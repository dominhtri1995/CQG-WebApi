// Code generated by protoc-gen-go. DO NOT EDIT.
// source: webapi_1.proto

/*
Package main is a generated protocol buffer package.

It is generated from these files:
	webapi_1.proto

It has these top-level messages:
	ClientMsg
	ServerMsg
	RealTimeCollapsing
	Logon
	LogonResult
	LogonRoutineClient
	LogonRoutineServer
	PasswordChangeRoutineClient
	PasswordChangeRoutineServer
	AbortRoutine
	LogonInit
	PasswordRequest
	PasswordResponse
	Encoding
	EncodingParameter
	RestoreOrJoinSession
	RestoreOrJoinSessionResult
	ConcurrentConnectionJoin
	Logoff
	LoggedOff
	PasswordChange
	PasswordChangeResult
	ObtainDemoCredentials
	ObtainDemoCredentialsResult
	UserMessage
	UserSessionStateRequest
	UserSessionStateResult
	Ping
	Pong
	StrategyDefinition
	ExchangeStrategy
	LegDefinition
	NestedStrategy
	StrategyNodeDefinition
	TickSizeByPrice
	TickSizeByDateTillExpiration
	ContractMetadata
	InformationRequest
	InformationReport
	AccountsRequest
	AccountsReport
	Brokerage
	SalesSeries
	Account
	SymbolResolutionRequest
	SymbolResolutionReport
	LastStatementBalancesRequest
	LastStatementBalancesReport
	Balance
	CurrencyRatesRequest
	CurrencyRatesReport
	BrokerageCurrencyRates
	CurrencyRate
	SessionInformationRequest
	SessionInformationReport
	SessionSegment
	SessionSchedule
	TradingDay
	SessionDay
	SessionHoliday
	SymbolsByUnderlyingRequest
	SymbolsByUnderlyingReport
	ChildSymbolsRequest
	ChildSymbolsReport
	AtTheMoneyStrikeRequest
	AtTheMoneyStrikeReport
	SessionTimeRangeRequest
	SessionTimeRangeReport
	SessionTimeRange
	TradingDayTimeRangeRequest
	TradingDayTimeRangeReport
	TradingDayTimeRange
	Symbol
	StrategyDefinitionRequest
	StrategyDefinitionReport
	TradeSubscription
	TradeSubscriptionStatus
	TradeSnapshotCompletion
	OrderRequest
	OrderRequestReject
	NewOrder
	Order
	UserAttribute
	SyntheticStrategyProperties
	ModifyOrder
	CancelOrder
	ActivateOrder
	ModifyUserAttributes
	NewCompoundOrder
	CompoundOrder
	CompoundOrderEntry
	SuspendOrder
	OrderStatus
	TransactionStatus
	Trade
	StrategyLegFill
	SyntheticHang
	CompoundOrderStructure
	CompoundOrderStructureEntry
	StrategyOrderLegParameters
	StrategyMarketOrderParameters
	PrimaryOrdersLimit
	PrimaryOrdersSniper
	SecondaryOrdersLimit
	SecondaryOrdersMarket
	SecondaryOrdersPayUp
	SecondaryOrdersTrailing
	LimitOrderLegDescription
	PriceShifting
	StrategyLimitOrderParameters
	StrategyStopOrderParameters
	MarketTakingParameters
	MarketMakingParameters
	AggregationLegDescription
	StrategyAggregationParameters
	StrategyTradingParameters
	PositionStatus
	OpenPosition
	PurchaseAndSalesGroup
	MatchedTrade
	CollateralStatus
	SyntheticLiquidate
	SyntheticScratch
	GoMarket
	MarketDataSubscription
	MarketDataSubscriptionStatus
	RealTimeMarketData
	Quote
	MarketValues
	ReadUserAttributeRequest
	ReadUserAttributeResult
	ModifyUserAttributeRequest
	ModifyUserAttributeResult
	TimeAndSalesParameters
	TimeAndSalesRequest
	TimeAndSalesReport
	TimeBarParameters
	TimeBarRequest
	TimeBar
	TimeBarReport
	VolumeProfileRequest
	VolumeProfileParameters
	VolumeProfileReport
	VolumeProfileItem
	HistoricalOrdersRequest
	HistoricalOrdersReport
*/
package main

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Last changes were made on 19 May 2017
// Version 1.68 - (version number is constructed as 'MAJOR.MINOR' from the following enums)
type ProtocolVersionMajor int32

const (
	// Major number change is required for backward incompatible protocol versions (new 'proto' file is necessary)
	ProtocolVersionMajor_PROTOCOL_VERSION_MAJOR ProtocolVersionMajor = 1
)

var ProtocolVersionMajor_name = map[int32]string{
	1: "PROTOCOL_VERSION_MAJOR",
}
var ProtocolVersionMajor_value = map[string]int32{
	"PROTOCOL_VERSION_MAJOR": 1,
}

func (x ProtocolVersionMajor) Enum() *ProtocolVersionMajor {
	p := new(ProtocolVersionMajor)
	*p = x
	return p
}
func (x ProtocolVersionMajor) String() string {
	return proto.EnumName(ProtocolVersionMajor_name, int32(x))
}
func (x *ProtocolVersionMajor) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ProtocolVersionMajor_value, data, "ProtocolVersionMajor")
	if err != nil {
		return err
	}
	*x = ProtocolVersionMajor(value)
	return nil
}
func (ProtocolVersionMajor) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type ProtocolVersionMinor int32

const (
	// Minor number is increased for backward compatible protocol versions when new messages and/ or fields are
	// added without removing/ changing any existing messages and fields (new 'proto' file is not created)
	ProtocolVersionMinor_PROTOCOL_VERSION_MINOR ProtocolVersionMinor = 68
)

var ProtocolVersionMinor_name = map[int32]string{
	68: "PROTOCOL_VERSION_MINOR",
}
var ProtocolVersionMinor_value = map[string]int32{
	"PROTOCOL_VERSION_MINOR": 68,
}

func (x ProtocolVersionMinor) Enum() *ProtocolVersionMinor {
	p := new(ProtocolVersionMinor)
	*p = x
	return p
}
func (x ProtocolVersionMinor) String() string {
	return proto.EnumName(ProtocolVersionMinor_name, int32(x))
}
func (x *ProtocolVersionMinor) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ProtocolVersionMinor_value, data, "ProtocolVersionMinor")
	if err != nil {
		return err
	}
	*x = ProtocolVersionMinor(value)
	return nil
}
func (ProtocolVersionMinor) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// Days of week enumeration.
type DayOfWeek int32

const (
	DayOfWeek_Sunday    DayOfWeek = 0
	DayOfWeek_Monday    DayOfWeek = 1
	DayOfWeek_Tuesday   DayOfWeek = 2
	DayOfWeek_Wednesday DayOfWeek = 3
	DayOfWeek_Thursday  DayOfWeek = 4
	DayOfWeek_Friday    DayOfWeek = 5
	DayOfWeek_Saturday  DayOfWeek = 6
)

var DayOfWeek_name = map[int32]string{
	0: "Sunday",
	1: "Monday",
	2: "Tuesday",
	3: "Wednesday",
	4: "Thursday",
	5: "Friday",
	6: "Saturday",
}
var DayOfWeek_value = map[string]int32{
	"Sunday":    0,
	"Monday":    1,
	"Tuesday":   2,
	"Wednesday": 3,
	"Thursday":  4,
	"Friday":    5,
	"Saturday":  6,
}

func (x DayOfWeek) Enum() *DayOfWeek {
	p := new(DayOfWeek)
	*p = x
	return p
}
func (x DayOfWeek) String() string {
	return proto.EnumName(DayOfWeek_name, int32(x))
}
func (x *DayOfWeek) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DayOfWeek_value, data, "DayOfWeek")
	if err != nil {
		return err
	}
	*x = DayOfWeek(value)
	return nil
}
func (DayOfWeek) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type RealTimeCollapsing_Level int32

const (
	// Collapsing is not not preferred.
	RealTimeCollapsing_NONE RealTimeCollapsing_Level = 0
	// DOM data is collapsed.
	RealTimeCollapsing_DOM RealTimeCollapsing_Level = 1
	// DOM and best bid/ ask quotes are collapsed delivering only last BBA but all trades.
	RealTimeCollapsing_DOM_BBA RealTimeCollapsing_Level = 2
	// DOM, best bid/ ask and trades quotes are collapsed delivering only last values.
	RealTimeCollapsing_DOM_BBA_TRADES RealTimeCollapsing_Level = 3
)

var RealTimeCollapsing_Level_name = map[int32]string{
	0: "NONE",
	1: "DOM",
	2: "DOM_BBA",
	3: "DOM_BBA_TRADES",
}
var RealTimeCollapsing_Level_value = map[string]int32{
	"NONE":           0,
	"DOM":            1,
	"DOM_BBA":        2,
	"DOM_BBA_TRADES": 3,
}

func (x RealTimeCollapsing_Level) Enum() *RealTimeCollapsing_Level {
	p := new(RealTimeCollapsing_Level)
	*p = x
	return p
}
func (x RealTimeCollapsing_Level) String() string {
	return proto.EnumName(RealTimeCollapsing_Level_name, int32(x))
}
func (x *RealTimeCollapsing_Level) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RealTimeCollapsing_Level_value, data, "RealTimeCollapsing_Level")
	if err != nil {
		return err
	}
	*x = RealTimeCollapsing_Level(value)
	return nil
}
func (RealTimeCollapsing_Level) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type Logon_SessionSetting int32

const (
	// Allows restoring session in case of an accidental disconnect (see RestoreOrJoinSession message).
	// If the setting is not specified then termination of the last connection also terminates the session without ability to restore it.
	// For security reasons clients should not specify this setting without using the restore session functionality.
	Logon_ALLOW_SESSION_RESTORE Logon_SessionSetting = 1
	// Allows other new connections to join the session (see RestoreOrJoinSession message) and work concurrently.
	// If the setting is not specified then the session can have only one connection at each moment and a new connection pushes the old one out (if the session restore is allowed).
	// For security reasons clients should not specify this setting without using join session functionality.
	Logon_ALLOW_SESSION_JOIN Logon_SessionSetting = 2
)

var Logon_SessionSetting_name = map[int32]string{
	1: "ALLOW_SESSION_RESTORE",
	2: "ALLOW_SESSION_JOIN",
}
var Logon_SessionSetting_value = map[string]int32{
	"ALLOW_SESSION_RESTORE": 1,
	"ALLOW_SESSION_JOIN":    2,
}

func (x Logon_SessionSetting) Enum() *Logon_SessionSetting {
	p := new(Logon_SessionSetting)
	*p = x
	return p
}
func (x Logon_SessionSetting) String() string {
	return proto.EnumName(Logon_SessionSetting_name, int32(x))
}
func (x *Logon_SessionSetting) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Logon_SessionSetting_value, data, "Logon_SessionSetting")
	if err != nil {
		return err
	}
	*x = Logon_SessionSetting(value)
	return nil
}
func (Logon_SessionSetting) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

type LogonResult_ResultCode int32

const (
	// // success codes
	// User is logged in to the system.
	LogonResult_SUCCESS LogonResult_ResultCode = 0
	// // failure codes (100+)
	// General failure.
	LogonResult_FAILURE LogonResult_ResultCode = 101
	// One-time password is required for this user but it was not sent, repeat logon
	// with one-time password.
	LogonResult_NO_ONETIME_PASSWORD LogonResult_ResultCode = 103
	// User password is expired, only change password operation is allowed.
	LogonResult_PASSWORD_EXPIRED LogonResult_ResultCode = 104
	// Failed because this user has a concurrent session that is
	// not allowed for this application and drop was not requested.
	LogonResult_CONCURRENT_SESSION LogonResult_ResultCode = 105
	// Client is redirected to a different server, new server is specified in redirectUrl.
	LogonResult_REDIRECTED LogonResult_ResultCode = 106
	// The negotiation rules for LogonRoutineClient have been violated, e.g. user has specified several fields at once in one message.
	LogonResult_ROUTINE_ERROR LogonResult_ResultCode = 107
)

var LogonResult_ResultCode_name = map[int32]string{
	0:   "SUCCESS",
	101: "FAILURE",
	103: "NO_ONETIME_PASSWORD",
	104: "PASSWORD_EXPIRED",
	105: "CONCURRENT_SESSION",
	106: "REDIRECTED",
	107: "ROUTINE_ERROR",
}
var LogonResult_ResultCode_value = map[string]int32{
	"SUCCESS":             0,
	"FAILURE":             101,
	"NO_ONETIME_PASSWORD": 103,
	"PASSWORD_EXPIRED":    104,
	"CONCURRENT_SESSION":  105,
	"REDIRECTED":          106,
	"ROUTINE_ERROR":       107,
}

func (x LogonResult_ResultCode) Enum() *LogonResult_ResultCode {
	p := new(LogonResult_ResultCode)
	*p = x
	return p
}
func (x LogonResult_ResultCode) String() string {
	return proto.EnumName(LogonResult_ResultCode_name, int32(x))
}
func (x *LogonResult_ResultCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LogonResult_ResultCode_value, data, "LogonResult_ResultCode")
	if err != nil {
		return err
	}
	*x = LogonResult_ResultCode(value)
	return nil
}
func (LogonResult_ResultCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type PasswordRequest_PasswordType int32

const (
	// Currently used password.
	PasswordRequest_STATIC PasswordRequest_PasswordType = 1
	// One-time password.
	PasswordRequest_ONE_TIME PasswordRequest_PasswordType = 2
	// New password that user wants to use. Can be specified only in result of PasswordChangeRoutineClient.
	PasswordRequest_NEW_STATIC PasswordRequest_PasswordType = 3
	// Currently used password and new password that user wants to use. Can be specified only in result of PasswordChangeRoutineClient.
	PasswordRequest_CUR_AND_NEW_STATIC PasswordRequest_PasswordType = 4
	// Non-password request with question e.g. "What is your favourite pet?".
	PasswordRequest_TEXT PasswordRequest_PasswordType = 5
)

var PasswordRequest_PasswordType_name = map[int32]string{
	1: "STATIC",
	2: "ONE_TIME",
	3: "NEW_STATIC",
	4: "CUR_AND_NEW_STATIC",
	5: "TEXT",
}
var PasswordRequest_PasswordType_value = map[string]int32{
	"STATIC":             1,
	"ONE_TIME":           2,
	"NEW_STATIC":         3,
	"CUR_AND_NEW_STATIC": 4,
	"TEXT":               5,
}

func (x PasswordRequest_PasswordType) Enum() *PasswordRequest_PasswordType {
	p := new(PasswordRequest_PasswordType)
	*p = x
	return p
}
func (x PasswordRequest_PasswordType) String() string {
	return proto.EnumName(PasswordRequest_PasswordType_name, int32(x))
}
func (x *PasswordRequest_PasswordType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PasswordRequest_PasswordType_value, data, "PasswordRequest_PasswordType")
	if err != nil {
		return err
	}
	*x = PasswordRequest_PasswordType(value)
	return nil
}
func (PasswordRequest_PasswordType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{11, 0}
}

type RestoreOrJoinSessionResult_ResultCode int32

const (
	// // success codes
	// User is logged in to the system.
	RestoreOrJoinSessionResult_SUCCESS RestoreOrJoinSessionResult_ResultCode = 0
	// // failure codes (100+)
	// General failure.
	RestoreOrJoinSessionResult_FAILURE RestoreOrJoinSessionResult_ResultCode = 104
	// Session is unknown to a server, client must perform standard logon procedure.
	RestoreOrJoinSessionResult_UNKNOWN_SESSION RestoreOrJoinSessionResult_ResultCode = 101
	// User is not allowed to perform session restore/join or the maximum connection number has been exceeded.
	RestoreOrJoinSessionResult_ACCESS_DENIED RestoreOrJoinSessionResult_ResultCode = 102
	// Some RestoreOrJoinSession message fields were not filled.
	RestoreOrJoinSessionResult_INVALID_PARAMS RestoreOrJoinSessionResult_ResultCode = 103
)

var RestoreOrJoinSessionResult_ResultCode_name = map[int32]string{
	0:   "SUCCESS",
	104: "FAILURE",
	101: "UNKNOWN_SESSION",
	102: "ACCESS_DENIED",
	103: "INVALID_PARAMS",
}
var RestoreOrJoinSessionResult_ResultCode_value = map[string]int32{
	"SUCCESS":         0,
	"FAILURE":         104,
	"UNKNOWN_SESSION": 101,
	"ACCESS_DENIED":   102,
	"INVALID_PARAMS":  103,
}

func (x RestoreOrJoinSessionResult_ResultCode) Enum() *RestoreOrJoinSessionResult_ResultCode {
	p := new(RestoreOrJoinSessionResult_ResultCode)
	*p = x
	return p
}
func (x RestoreOrJoinSessionResult_ResultCode) String() string {
	return proto.EnumName(RestoreOrJoinSessionResult_ResultCode_name, int32(x))
}
func (x *RestoreOrJoinSessionResult_ResultCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RestoreOrJoinSessionResult_ResultCode_value, data, "RestoreOrJoinSessionResult_ResultCode")
	if err != nil {
		return err
	}
	*x = RestoreOrJoinSessionResult_ResultCode(value)
	return nil
}
func (RestoreOrJoinSessionResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{16, 0}
}

type LoggedOff_LogoffReason int32

const (
	// User is logged off by client request.
	LoggedOff_BY_REQUEST LoggedOff_LogoffReason = 1
	// User is redirected to another URL.
	LoggedOff_REDIRECTED LoggedOff_LogoffReason = 2
	// System logged off the user because of some server side Reason.
	LoggedOff_FORCED LoggedOff_LogoffReason = 3
	// System logged off the user because this session was re-assigned to another connection
	// that took it over by 'restore session' operation
	LoggedOff_REASSIGNED LoggedOff_LogoffReason = 4
)

var LoggedOff_LogoffReason_name = map[int32]string{
	1: "BY_REQUEST",
	2: "REDIRECTED",
	3: "FORCED",
	4: "REASSIGNED",
}
var LoggedOff_LogoffReason_value = map[string]int32{
	"BY_REQUEST": 1,
	"REDIRECTED": 2,
	"FORCED":     3,
	"REASSIGNED": 4,
}

func (x LoggedOff_LogoffReason) Enum() *LoggedOff_LogoffReason {
	p := new(LoggedOff_LogoffReason)
	*p = x
	return p
}
func (x LoggedOff_LogoffReason) String() string {
	return proto.EnumName(LoggedOff_LogoffReason_name, int32(x))
}
func (x *LoggedOff_LogoffReason) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LoggedOff_LogoffReason_value, data, "LoggedOff_LogoffReason")
	if err != nil {
		return err
	}
	*x = LoggedOff_LogoffReason(value)
	return nil
}
func (LoggedOff_LogoffReason) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{19, 0} }

// Password change result.
type PasswordChangeResult_ResultCode int32

const (
	// / success codes
	// User password is changed successfully.
	PasswordChangeResult_SUCCESS PasswordChangeResult_ResultCode = 0
	// / failure codes (100+)
	// Incorrect user name or password.
	PasswordChangeResult_FAILURE PasswordChangeResult_ResultCode = 101
	// The negotiation rules for PasswordChangeRoutineClient have been violated, e.g. user has specified several fields at once in one message.
	PasswordChangeResult_ROUTINE_ERROR PasswordChangeResult_ResultCode = 102
)

var PasswordChangeResult_ResultCode_name = map[int32]string{
	0:   "SUCCESS",
	101: "FAILURE",
	102: "ROUTINE_ERROR",
}
var PasswordChangeResult_ResultCode_value = map[string]int32{
	"SUCCESS":       0,
	"FAILURE":       101,
	"ROUTINE_ERROR": 102,
}

func (x PasswordChangeResult_ResultCode) Enum() *PasswordChangeResult_ResultCode {
	p := new(PasswordChangeResult_ResultCode)
	*p = x
	return p
}
func (x PasswordChangeResult_ResultCode) String() string {
	return proto.EnumName(PasswordChangeResult_ResultCode_name, int32(x))
}
func (x *PasswordChangeResult_ResultCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PasswordChangeResult_ResultCode_value, data, "PasswordChangeResult_ResultCode")
	if err != nil {
		return err
	}
	*x = PasswordChangeResult_ResultCode(value)
	return nil
}
func (PasswordChangeResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{21, 0}
}

// Password change result.
type ObtainDemoCredentialsResult_ResultCode int32

const (
	// / success codes (0 - 100)
	ObtainDemoCredentialsResult_SUCCESS ObtainDemoCredentialsResult_ResultCode = 0
	// / failure codes (100+)
	ObtainDemoCredentialsResult_FAILURE ObtainDemoCredentialsResult_ResultCode = 101
)

var ObtainDemoCredentialsResult_ResultCode_name = map[int32]string{
	0:   "SUCCESS",
	101: "FAILURE",
}
var ObtainDemoCredentialsResult_ResultCode_value = map[string]int32{
	"SUCCESS": 0,
	"FAILURE": 101,
}

func (x ObtainDemoCredentialsResult_ResultCode) Enum() *ObtainDemoCredentialsResult_ResultCode {
	p := new(ObtainDemoCredentialsResult_ResultCode)
	*p = x
	return p
}
func (x ObtainDemoCredentialsResult_ResultCode) String() string {
	return proto.EnumName(ObtainDemoCredentialsResult_ResultCode_name, int32(x))
}
func (x *ObtainDemoCredentialsResult_ResultCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ObtainDemoCredentialsResult_ResultCode_value, data, "ObtainDemoCredentialsResult_ResultCode")
	if err != nil {
		return err
	}
	*x = ObtainDemoCredentialsResult_ResultCode(value)
	return nil
}
func (ObtainDemoCredentialsResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{23, 0}
}

// Type of the message.
type UserMessage_MessageType int32

const (
	// Critical error message.
	UserMessage_CRITICAL_ERROR UserMessage_MessageType = 1
	// Warning.
	UserMessage_WARNING UserMessage_MessageType = 2
	// General information.
	UserMessage_INFO UserMessage_MessageType = 3
	// This message shouldn't be visible for users, only dumped into a log file.
	UserMessage_LOG UserMessage_MessageType = 4
)

var UserMessage_MessageType_name = map[int32]string{
	1: "CRITICAL_ERROR",
	2: "WARNING",
	3: "INFO",
	4: "LOG",
}
var UserMessage_MessageType_value = map[string]int32{
	"CRITICAL_ERROR": 1,
	"WARNING":        2,
	"INFO":           3,
	"LOG":            4,
}

func (x UserMessage_MessageType) Enum() *UserMessage_MessageType {
	p := new(UserMessage_MessageType)
	*p = x
	return p
}
func (x UserMessage_MessageType) String() string {
	return proto.EnumName(UserMessage_MessageType_name, int32(x))
}
func (x *UserMessage_MessageType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(UserMessage_MessageType_value, data, "UserMessage_MessageType")
	if err != nil {
		return err
	}
	*x = UserMessage_MessageType(value)
	return nil
}
func (UserMessage_MessageType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{24, 0} }

type UserSessionStateResult_ResultCode int32

const (
	// // success codes
	// Data for requested session is found.
	UserSessionStateResult_SUCCESS UserSessionStateResult_ResultCode = 0
	// // failure codes (100+)
	// General failure.
	UserSessionStateResult_FAILURE UserSessionStateResult_ResultCode = 101
	// Session is unknown to a server.
	UserSessionStateResult_UNKNOWN_SESSION UserSessionStateResult_ResultCode = 102
	// The user is not allowed to access this data.
	UserSessionStateResult_ACCESS_DENIED UserSessionStateResult_ResultCode = 103
)

var UserSessionStateResult_ResultCode_name = map[int32]string{
	0:   "SUCCESS",
	101: "FAILURE",
	102: "UNKNOWN_SESSION",
	103: "ACCESS_DENIED",
}
var UserSessionStateResult_ResultCode_value = map[string]int32{
	"SUCCESS":         0,
	"FAILURE":         101,
	"UNKNOWN_SESSION": 102,
	"ACCESS_DENIED":   103,
}

func (x UserSessionStateResult_ResultCode) Enum() *UserSessionStateResult_ResultCode {
	p := new(UserSessionStateResult_ResultCode)
	*p = x
	return p
}
func (x UserSessionStateResult_ResultCode) String() string {
	return proto.EnumName(UserSessionStateResult_ResultCode_name, int32(x))
}
func (x *UserSessionStateResult_ResultCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(UserSessionStateResult_ResultCode_value, data, "UserSessionStateResult_ResultCode")
	if err != nil {
		return err
	}
	*x = UserSessionStateResult_ResultCode(value)
	return nil
}
func (UserSessionStateResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{26, 0}
}

// Using a fractional trade ratio may result in fractional lots. If so, the number of lots has to be rounded.
// Rounding applies only to complex strategies with fractional quantity ratios.
type StrategyDefinition_RoundLegMode int32

const (
	// always round down, e.g. 1.1 -> 1 and -2.1 -> -2
	StrategyDefinition_DOWN StrategyDefinition_RoundLegMode = 1
	// always round up, e.g. 1.1 -> 2 and -2.1 -> -3
	StrategyDefinition_UP StrategyDefinition_RoundLegMode = 2
	// round up when fractional part is 5 or greater; round down when fractional part is less than 5, e.g. 1.1 -> 1 and 1.6 -> 2
	StrategyDefinition_MATH StrategyDefinition_RoundLegMode = 3
)

var StrategyDefinition_RoundLegMode_name = map[int32]string{
	1: "DOWN",
	2: "UP",
	3: "MATH",
}
var StrategyDefinition_RoundLegMode_value = map[string]int32{
	"DOWN": 1,
	"UP":   2,
	"MATH": 3,
}

func (x StrategyDefinition_RoundLegMode) Enum() *StrategyDefinition_RoundLegMode {
	p := new(StrategyDefinition_RoundLegMode)
	*p = x
	return p
}
func (x StrategyDefinition_RoundLegMode) String() string {
	return proto.EnumName(StrategyDefinition_RoundLegMode_name, int32(x))
}
func (x *StrategyDefinition_RoundLegMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(StrategyDefinition_RoundLegMode_value, data, "StrategyDefinition_RoundLegMode")
	if err != nil {
		return err
	}
	*x = StrategyDefinition_RoundLegMode(value)
	return nil
}
func (StrategyDefinition_RoundLegMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{29, 0}
}

// Operation on a node of the synthetic strategy.
// Associating an operation with a node allows using different operations, e.g. multiplication and subtraction,
// without introducing intermediate StrategyDefinition entities.
// MUL and DIV cannot be mixed with SUM within the same StrategyDefinition.node_definition array.
// i.e. node1 / node2 * node3 is allowed, but node1 / node2 + node3 is not.
type StrategyNodeDefinition_NodeOperation int32

const (
	// Add the quantity and the price.
	StrategyNodeDefinition_SUM StrategyNodeDefinition_NodeOperation = 1
	// Add the quantity but multiply the price.
	StrategyNodeDefinition_MUL StrategyNodeDefinition_NodeOperation = 2
	// Subtract the quantity but divide the price.
	StrategyNodeDefinition_DIV StrategyNodeDefinition_NodeOperation = 3
)

var StrategyNodeDefinition_NodeOperation_name = map[int32]string{
	1: "SUM",
	2: "MUL",
	3: "DIV",
}
var StrategyNodeDefinition_NodeOperation_value = map[string]int32{
	"SUM": 1,
	"MUL": 2,
	"DIV": 3,
}

func (x StrategyNodeDefinition_NodeOperation) Enum() *StrategyNodeDefinition_NodeOperation {
	p := new(StrategyNodeDefinition_NodeOperation)
	*p = x
	return p
}
func (x StrategyNodeDefinition_NodeOperation) String() string {
	return proto.EnumName(StrategyNodeDefinition_NodeOperation_name, int32(x))
}
func (x *StrategyNodeDefinition_NodeOperation) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(StrategyNodeDefinition_NodeOperation_value, data, "StrategyNodeDefinition_NodeOperation")
	if err != nil {
		return err
	}
	*x = StrategyNodeDefinition_NodeOperation(value)
	return nil
}
func (StrategyNodeDefinition_NodeOperation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{33, 0}
}

// Margin style (for options).
type ContractMetadata_MarginStyle int32

const (
	// The premium is paid on exercise/ expiry (position is included to OTE calculation).
	ContractMetadata_FUTURE ContractMetadata_MarginStyle = 1
	// Premium is subtracted from Username balance when order is filled (position is included to MVO/UPL calculation).
	ContractMetadata_PREMIUM ContractMetadata_MarginStyle = 2
)

var ContractMetadata_MarginStyle_name = map[int32]string{
	1: "FUTURE",
	2: "PREMIUM",
}
var ContractMetadata_MarginStyle_value = map[string]int32{
	"FUTURE":  1,
	"PREMIUM": 2,
}

func (x ContractMetadata_MarginStyle) Enum() *ContractMetadata_MarginStyle {
	p := new(ContractMetadata_MarginStyle)
	*p = x
	return p
}
func (x ContractMetadata_MarginStyle) String() string {
	return proto.EnumName(ContractMetadata_MarginStyle_name, int32(x))
}
func (x *ContractMetadata_MarginStyle) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ContractMetadata_MarginStyle_value, data, "ContractMetadata_MarginStyle")
	if err != nil {
		return err
	}
	*x = ContractMetadata_MarginStyle(value)
	return nil
}
func (ContractMetadata_MarginStyle) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{36, 0}
}

// Optional Status code for a request or subscription, Status is only sent for initial Status and Status changes.
type InformationReport_StatusCode int32

const (
	// / success codes  (0 - 99)
	// Request is processed without subscription (subscription was not requested).
	InformationReport_SUCCESS InformationReport_StatusCode = 0
	// Request is processed and subscription is established.
	InformationReport_SUBSCRIBED InformationReport_StatusCode = 1
	// Subscription is dropped by a client request.
	InformationReport_DROPPED InformationReport_StatusCode = 2
	// Unsolicited information update because of subscription.
	InformationReport_UPDATE InformationReport_StatusCode = 3
	// Currently subscription is disconnect because of communication issues
	// NOTE: Clients should not resubscribe in this case, the server will restore subscription with
	// sending SUBSCRIBED Status once communication issues are resolved
	InformationReport_DISCONNECTED InformationReport_StatusCode = 4
	// / failure codes (100+), subscription (if any) is dropped in case of failure.
	// General failure.
	InformationReport_FAILURE InformationReport_StatusCode = 101
	// Requested information is not found.
	InformationReport_NOT_FOUND InformationReport_StatusCode = 104
	// The limit of the request number has been violated.
	InformationReport_REQUEST_LIMIT_VIOLATION InformationReport_StatusCode = 105
)

var InformationReport_StatusCode_name = map[int32]string{
	0:   "SUCCESS",
	1:   "SUBSCRIBED",
	2:   "DROPPED",
	3:   "UPDATE",
	4:   "DISCONNECTED",
	101: "FAILURE",
	104: "NOT_FOUND",
	105: "REQUEST_LIMIT_VIOLATION",
}
var InformationReport_StatusCode_value = map[string]int32{
	"SUCCESS":                 0,
	"SUBSCRIBED":              1,
	"DROPPED":                 2,
	"UPDATE":                  3,
	"DISCONNECTED":            4,
	"FAILURE":                 101,
	"NOT_FOUND":               104,
	"REQUEST_LIMIT_VIOLATION": 105,
}

func (x InformationReport_StatusCode) Enum() *InformationReport_StatusCode {
	p := new(InformationReport_StatusCode)
	*p = x
	return p
}
func (x InformationReport_StatusCode) String() string {
	return proto.EnumName(InformationReport_StatusCode_name, int32(x))
}
func (x *InformationReport_StatusCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(InformationReport_StatusCode_value, data, "InformationReport_StatusCode")
	if err != nil {
		return err
	}
	*x = InformationReport_StatusCode(value)
	return nil
}
func (InformationReport_StatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{38, 0}
}

// Scope of the subscription (provide a list).
type TradeSubscription_SubscriptionScope int32

const (
	// Subscribe to order updates.
	TradeSubscription_ORDERS TradeSubscription_SubscriptionScope = 1
	// Subscribe to open positions and matched trades updates.
	TradeSubscription_POSITIONS TradeSubscription_SubscriptionScope = 2
	// Subscribe to collateral updates (current margin and purchasing power).
	TradeSubscription_COLLATERAL TradeSubscription_SubscriptionScope = 3
)

var TradeSubscription_SubscriptionScope_name = map[int32]string{
	1: "ORDERS",
	2: "POSITIONS",
	3: "COLLATERAL",
}
var TradeSubscription_SubscriptionScope_value = map[string]int32{
	"ORDERS":     1,
	"POSITIONS":  2,
	"COLLATERAL": 3,
}

func (x TradeSubscription_SubscriptionScope) Enum() *TradeSubscription_SubscriptionScope {
	p := new(TradeSubscription_SubscriptionScope)
	*p = x
	return p
}
func (x TradeSubscription_SubscriptionScope) String() string {
	return proto.EnumName(TradeSubscription_SubscriptionScope_name, int32(x))
}
func (x *TradeSubscription_SubscriptionScope) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TradeSubscription_SubscriptionScope_value, data, "TradeSubscription_SubscriptionScope")
	if err != nil {
		return err
	}
	*x = TradeSubscription_SubscriptionScope(value)
	return nil
}
func (TradeSubscription_SubscriptionScope) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{75, 0}
}

// Type of the publication to subscribe.
type TradeSubscription_PublicationType int32

const (
	// Subscribe to a single Username.
	TradeSubscription_ACCOUNT TradeSubscription_PublicationType = 1
	// Subscribe to all accounts of a specific sales series.
	TradeSubscription_SALES_SERIES TradeSubscription_PublicationType = 2
	// Subscribe to all accounts of a specific brokerage.
	TradeSubscription_BROKERAGE TradeSubscription_PublicationType = 3
	// Subscribe to all accounts this user is authorized for (default).
	TradeSubscription_ALL_AUTHORIZED TradeSubscription_PublicationType = 4
)

var TradeSubscription_PublicationType_name = map[int32]string{
	1: "ACCOUNT",
	2: "SALES_SERIES",
	3: "BROKERAGE",
	4: "ALL_AUTHORIZED",
}
var TradeSubscription_PublicationType_value = map[string]int32{
	"ACCOUNT":        1,
	"SALES_SERIES":   2,
	"BROKERAGE":      3,
	"ALL_AUTHORIZED": 4,
}

func (x TradeSubscription_PublicationType) Enum() *TradeSubscription_PublicationType {
	p := new(TradeSubscription_PublicationType)
	*p = x
	return p
}
func (x TradeSubscription_PublicationType) String() string {
	return proto.EnumName(TradeSubscription_PublicationType_name, int32(x))
}
func (x *TradeSubscription_PublicationType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TradeSubscription_PublicationType_value, data, "TradeSubscription_PublicationType")
	if err != nil {
		return err
	}
	*x = TradeSubscription_PublicationType(value)
	return nil
}
func (TradeSubscription_PublicationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{75, 1}
}

// Positions matching algorithm (for position subscription).
type TradeSubscription_MatchingAlgorithm int32

const (
	// First In, First Out. The first order filled is the first order offset when an order on the opposite side of the market is executed.
	TradeSubscription_FIFO TradeSubscription_MatchingAlgorithm = 1
	// High Buy, High Sell. The highest buy is matched with the highest sell.
	TradeSubscription_HBHS TradeSubscription_MatchingAlgorithm = 2
	// Last In, First Out. The last order filled is the first order offset when an order on the opposite side of the market is executed.
	TradeSubscription_LIFO TradeSubscription_MatchingAlgorithm = 3
)

var TradeSubscription_MatchingAlgorithm_name = map[int32]string{
	1: "FIFO",
	2: "HBHS",
	3: "LIFO",
}
var TradeSubscription_MatchingAlgorithm_value = map[string]int32{
	"FIFO": 1,
	"HBHS": 2,
	"LIFO": 3,
}

func (x TradeSubscription_MatchingAlgorithm) Enum() *TradeSubscription_MatchingAlgorithm {
	p := new(TradeSubscription_MatchingAlgorithm)
	*p = x
	return p
}
func (x TradeSubscription_MatchingAlgorithm) String() string {
	return proto.EnumName(TradeSubscription_MatchingAlgorithm_name, int32(x))
}
func (x *TradeSubscription_MatchingAlgorithm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TradeSubscription_MatchingAlgorithm_value, data, "TradeSubscription_MatchingAlgorithm")
	if err != nil {
		return err
	}
	*x = TradeSubscription_MatchingAlgorithm(value)
	return nil
}
func (TradeSubscription_MatchingAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{75, 2}
}

// Possible result codes.
type TradeSubscriptionStatus_StatusCode int32

const (
	// success codes (0 - 99)
	TradeSubscriptionStatus_SUCCESS TradeSubscriptionStatus_StatusCode = 0
	// Currently subscription is [partially] disconnect because of communication issues
	// NOTE: Clients should not resubscribe in this case, the server will restore subscription with
	// sending SUCCESS Status once communication issues are resolved following with all necessary data updates
	TradeSubscriptionStatus_DISCONNECTED TradeSubscriptionStatus_StatusCode = 1
	// failure codes (100+)
	TradeSubscriptionStatus_FAILURE TradeSubscriptionStatus_StatusCode = 101
	// The limit of the request number has been violated.
	TradeSubscriptionStatus_REQUEST_LIMIT_VIOLATION TradeSubscriptionStatus_StatusCode = 102
)

var TradeSubscriptionStatus_StatusCode_name = map[int32]string{
	0:   "SUCCESS",
	1:   "DISCONNECTED",
	101: "FAILURE",
	102: "REQUEST_LIMIT_VIOLATION",
}
var TradeSubscriptionStatus_StatusCode_value = map[string]int32{
	"SUCCESS":                 0,
	"DISCONNECTED":            1,
	"FAILURE":                 101,
	"REQUEST_LIMIT_VIOLATION": 102,
}

func (x TradeSubscriptionStatus_StatusCode) Enum() *TradeSubscriptionStatus_StatusCode {
	p := new(TradeSubscriptionStatus_StatusCode)
	*p = x
	return p
}
func (x TradeSubscriptionStatus_StatusCode) String() string {
	return proto.EnumName(TradeSubscriptionStatus_StatusCode_name, int32(x))
}
func (x *TradeSubscriptionStatus_StatusCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TradeSubscriptionStatus_StatusCode_value, data, "TradeSubscriptionStatus_StatusCode")
	if err != nil {
		return err
	}
	*x = TradeSubscriptionStatus_StatusCode(value)
	return nil
}
func (TradeSubscriptionStatus_StatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{76, 0}
}

type Order_Side int32

const (
	// Describes purchasing side of a trade.
	Order_BUY Order_Side = 1
	// Describes selling side of a trade.
	Order_SELL Order_Side = 2
)

var Order_Side_name = map[int32]string{
	1: "BUY",
	2: "SELL",
}
var Order_Side_value = map[string]int32{
	"BUY":  1,
	"SELL": 2,
}

func (x Order_Side) Enum() *Order_Side {
	p := new(Order_Side)
	*p = x
	return p
}
func (x Order_Side) String() string {
	return proto.EnumName(Order_Side_name, int32(x))
}
func (x *Order_Side) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Order_Side_value, data, "Order_Side")
	if err != nil {
		return err
	}
	*x = Order_Side(value)
	return nil
}
func (Order_Side) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{81, 0} }

type Order_OrderType int32

const (
	// Market order, buy or sell by the best available opposite price.
	Order_MKT Order_OrderType = 1
	// Limit order, buy or sell by price that is the same or better then specified limit price.
	Order_LMT Order_OrderType = 2
	// Stop order, Order becomes a Market when market reaches order's stop price
	// (which is on opposite side of market).
	Order_STP Order_OrderType = 3
	// Stop-limit order, Order becomes a Limit when market reaches order's stop price.
	Order_STL Order_OrderType = 4
)

var Order_OrderType_name = map[int32]string{
	1: "MKT",
	2: "LMT",
	3: "STP",
	4: "STL",
}
var Order_OrderType_value = map[string]int32{
	"MKT": 1,
	"LMT": 2,
	"STP": 3,
	"STL": 4,
}

func (x Order_OrderType) Enum() *Order_OrderType {
	p := new(Order_OrderType)
	*p = x
	return p
}
func (x Order_OrderType) String() string {
	return proto.EnumName(Order_OrderType_name, int32(x))
}
func (x *Order_OrderType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Order_OrderType_value, data, "Order_OrderType")
	if err != nil {
		return err
	}
	*x = Order_OrderType(value)
	return nil
}
func (Order_OrderType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{81, 1} }

type Order_ExecInstruction int32

const (
	// All or None (fill order only completely).
	Order_AON Order_ExecInstruction = 1
	// Iceberg (show only part of order size).
	Order_ICEBERG Order_ExecInstruction = 2
	// Quantity triggered (aka DOM Triggered, honor additional quantity threshold for triggering).
	Order_QT Order_ExecInstruction = 3
	// Trailing order (price of the order is following market one direction by specific offset).
	Order_TRAIL Order_ExecInstruction = 4
	// Funari (Limit order becomes a Market on Close).
	Order_FUNARI Order_ExecInstruction = 5
	// Market if Touched (Limit order becomes a Market when market reaches order's limit price).
	Order_MIT Order_ExecInstruction = 6
	// Market Limit Market is a limit order that is used to place a buy order above the best offer
	// to fill by the best offer or a sell order below the best bid to fill by the best bid.
	Order_MLM Order_ExecInstruction = 7
)

var Order_ExecInstruction_name = map[int32]string{
	1: "AON",
	2: "ICEBERG",
	3: "QT",
	4: "TRAIL",
	5: "FUNARI",
	6: "MIT",
	7: "MLM",
}
var Order_ExecInstruction_value = map[string]int32{
	"AON":     1,
	"ICEBERG": 2,
	"QT":      3,
	"TRAIL":   4,
	"FUNARI":  5,
	"MIT":     6,
	"MLM":     7,
}

func (x Order_ExecInstruction) Enum() *Order_ExecInstruction {
	p := new(Order_ExecInstruction)
	*p = x
	return p
}
func (x Order_ExecInstruction) String() string {
	return proto.EnumName(Order_ExecInstruction_name, int32(x))
}
func (x *Order_ExecInstruction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Order_ExecInstruction_value, data, "Order_ExecInstruction")
	if err != nil {
		return err
	}
	*x = Order_ExecInstruction(value)
	return nil
}
func (Order_ExecInstruction) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{81, 2} }

type Order_Duration int32

const (
	// Day order. Order is working through the current trading day only.
	Order_DAY Order_Duration = 1
	// Good Til Canceled. Order is working until canceled or until the contract is no longer available for trading.
	Order_GTC Order_Duration = 2
	// Good Til Date. Order is working until the end of the nearest trading day for the contract on
	// or before the date specified in the order.
	Order_GTD Order_Duration = 3
	// Good Til Time. Order is working until the specified time.
	Order_GTT Order_Duration = 4
	// Fill and Kill. Immediately fill as many as possible and cancel the rest.
	Order_FAK Order_Duration = 5
	// Fill Or Kill. Immediately fill this order completely or cancel.
	Order_FOK Order_Duration = 6
	// At The Open. Buy or sell at the very beginning of the trading day.
	Order_ATO Order_Duration = 7
	// At The Close. Buy or sell at the close of the market, or as near to the closing price as possible.
	Order_ATC Order_Duration = 8
)

var Order_Duration_name = map[int32]string{
	1: "DAY",
	2: "GTC",
	3: "GTD",
	4: "GTT",
	5: "FAK",
	6: "FOK",
	7: "ATO",
	8: "ATC",
}
var Order_Duration_value = map[string]int32{
	"DAY": 1,
	"GTC": 2,
	"GTD": 3,
	"GTT": 4,
	"FAK": 5,
	"FOK": 6,
	"ATO": 7,
	"ATC": 8,
}

func (x Order_Duration) Enum() *Order_Duration {
	p := new(Order_Duration)
	*p = x
	return p
}
func (x Order_Duration) String() string {
	return proto.EnumName(Order_Duration_name, int32(x))
}
func (x *Order_Duration) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Order_Duration_value, data, "Order_Duration")
	if err != nil {
		return err
	}
	*x = Order_Duration(value)
	return nil
}
func (Order_Duration) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{81, 3} }

type Order_TrailingPeg int32

const (
	// Trail the best bid.
	Order_BESTBID Order_TrailingPeg = 1
	// Trail the best ask.
	Order_BESTASK Order_TrailingPeg = 2
	// Trail the last trade.
	Order_LASTTRADE Order_TrailingPeg = 3
)

var Order_TrailingPeg_name = map[int32]string{
	1: "BESTBID",
	2: "BESTASK",
	3: "LASTTRADE",
}
var Order_TrailingPeg_value = map[string]int32{
	"BESTBID":   1,
	"BESTASK":   2,
	"LASTTRADE": 3,
}

func (x Order_TrailingPeg) Enum() *Order_TrailingPeg {
	p := new(Order_TrailingPeg)
	*p = x
	return p
}
func (x Order_TrailingPeg) String() string {
	return proto.EnumName(Order_TrailingPeg_name, int32(x))
}
func (x *Order_TrailingPeg) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Order_TrailingPeg_value, data, "Order_TrailingPeg")
	if err != nil {
		return err
	}
	*x = Order_TrailingPeg(value)
	return nil
}
func (Order_TrailingPeg) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{81, 4} }

// Type of the compound order.
type CompoundOrder_Type int32

const (
	// Order Places Order.
	// [Partial] fill of the first entry triggers [partial] placement of all other orders.
	CompoundOrder_OPO CompoundOrder_Type = 1
	// Order Cancels Order. This type allows several compound order entires.
	// [Partial] fill of any order triggers [partial] canceling of all other orders.
	CompoundOrder_OCO CompoundOrder_Type = 2
)

var CompoundOrder_Type_name = map[int32]string{
	1: "OPO",
	2: "OCO",
}
var CompoundOrder_Type_value = map[string]int32{
	"OPO": 1,
	"OCO": 2,
}

func (x CompoundOrder_Type) Enum() *CompoundOrder_Type {
	p := new(CompoundOrder_Type)
	*p = x
	return p
}
func (x CompoundOrder_Type) String() string {
	return proto.EnumName(CompoundOrder_Type_name, int32(x))
}
func (x *CompoundOrder_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CompoundOrder_Type_value, data, "CompoundOrder_Type")
	if err != nil {
		return err
	}
	*x = CompoundOrder_Type(value)
	return nil
}
func (CompoundOrder_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{89, 0} }

// Current order Status.
type OrderStatus_Status int32

const (
	// Original order is sent to execution system.
	OrderStatus_IN_TRANSIT OrderStatus_Status = 1
	// Order is rejected.
	OrderStatus_REJECTED OrderStatus_Status = 2
	// Order is acknowledged by execution and perhaps partially filled.
	OrderStatus_WORKING OrderStatus_Status = 3
	// Order is expired.
	OrderStatus_EXPIRED OrderStatus_Status = 4
	// Cancel request is sent to execution system.
	OrderStatus_IN_CANCEL OrderStatus_Status = 5
	// Modify request is sent to execution system.
	OrderStatus_IN_MODIFY OrderStatus_Status = 6
	// Order is canceled.
	OrderStatus_CANCELLED OrderStatus_Status = 7
	// Order is completely filled by execution system.
	OrderStatus_FILLED OrderStatus_Status = 8
	// Order is waiting submission to execution system.
	OrderStatus_SUSPENDED OrderStatus_Status = 9
	// Order may be canceled because a disconnect occurred.
	OrderStatus_DISCONNECTED OrderStatus_Status = 10
	// Order will be placed at a specified time (waiting execution system to start accepting orders).
	OrderStatus_ACTIVEAT OrderStatus_Status = 11
)

var OrderStatus_Status_name = map[int32]string{
	1:  "IN_TRANSIT",
	2:  "REJECTED",
	3:  "WORKING",
	4:  "EXPIRED",
	5:  "IN_CANCEL",
	6:  "IN_MODIFY",
	7:  "CANCELLED",
	8:  "FILLED",
	9:  "SUSPENDED",
	10: "DISCONNECTED",
	11: "ACTIVEAT",
}
var OrderStatus_Status_value = map[string]int32{
	"IN_TRANSIT":   1,
	"REJECTED":     2,
	"WORKING":      3,
	"EXPIRED":      4,
	"IN_CANCEL":    5,
	"IN_MODIFY":    6,
	"CANCELLED":    7,
	"FILLED":       8,
	"SUSPENDED":    9,
	"DISCONNECTED": 10,
	"ACTIVEAT":     11,
}

func (x OrderStatus_Status) Enum() *OrderStatus_Status {
	p := new(OrderStatus_Status)
	*p = x
	return p
}
func (x OrderStatus_Status) String() string {
	return proto.EnumName(OrderStatus_Status_name, int32(x))
}
func (x *OrderStatus_Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(OrderStatus_Status_value, data, "OrderStatus_Status")
	if err != nil {
		return err
	}
	*x = OrderStatus_Status(value)
	return nil
}
func (OrderStatus_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{92, 0} }

// Status of the transaction.
type TransactionStatus_Status int32

const (
	// Original order is sent to execution system.
	TransactionStatus_IN_TRANSIT TransactionStatus_Status = 1
	// Original order is rejected (exception).
	TransactionStatus_REJECTED TransactionStatus_Status = 2
	// Order is acknowledged by execution system.
	TransactionStatus_ACK_PLACE TransactionStatus_Status = 3
	// Order is expired (exception).
	TransactionStatus_EXPIRED TransactionStatus_Status = 4
	// Cancel request is sent to execution system.
	TransactionStatus_IN_CANCEL TransactionStatus_Status = 5
	// Cancel is acknowledged by execution system.
	TransactionStatus_ACK_CANCEL TransactionStatus_Status = 6
	// Cancel request is rejected (exception).
	TransactionStatus_REJECT_CANCEL TransactionStatus_Status = 7
	// Modify request is sent to execution system.
	TransactionStatus_IN_MODIFY TransactionStatus_Status = 8
	// Modify is acknowledged by execution system.
	TransactionStatus_ACK_MODIFY TransactionStatus_Status = 9
	// Modify request is rejected (exception).
	TransactionStatus_REJECT_MODIFY TransactionStatus_Status = 10
	// Fill event is received from execution system.
	TransactionStatus_FILL TransactionStatus_Status = 11
	// Order is suspended (parked).
	TransactionStatus_SUSPEND TransactionStatus_Status = 12
	// Referenced fill is corrected.
	TransactionStatus_FILL_CORRECT TransactionStatus_Status = 13
	// Referenced fill is canceled (exception).
	TransactionStatus_FILL_CANCEL TransactionStatus_Status = 14
	// Referenced fill is busted (exception).
	TransactionStatus_FILL_BUST TransactionStatus_Status = 15
	// Acknowledgment that order will activate at specified time.
	TransactionStatus_ACTIVEAT TransactionStatus_Status = 16
	// Order may be canceled because a disconnect occurred (exception).
	TransactionStatus_DISCONNECT TransactionStatus_Status = 17
	// Synthetic order was sent to the actual execution system.
	TransactionStatus_SYNTHETIC_ACTIVATED TransactionStatus_Status = 18
	// Order Status and/ or attributes are updated.
	TransactionStatus_UPDATE TransactionStatus_Status = 19
	// Synthetic strategy execution failed, expect 'text_message'
	// attribute with further details. The client may identify outright orders used
	// when attempting to execute the synthetic strategy by finding orders in its
	// book where OrderStatus.origin_order_id == OrderStatus.order_id.
	TransactionStatus_SYNTHETIC_FAILED TransactionStatus_Status = 20
	// Synthetic strategy order has at least one overfilled leg, 'synthetic_hang' attribute is populated.
	TransactionStatus_SYNTHETIC_OVERFILL TransactionStatus_Status = 21
	// Hanging quantity update for the synthetic strategy order.
	TransactionStatus_SYNTHETIC_HANG TransactionStatus_Status = 22
)

var TransactionStatus_Status_name = map[int32]string{
	1:  "IN_TRANSIT",
	2:  "REJECTED",
	3:  "ACK_PLACE",
	4:  "EXPIRED",
	5:  "IN_CANCEL",
	6:  "ACK_CANCEL",
	7:  "REJECT_CANCEL",
	8:  "IN_MODIFY",
	9:  "ACK_MODIFY",
	10: "REJECT_MODIFY",
	11: "FILL",
	12: "SUSPEND",
	13: "FILL_CORRECT",
	14: "FILL_CANCEL",
	15: "FILL_BUST",
	16: "ACTIVEAT",
	17: "DISCONNECT",
	18: "SYNTHETIC_ACTIVATED",
	19: "UPDATE",
	20: "SYNTHETIC_FAILED",
	21: "SYNTHETIC_OVERFILL",
	22: "SYNTHETIC_HANG",
}
var TransactionStatus_Status_value = map[string]int32{
	"IN_TRANSIT":          1,
	"REJECTED":            2,
	"ACK_PLACE":           3,
	"EXPIRED":             4,
	"IN_CANCEL":           5,
	"ACK_CANCEL":          6,
	"REJECT_CANCEL":       7,
	"IN_MODIFY":           8,
	"ACK_MODIFY":          9,
	"REJECT_MODIFY":       10,
	"FILL":                11,
	"SUSPEND":             12,
	"FILL_CORRECT":        13,
	"FILL_CANCEL":         14,
	"FILL_BUST":           15,
	"ACTIVEAT":            16,
	"DISCONNECT":          17,
	"SYNTHETIC_ACTIVATED": 18,
	"UPDATE":              19,
	"SYNTHETIC_FAILED":    20,
	"SYNTHETIC_OVERFILL":  21,
	"SYNTHETIC_HANG":      22,
}

func (x TransactionStatus_Status) Enum() *TransactionStatus_Status {
	p := new(TransactionStatus_Status)
	*p = x
	return p
}
func (x TransactionStatus_Status) String() string {
	return proto.EnumName(TransactionStatus_Status_name, int32(x))
}
func (x *TransactionStatus_Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TransactionStatus_Status_value, data, "TransactionStatus_Status")
	if err != nil {
		return err
	}
	*x = TransactionStatus_Status(value)
	return nil
}
func (TransactionStatus_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{93, 0} }

// Mode of working primary orders with price far from market.
type PrimaryOrdersLimit_FarFromMarketMode int32

const (
	// Primary orders will be canceled (won't be placed) if a new target price is far from market.
	PrimaryOrdersLimit_NO_ORDERS PrimaryOrdersLimit_FarFromMarketMode = 1
	// Primary orders will be moved away from market (will be left untouched) if a new target price is far from market.
	PrimaryOrdersLimit_MOVE_AWAY_ONLY PrimaryOrdersLimit_FarFromMarketMode = 2
	// Primary orders will be left untouched if current and a new target price are both far from market.
	PrimaryOrdersLimit_DONT_MOVE PrimaryOrdersLimit_FarFromMarketMode = 3
)

var PrimaryOrdersLimit_FarFromMarketMode_name = map[int32]string{
	1: "NO_ORDERS",
	2: "MOVE_AWAY_ONLY",
	3: "DONT_MOVE",
}
var PrimaryOrdersLimit_FarFromMarketMode_value = map[string]int32{
	"NO_ORDERS":      1,
	"MOVE_AWAY_ONLY": 2,
	"DONT_MOVE":      3,
}

func (x PrimaryOrdersLimit_FarFromMarketMode) Enum() *PrimaryOrdersLimit_FarFromMarketMode {
	p := new(PrimaryOrdersLimit_FarFromMarketMode)
	*p = x
	return p
}
func (x PrimaryOrdersLimit_FarFromMarketMode) String() string {
	return proto.EnumName(PrimaryOrdersLimit_FarFromMarketMode_name, int32(x))
}
func (x *PrimaryOrdersLimit_FarFromMarketMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PrimaryOrdersLimit_FarFromMarketMode_value, data, "PrimaryOrdersLimit_FarFromMarketMode")
	if err != nil {
		return err
	}
	*x = PrimaryOrdersLimit_FarFromMarketMode(value)
	return nil
}
func (PrimaryOrdersLimit_FarFromMarketMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{101, 0}
}

// Modes of handling DOM data.
type PrimaryOrdersLimit_DOMUsageMode int32

const (
	// Use only top levels of DOMs and produce a single level of primary orders.
	PrimaryOrdersLimit_TOP_ONLY PrimaryOrdersLimit_DOMUsageMode = 1
	// Use multiple levels of DOMs and produce multiple levels of primary orders.
	PrimaryOrdersLimit_MULTILEVELS PrimaryOrdersLimit_DOMUsageMode = 2
	// Produce a single level of primary orders of the full quantity corresponding to the worst DOM prices with a sufficient cumulative quantity.
	PrimaryOrdersLimit_FULL_SIZE_WORST_PRICE PrimaryOrdersLimit_DOMUsageMode = 3
	// Produce a single level of primary orders of the full quantity corresponding
	// to average DOM prices with a sufficient cumulative quantity.
	PrimaryOrdersLimit_FULL_SIZE_AVERAGE_PRICE PrimaryOrdersLimit_DOMUsageMode = 4
)

var PrimaryOrdersLimit_DOMUsageMode_name = map[int32]string{
	1: "TOP_ONLY",
	2: "MULTILEVELS",
	3: "FULL_SIZE_WORST_PRICE",
	4: "FULL_SIZE_AVERAGE_PRICE",
}
var PrimaryOrdersLimit_DOMUsageMode_value = map[string]int32{
	"TOP_ONLY":                1,
	"MULTILEVELS":             2,
	"FULL_SIZE_WORST_PRICE":   3,
	"FULL_SIZE_AVERAGE_PRICE": 4,
}

func (x PrimaryOrdersLimit_DOMUsageMode) Enum() *PrimaryOrdersLimit_DOMUsageMode {
	p := new(PrimaryOrdersLimit_DOMUsageMode)
	*p = x
	return p
}
func (x PrimaryOrdersLimit_DOMUsageMode) String() string {
	return proto.EnumName(PrimaryOrdersLimit_DOMUsageMode_name, int32(x))
}
func (x *PrimaryOrdersLimit_DOMUsageMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PrimaryOrdersLimit_DOMUsageMode_value, data, "PrimaryOrdersLimit_DOMUsageMode")
	if err != nil {
		return err
	}
	*x = PrimaryOrdersLimit_DOMUsageMode(value)
	return nil
}
func (PrimaryOrdersLimit_DOMUsageMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{101, 1}
}

// Duration for sniper leg orders
type PrimaryOrdersSniper_LegDuration int32

const (
	PrimaryOrdersSniper_DAY PrimaryOrdersSniper_LegDuration = 1
	// Fill and kill
	PrimaryOrdersSniper_FAK PrimaryOrdersSniper_LegDuration = 2
	// Fill or kill
	PrimaryOrdersSniper_FOK PrimaryOrdersSniper_LegDuration = 3
)

var PrimaryOrdersSniper_LegDuration_name = map[int32]string{
	1: "DAY",
	2: "FAK",
	3: "FOK",
}
var PrimaryOrdersSniper_LegDuration_value = map[string]int32{
	"DAY": 1,
	"FAK": 2,
	"FOK": 3,
}

func (x PrimaryOrdersSniper_LegDuration) Enum() *PrimaryOrdersSniper_LegDuration {
	p := new(PrimaryOrdersSniper_LegDuration)
	*p = x
	return p
}
func (x PrimaryOrdersSniper_LegDuration) String() string {
	return proto.EnumName(PrimaryOrdersSniper_LegDuration_name, int32(x))
}
func (x *PrimaryOrdersSniper_LegDuration) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PrimaryOrdersSniper_LegDuration_value, data, "PrimaryOrdersSniper_LegDuration")
	if err != nil {
		return err
	}
	*x = PrimaryOrdersSniper_LegDuration(value)
	return nil
}
func (PrimaryOrdersSniper_LegDuration) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{102, 0}
}

// Mode of overfill handling
type StrategyLimitOrderParameters_OverfillMode int32

const (
	// Overfills are allowed and managed by trader
	StrategyLimitOrderParameters_MANUAL StrategyLimitOrderParameters_OverfillMode = 1
	// Overfills are allowed and must be hedged by the server according to strategy quantity ratios
	StrategyLimitOrderParameters_AUTOMATIC_HEDGING StrategyLimitOrderParameters_OverfillMode = 2
	// Minimize probability of overfills
	StrategyLimitOrderParameters_AVOID_OVERFILLS StrategyLimitOrderParameters_OverfillMode = 3
)

var StrategyLimitOrderParameters_OverfillMode_name = map[int32]string{
	1: "MANUAL",
	2: "AUTOMATIC_HEDGING",
	3: "AVOID_OVERFILLS",
}
var StrategyLimitOrderParameters_OverfillMode_value = map[string]int32{
	"MANUAL":            1,
	"AUTOMATIC_HEDGING": 2,
	"AVOID_OVERFILLS":   3,
}

func (x StrategyLimitOrderParameters_OverfillMode) Enum() *StrategyLimitOrderParameters_OverfillMode {
	p := new(StrategyLimitOrderParameters_OverfillMode)
	*p = x
	return p
}
func (x StrategyLimitOrderParameters_OverfillMode) String() string {
	return proto.EnumName(StrategyLimitOrderParameters_OverfillMode_name, int32(x))
}
func (x *StrategyLimitOrderParameters_OverfillMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(StrategyLimitOrderParameters_OverfillMode_value, data, "StrategyLimitOrderParameters_OverfillMode")
	if err != nil {
		return err
	}
	*x = StrategyLimitOrderParameters_OverfillMode(value)
	return nil
}
func (StrategyLimitOrderParameters_OverfillMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{109, 0}
}

// Defines sizes of what leg orders must be aligned to strategy lots (opposite to work proportionally).
type StrategyLimitOrderParameters_AlignToStrategyLots int32

const (
	// Both primary and secondary leg orders could work its sizes proportionally (without aligning it to strategy lot)
	StrategyLimitOrderParameters_NONE StrategyLimitOrderParameters_AlignToStrategyLots = 1
	// Secondary leg orders must align its size to strategy lots
	StrategyLimitOrderParameters_SECONDARY_ONLY StrategyLimitOrderParameters_AlignToStrategyLots = 2
	// Both primary and secondary leg orders align its sizes to strategy lots
	StrategyLimitOrderParameters_ALL StrategyLimitOrderParameters_AlignToStrategyLots = 3
)

var StrategyLimitOrderParameters_AlignToStrategyLots_name = map[int32]string{
	1: "NONE",
	2: "SECONDARY_ONLY",
	3: "ALL",
}
var StrategyLimitOrderParameters_AlignToStrategyLots_value = map[string]int32{
	"NONE":           1,
	"SECONDARY_ONLY": 2,
	"ALL":            3,
}

func (x StrategyLimitOrderParameters_AlignToStrategyLots) Enum() *StrategyLimitOrderParameters_AlignToStrategyLots {
	p := new(StrategyLimitOrderParameters_AlignToStrategyLots)
	*p = x
	return p
}
func (x StrategyLimitOrderParameters_AlignToStrategyLots) String() string {
	return proto.EnumName(StrategyLimitOrderParameters_AlignToStrategyLots_name, int32(x))
}
func (x *StrategyLimitOrderParameters_AlignToStrategyLots) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(StrategyLimitOrderParameters_AlignToStrategyLots_value, data, "StrategyLimitOrderParameters_AlignToStrategyLots")
	if err != nil {
		return err
	}
	*x = StrategyLimitOrderParameters_AlignToStrategyLots(value)
	return nil
}
func (StrategyLimitOrderParameters_AlignToStrategyLots) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{109, 1}
}

// The way prices for secondary orders are calculated
type StrategyLimitOrderParameters_PricingMethod int32

const (
	// Respect each strategy lot price independently
	StrategyLimitOrderParameters_INDEPENDENT_LOT_PRICE StrategyLimitOrderParameters_PricingMethod = 1
	// Respect average strategy order price
	StrategyLimitOrderParameters_AVERAGE_ORDER_PRICE StrategyLimitOrderParameters_PricingMethod = 2
)

var StrategyLimitOrderParameters_PricingMethod_name = map[int32]string{
	1: "INDEPENDENT_LOT_PRICE",
	2: "AVERAGE_ORDER_PRICE",
}
var StrategyLimitOrderParameters_PricingMethod_value = map[string]int32{
	"INDEPENDENT_LOT_PRICE": 1,
	"AVERAGE_ORDER_PRICE":   2,
}

func (x StrategyLimitOrderParameters_PricingMethod) Enum() *StrategyLimitOrderParameters_PricingMethod {
	p := new(StrategyLimitOrderParameters_PricingMethod)
	*p = x
	return p
}
func (x StrategyLimitOrderParameters_PricingMethod) String() string {
	return proto.EnumName(StrategyLimitOrderParameters_PricingMethod_name, int32(x))
}
func (x *StrategyLimitOrderParameters_PricingMethod) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(StrategyLimitOrderParameters_PricingMethod_value, data, "StrategyLimitOrderParameters_PricingMethod")
	if err != nil {
		return err
	}
	*x = StrategyLimitOrderParameters_PricingMethod(value)
	return nil
}
func (StrategyLimitOrderParameters_PricingMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{109, 2}
}

// Enumeration of sides of strategy price that STP orders watch for.
type StrategyStopOrderParameters_StopSide int32

const (
	// Bid price of strategy must be matched against STP price.
	StrategyStopOrderParameters_BID StrategyStopOrderParameters_StopSide = 1
	// Ask price of strategy must be matched against STP price.
	StrategyStopOrderParameters_ASK StrategyStopOrderParameters_StopSide = 2
)

var StrategyStopOrderParameters_StopSide_name = map[int32]string{
	1: "BID",
	2: "ASK",
}
var StrategyStopOrderParameters_StopSide_value = map[string]int32{
	"BID": 1,
	"ASK": 2,
}

func (x StrategyStopOrderParameters_StopSide) Enum() *StrategyStopOrderParameters_StopSide {
	p := new(StrategyStopOrderParameters_StopSide)
	*p = x
	return p
}
func (x StrategyStopOrderParameters_StopSide) String() string {
	return proto.EnumName(StrategyStopOrderParameters_StopSide_name, int32(x))
}
func (x *StrategyStopOrderParameters_StopSide) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(StrategyStopOrderParameters_StopSide_value, data, "StrategyStopOrderParameters_StopSide")
	if err != nil {
		return err
	}
	*x = StrategyStopOrderParameters_StopSide(value)
	return nil
}
func (StrategyStopOrderParameters_StopSide) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{110, 0}
}

// Type of order placed for the leg.
type MarketTakingParameters_MarketTakingLimitOrderType int32

const (
	MarketTakingParameters_LMT MarketTakingParameters_MarketTakingLimitOrderType = 1
	MarketTakingParameters_MKT MarketTakingParameters_MarketTakingLimitOrderType = 2
)

var MarketTakingParameters_MarketTakingLimitOrderType_name = map[int32]string{
	1: "LMT",
	2: "MKT",
}
var MarketTakingParameters_MarketTakingLimitOrderType_value = map[string]int32{
	"LMT": 1,
	"MKT": 2,
}

func (x MarketTakingParameters_MarketTakingLimitOrderType) Enum() *MarketTakingParameters_MarketTakingLimitOrderType {
	p := new(MarketTakingParameters_MarketTakingLimitOrderType)
	*p = x
	return p
}
func (x MarketTakingParameters_MarketTakingLimitOrderType) String() string {
	return proto.EnumName(MarketTakingParameters_MarketTakingLimitOrderType_name, int32(x))
}
func (x *MarketTakingParameters_MarketTakingLimitOrderType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MarketTakingParameters_MarketTakingLimitOrderType_value, data, "MarketTakingParameters_MarketTakingLimitOrderType")
	if err != nil {
		return err
	}
	*x = MarketTakingParameters_MarketTakingLimitOrderType(value)
	return nil
}
func (MarketTakingParameters_MarketTakingLimitOrderType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{111, 0}
}

// Mode of overfill handling.
type StrategyAggregationParameters_AggrOverfillMode int32

const (
	// Minimize probability of overfills: don't place market taking LMT until existing market making LMT on other legs have quantity reduction acknowledge.
	StrategyAggregationParameters_AVOID_OVERFILLS StrategyAggregationParameters_AggrOverfillMode = 1
	// Place market taking LMTs and then attempt to reduce market making LMT quantity on other legs.
	// There is a window of time where leg orders may be working that total more than the strategy order quantity.
	StrategyAggregationParameters_ACCEPT_OVERFILL StrategyAggregationParameters_AggrOverfillMode = 2
	// Place market taking LMT and wait to reduce market making LMT qty on other legs until
	// the market taking LMT are filled (or cancelled after timeout).
	// There is a much larger window of time where leg orders
	// may be working that total more than the strategy order qty,
	// but market making LMT don't lose their place in queue.
	StrategyAggregationParameters_PRESERVE_QUEUE_POSITION StrategyAggregationParameters_AggrOverfillMode = 3
)

var StrategyAggregationParameters_AggrOverfillMode_name = map[int32]string{
	1: "AVOID_OVERFILLS",
	2: "ACCEPT_OVERFILL",
	3: "PRESERVE_QUEUE_POSITION",
}
var StrategyAggregationParameters_AggrOverfillMode_value = map[string]int32{
	"AVOID_OVERFILLS":         1,
	"ACCEPT_OVERFILL":         2,
	"PRESERVE_QUEUE_POSITION": 3,
}

func (x StrategyAggregationParameters_AggrOverfillMode) Enum() *StrategyAggregationParameters_AggrOverfillMode {
	p := new(StrategyAggregationParameters_AggrOverfillMode)
	*p = x
	return p
}
func (x StrategyAggregationParameters_AggrOverfillMode) String() string {
	return proto.EnumName(StrategyAggregationParameters_AggrOverfillMode_name, int32(x))
}
func (x *StrategyAggregationParameters_AggrOverfillMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(StrategyAggregationParameters_AggrOverfillMode_value, data, "StrategyAggregationParameters_AggrOverfillMode")
	if err != nil {
		return err
	}
	*x = StrategyAggregationParameters_AggrOverfillMode(value)
	return nil
}
func (StrategyAggregationParameters_AggrOverfillMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{114, 0}
}

// Level or subscription, each new level is a promotion of the previous one.
type MarketDataSubscription_Level int32

const (
	// Unsubscribe.
	MarketDataSubscription_NONE MarketDataSubscription_Level = 0
	// Get trade and settlement quotes.
	MarketDataSubscription_TRADES MarketDataSubscription_Level = 1
	// Get trades, settlement and best ask & bid without volumes.
	MarketDataSubscription_TRADES_BBA MarketDataSubscription_Level = 2
	// Get trades, settlement and best ask & bid with volumes.
	MarketDataSubscription_TRADES_BBA_VOLUMES MarketDataSubscription_Level = 3
	// All price data including DOM.
	MarketDataSubscription_TRADES_BBA_DOM MarketDataSubscription_Level = 4
)

var MarketDataSubscription_Level_name = map[int32]string{
	0: "NONE",
	1: "TRADES",
	2: "TRADES_BBA",
	3: "TRADES_BBA_VOLUMES",
	4: "TRADES_BBA_DOM",
}
var MarketDataSubscription_Level_value = map[string]int32{
	"NONE":               0,
	"TRADES":             1,
	"TRADES_BBA":         2,
	"TRADES_BBA_VOLUMES": 3,
	"TRADES_BBA_DOM":     4,
}

func (x MarketDataSubscription_Level) Enum() *MarketDataSubscription_Level {
	p := new(MarketDataSubscription_Level)
	*p = x
	return p
}
func (x MarketDataSubscription_Level) String() string {
	return proto.EnumName(MarketDataSubscription_Level_name, int32(x))
}
func (x *MarketDataSubscription_Level) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MarketDataSubscription_Level_value, data, "MarketDataSubscription_Level")
	if err != nil {
		return err
	}
	*x = MarketDataSubscription_Level(value)
	return nil
}
func (MarketDataSubscription_Level) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{124, 0}
}

type MarketDataSubscriptionStatus_StatusCode int32

const (
	// / success codes (0 - 99)
	MarketDataSubscriptionStatus_SUCCESS MarketDataSubscriptionStatus_StatusCode = 0
	// Currently subscription is disconnected because of communication issues
	// NOTE: Clients should not resubscribe in this case, the server will restore subscription with
	// sending SUCCESS Status once communication issues are resolved
	MarketDataSubscriptionStatus_DISCONNECTED MarketDataSubscriptionStatus_StatusCode = 1
	// / failure codes (100+)
	// general failure
	MarketDataSubscriptionStatus_FAILURE MarketDataSubscriptionStatus_StatusCode = 101
	// Subscription parameters are invalid.
	MarketDataSubscriptionStatus_INVALID_PARAMS MarketDataSubscriptionStatus_StatusCode = 102
	// The user is not allowed to be subscribed to this Instrument.
	MarketDataSubscriptionStatus_ACCESS_DENIED MarketDataSubscriptionStatus_StatusCode = 103
	// Market data source was deleted because of expiration or by another Reason.
	MarketDataSubscriptionStatus_DELETED MarketDataSubscriptionStatus_StatusCode = 104
	// The limit of the request number has been violated.
	MarketDataSubscriptionStatus_REQUEST_LIMIT_VIOLATION MarketDataSubscriptionStatus_StatusCode = 105
	// Account Cluster ID is required for this subscription but was not provided.
	MarketDataSubscriptionStatus_ACCOUNT_CLUSTER_REQUIRED MarketDataSubscriptionStatus_StatusCode = 106
)

var MarketDataSubscriptionStatus_StatusCode_name = map[int32]string{
	0:   "SUCCESS",
	1:   "DISCONNECTED",
	101: "FAILURE",
	102: "INVALID_PARAMS",
	103: "ACCESS_DENIED",
	104: "DELETED",
	105: "REQUEST_LIMIT_VIOLATION",
	106: "ACCOUNT_CLUSTER_REQUIRED",
}
var MarketDataSubscriptionStatus_StatusCode_value = map[string]int32{
	"SUCCESS":                  0,
	"DISCONNECTED":             1,
	"FAILURE":                  101,
	"INVALID_PARAMS":           102,
	"ACCESS_DENIED":            103,
	"DELETED":                  104,
	"REQUEST_LIMIT_VIOLATION":  105,
	"ACCOUNT_CLUSTER_REQUIRED": 106,
}

func (x MarketDataSubscriptionStatus_StatusCode) Enum() *MarketDataSubscriptionStatus_StatusCode {
	p := new(MarketDataSubscriptionStatus_StatusCode)
	*p = x
	return p
}
func (x MarketDataSubscriptionStatus_StatusCode) String() string {
	return proto.EnumName(MarketDataSubscriptionStatus_StatusCode_name, int32(x))
}
func (x *MarketDataSubscriptionStatus_StatusCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MarketDataSubscriptionStatus_StatusCode_value, data, "MarketDataSubscriptionStatus_StatusCode")
	if err != nil {
		return err
	}
	*x = MarketDataSubscriptionStatus_StatusCode(value)
	return nil
}
func (MarketDataSubscriptionStatus_StatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{125, 0}
}

// Type of the quote.
type Quote_Type int32

const (
	// Trade quote.
	Quote_TRADE Quote_Type = 0
	// Best bid quote.
	// Note that best bid/ask quotes are not guaranteed to be consistent with bid/ask quotes in the short
	// term. Thus, best bid/ask quotes must not be used to update DOM.
	Quote_BESTBID Quote_Type = 1
	// Best ask quote.
	// See the note for BESTBID
	Quote_BESTASK Quote_Type = 2
	// Bid quote (DOM level).
	Quote_BID Quote_Type = 3
	// Ask quote (DOM level).
	Quote_ASK Quote_Type = 4
	// Settlement quote.
	Quote_SETTLEMENT Quote_Type = 5
)

var Quote_Type_name = map[int32]string{
	0: "TRADE",
	1: "BESTBID",
	2: "BESTASK",
	3: "BID",
	4: "ASK",
	5: "SETTLEMENT",
}
var Quote_Type_value = map[string]int32{
	"TRADE":      0,
	"BESTBID":    1,
	"BESTASK":    2,
	"BID":        3,
	"ASK":        4,
	"SETTLEMENT": 5,
}

func (x Quote_Type) Enum() *Quote_Type {
	p := new(Quote_Type)
	*p = x
	return p
}
func (x Quote_Type) String() string {
	return proto.EnumName(Quote_Type_name, int32(x))
}
func (x *Quote_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Quote_Type_value, data, "Quote_Type")
	if err != nil {
		return err
	}
	*x = Quote_Type(value)
	return nil
}
func (Quote_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{127, 0} }

// Optional indicator(s) (e.g. this quote also updates some of Open/High/Low/Close session prices).
type Quote_Indicator int32

const (
	// Price of this quote is a new open price of the contract session.
	Quote_OPEN Quote_Indicator = 1
	// Price of this quote is a new high price of the contract session.
	Quote_HIGH Quote_Indicator = 2
	// Price of this quote is a new low price of the contract session.
	Quote_LOW Quote_Indicator = 3
	// Price of this quote is a new close price of the contract session.
	Quote_CLOSE Quote_Indicator = 4
)

var Quote_Indicator_name = map[int32]string{
	1: "OPEN",
	2: "HIGH",
	3: "LOW",
	4: "CLOSE",
}
var Quote_Indicator_value = map[string]int32{
	"OPEN":  1,
	"HIGH":  2,
	"LOW":   3,
	"CLOSE": 4,
}

func (x Quote_Indicator) Enum() *Quote_Indicator {
	p := new(Quote_Indicator)
	*p = x
	return p
}
func (x Quote_Indicator) String() string {
	return proto.EnumName(Quote_Indicator_name, int32(x))
}
func (x *Quote_Indicator) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Quote_Indicator_value, data, "Quote_Indicator")
	if err != nil {
		return err
	}
	*x = Quote_Indicator(value)
	return nil
}
func (Quote_Indicator) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{127, 1} }

// Result code.
type ReadUserAttributeResult_ResultCode int32

const (
	// success codes
	ReadUserAttributeResult_SUCCESS ReadUserAttributeResult_ResultCode = 0
	// failure codes (100+)
	ReadUserAttributeResult_FAILURE ReadUserAttributeResult_ResultCode = 101
	// The limit of the request number has been violated.
	ReadUserAttributeResult_REQUEST_LIMIT_VIOLATION ReadUserAttributeResult_ResultCode = 102
)

var ReadUserAttributeResult_ResultCode_name = map[int32]string{
	0:   "SUCCESS",
	101: "FAILURE",
	102: "REQUEST_LIMIT_VIOLATION",
}
var ReadUserAttributeResult_ResultCode_value = map[string]int32{
	"SUCCESS":                 0,
	"FAILURE":                 101,
	"REQUEST_LIMIT_VIOLATION": 102,
}

func (x ReadUserAttributeResult_ResultCode) Enum() *ReadUserAttributeResult_ResultCode {
	p := new(ReadUserAttributeResult_ResultCode)
	*p = x
	return p
}
func (x ReadUserAttributeResult_ResultCode) String() string {
	return proto.EnumName(ReadUserAttributeResult_ResultCode_name, int32(x))
}
func (x *ReadUserAttributeResult_ResultCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ReadUserAttributeResult_ResultCode_value, data, "ReadUserAttributeResult_ResultCode")
	if err != nil {
		return err
	}
	*x = ReadUserAttributeResult_ResultCode(value)
	return nil
}
func (ReadUserAttributeResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{130, 0}
}

// Result code.
type ModifyUserAttributeResult_ResultCode int32

const (
	// success codes
	ModifyUserAttributeResult_SUCCESS ModifyUserAttributeResult_ResultCode = 0
	// failure codes (100+)
	ModifyUserAttributeResult_FAILURE ModifyUserAttributeResult_ResultCode = 101
	// The limit of the request number has been violated.
	ModifyUserAttributeResult_REQUEST_LIMIT_VIOLATION ModifyUserAttributeResult_ResultCode = 102
)

var ModifyUserAttributeResult_ResultCode_name = map[int32]string{
	0:   "SUCCESS",
	101: "FAILURE",
	102: "REQUEST_LIMIT_VIOLATION",
}
var ModifyUserAttributeResult_ResultCode_value = map[string]int32{
	"SUCCESS":                 0,
	"FAILURE":                 101,
	"REQUEST_LIMIT_VIOLATION": 102,
}

func (x ModifyUserAttributeResult_ResultCode) Enum() *ModifyUserAttributeResult_ResultCode {
	p := new(ModifyUserAttributeResult_ResultCode)
	*p = x
	return p
}
func (x ModifyUserAttributeResult_ResultCode) String() string {
	return proto.EnumName(ModifyUserAttributeResult_ResultCode_name, int32(x))
}
func (x *ModifyUserAttributeResult_ResultCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ModifyUserAttributeResult_ResultCode_value, data, "ModifyUserAttributeResult_ResultCode")
	if err != nil {
		return err
	}
	*x = ModifyUserAttributeResult_ResultCode(value)
	return nil
}
func (ModifyUserAttributeResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{132, 0}
}

// Level or requested Time and Sales data.
type TimeAndSalesParameters_Level int32

const (
	// Get trades with volumes and settlement quotes.
	TimeAndSalesParameters_TRADES TimeAndSalesParameters_Level = 1
	// Get trades, settlement and best ask & bid quotes with volumes.
	TimeAndSalesParameters_TRADES_BBA_VOLUMES TimeAndSalesParameters_Level = 3
)

var TimeAndSalesParameters_Level_name = map[int32]string{
	1: "TRADES",
	3: "TRADES_BBA_VOLUMES",
}
var TimeAndSalesParameters_Level_value = map[string]int32{
	"TRADES":             1,
	"TRADES_BBA_VOLUMES": 3,
}

func (x TimeAndSalesParameters_Level) Enum() *TimeAndSalesParameters_Level {
	p := new(TimeAndSalesParameters_Level)
	*p = x
	return p
}
func (x TimeAndSalesParameters_Level) String() string {
	return proto.EnumName(TimeAndSalesParameters_Level_name, int32(x))
}
func (x *TimeAndSalesParameters_Level) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TimeAndSalesParameters_Level_value, data, "TimeAndSalesParameters_Level")
	if err != nil {
		return err
	}
	*x = TimeAndSalesParameters_Level(value)
	return nil
}
func (TimeAndSalesParameters_Level) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{133, 0}
}

// Type of request.
type TimeAndSalesRequest_RequestType int32

const (
	// Request.
	TimeAndSalesRequest_GET TimeAndSalesRequest_RequestType = 1
	// Drop request.
	TimeAndSalesRequest_DROP TimeAndSalesRequest_RequestType = 3
)

var TimeAndSalesRequest_RequestType_name = map[int32]string{
	1: "GET",
	3: "DROP",
}
var TimeAndSalesRequest_RequestType_value = map[string]int32{
	"GET":  1,
	"DROP": 3,
}

func (x TimeAndSalesRequest_RequestType) Enum() *TimeAndSalesRequest_RequestType {
	p := new(TimeAndSalesRequest_RequestType)
	*p = x
	return p
}
func (x TimeAndSalesRequest_RequestType) String() string {
	return proto.EnumName(TimeAndSalesRequest_RequestType_name, int32(x))
}
func (x *TimeAndSalesRequest_RequestType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TimeAndSalesRequest_RequestType_value, data, "TimeAndSalesRequest_RequestType")
	if err != nil {
		return err
	}
	*x = TimeAndSalesRequest_RequestType(value)
	return nil
}
func (TimeAndSalesRequest_RequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{134, 0}
}

// Result code.
type TimeAndSalesReport_ResultCode int32

const (
	// / success codes  (0 - 99)
	// Request is processed successfully.
	TimeAndSalesReport_SUCCESS TimeAndSalesReport_ResultCode = 0
	// Delayed request is dropped by a client.
	TimeAndSalesReport_DROPPED TimeAndSalesReport_ResultCode = 2
	// Request processing Status that indicates that currently processing is impossible because of communication issues.
	// NOTE: Clients should not resend requests in this case, the server will restore processing with
	// sending SUCCESS Status once communication issues are resolved.
	// If client is not interested in this request any longer it should send DROP request.
	TimeAndSalesReport_DISCONNECTED TimeAndSalesReport_ResultCode = 4
	// / failure codes (100+)
	// General failure.
	TimeAndSalesReport_FAILURE TimeAndSalesReport_ResultCode = 101
	// The user is not allowed to access this instrument data.
	TimeAndSalesReport_ACCESS_DENIED TimeAndSalesReport_ResultCode = 103
	// Requested information is not found.
	TimeAndSalesReport_NOT_FOUND TimeAndSalesReport_ResultCode = 104
	// Requested data is outside of allowed range.
	TimeAndSalesReport_OUTSIDE_ALLOWED_RANGE TimeAndSalesReport_ResultCode = 105
	// The limit of the request number has been violated.
	TimeAndSalesReport_REQUEST_LIMIT_VIOLATION TimeAndSalesReport_ResultCode = 106
)

var TimeAndSalesReport_ResultCode_name = map[int32]string{
	0:   "SUCCESS",
	2:   "DROPPED",
	4:   "DISCONNECTED",
	101: "FAILURE",
	103: "ACCESS_DENIED",
	104: "NOT_FOUND",
	105: "OUTSIDE_ALLOWED_RANGE",
	106: "REQUEST_LIMIT_VIOLATION",
}
var TimeAndSalesReport_ResultCode_value = map[string]int32{
	"SUCCESS":                 0,
	"DROPPED":                 2,
	"DISCONNECTED":            4,
	"FAILURE":                 101,
	"ACCESS_DENIED":           103,
	"NOT_FOUND":               104,
	"OUTSIDE_ALLOWED_RANGE":   105,
	"REQUEST_LIMIT_VIOLATION": 106,
}

func (x TimeAndSalesReport_ResultCode) Enum() *TimeAndSalesReport_ResultCode {
	p := new(TimeAndSalesReport_ResultCode)
	*p = x
	return p
}
func (x TimeAndSalesReport_ResultCode) String() string {
	return proto.EnumName(TimeAndSalesReport_ResultCode_name, int32(x))
}
func (x *TimeAndSalesReport_ResultCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TimeAndSalesReport_ResultCode_value, data, "TimeAndSalesReport_ResultCode")
	if err != nil {
		return err
	}
	*x = TimeAndSalesReport_ResultCode(value)
	return nil
}
func (TimeAndSalesReport_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{135, 0}
}

// Bar unit type.
type TimeBarParameters_BarUnit int32

const (
	// yearly bars
	TimeBarParameters_YEAR TimeBarParameters_BarUnit = 1
	// semi-annual bars
	TimeBarParameters_SEMI_ANNUAL TimeBarParameters_BarUnit = 2
	// quarterly bars
	TimeBarParameters_QUARTER TimeBarParameters_BarUnit = 3
	// monthly bars
	TimeBarParameters_MONTH TimeBarParameters_BarUnit = 4
	// weekly bars
	TimeBarParameters_WEEK TimeBarParameters_BarUnit = 5
	// daily bars
	TimeBarParameters_DAY TimeBarParameters_BarUnit = 6
	// hourly bars
	TimeBarParameters_HOUR TimeBarParameters_BarUnit = 7
	// minute bars
	TimeBarParameters_MIN TimeBarParameters_BarUnit = 8
)

var TimeBarParameters_BarUnit_name = map[int32]string{
	1: "YEAR",
	2: "SEMI_ANNUAL",
	3: "QUARTER",
	4: "MONTH",
	5: "WEEK",
	6: "DAY",
	7: "HOUR",
	8: "MIN",
}
var TimeBarParameters_BarUnit_value = map[string]int32{
	"YEAR":        1,
	"SEMI_ANNUAL": 2,
	"QUARTER":     3,
	"MONTH":       4,
	"WEEK":        5,
	"DAY":         6,
	"HOUR":        7,
	"MIN":         8,
}

func (x TimeBarParameters_BarUnit) Enum() *TimeBarParameters_BarUnit {
	p := new(TimeBarParameters_BarUnit)
	*p = x
	return p
}
func (x TimeBarParameters_BarUnit) String() string {
	return proto.EnumName(TimeBarParameters_BarUnit_name, int32(x))
}
func (x *TimeBarParameters_BarUnit) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TimeBarParameters_BarUnit_value, data, "TimeBarParameters_BarUnit")
	if err != nil {
		return err
	}
	*x = TimeBarParameters_BarUnit(value)
	return nil
}
func (TimeBarParameters_BarUnit) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{136, 0}
}

// Type of a bar request.
type TimeBarRequest_RequestType int32

const (
	// Request bars without subscription.
	TimeBarRequest_GET TimeBarRequest_RequestType = 1
	// Request bars with subscription for updates.
	// Note: to_utc_time parameter must not be specified to subscribe.
	TimeBarRequest_SUBSCRIBE TimeBarRequest_RequestType = 2
	// Drop request if server has not completed it yet and/or unsubscribe if already subscribed for updates.
	TimeBarRequest_DROP TimeBarRequest_RequestType = 3
)

var TimeBarRequest_RequestType_name = map[int32]string{
	1: "GET",
	2: "SUBSCRIBE",
	3: "DROP",
}
var TimeBarRequest_RequestType_value = map[string]int32{
	"GET":       1,
	"SUBSCRIBE": 2,
	"DROP":      3,
}

func (x TimeBarRequest_RequestType) Enum() *TimeBarRequest_RequestType {
	p := new(TimeBarRequest_RequestType)
	*p = x
	return p
}
func (x TimeBarRequest_RequestType) String() string {
	return proto.EnumName(TimeBarRequest_RequestType_name, int32(x))
}
func (x *TimeBarRequest_RequestType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TimeBarRequest_RequestType_value, data, "TimeBarRequest_RequestType")
	if err != nil {
		return err
	}
	*x = TimeBarRequest_RequestType(value)
	return nil
}
func (TimeBarRequest_RequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{137, 0}
}

// Status code.
type TimeBarReport_StatusCode int32

const (
	// / success codes  (0 - 99)
	// Request is processed without subscription (subscription was not requested).
	TimeBarReport_SUCCESS TimeBarReport_StatusCode = 0
	// Request is processed and subscription is established or restored after disconnection.
	// Data can be resent as a result of the restored subscription.
	TimeBarReport_SUBSCRIBED TimeBarReport_StatusCode = 1
	// Subscription or delayed request is dropped by a client.
	TimeBarReport_DROPPED TimeBarReport_StatusCode = 2
	// Unsolicited information update because of subscription.
	TimeBarReport_UPDATE TimeBarReport_StatusCode = 3
	// Subscription or request processing Status that indicates that currently processing is impossible because of communication issues.
	// NOTE: Clients should not resubscribe or resend requests in this case, the server will restore processing with
	// sending SUCCESS or SUBSCRIBED Status once communication issues are resolved.
	// If client is not interested in this request or subscription any longer it should send DROP request.
	TimeBarReport_DISCONNECTED TimeBarReport_StatusCode = 4
	// / failure codes (100+), subscription (if any) is dropped in case of failure.
	// General failure.
	TimeBarReport_FAILURE TimeBarReport_StatusCode = 101
	// The user is not allowed to access this data.
	TimeBarReport_ACCESS_DENIED TimeBarReport_StatusCode = 103
	// Requested information is not found.
	TimeBarReport_NOT_FOUND TimeBarReport_StatusCode = 104
	// Requested data is outside of allowed range.
	TimeBarReport_OUTSIDE_ALLOWED_RANGE TimeBarReport_StatusCode = 105
	// Parameters of a time bar request are invalid.
	TimeBarReport_INVALID_PARAMS TimeBarReport_StatusCode = 106
	// The limit of the request number has been violated.
	TimeBarReport_REQUEST_LIMIT_VIOLATION TimeBarReport_StatusCode = 107
)

var TimeBarReport_StatusCode_name = map[int32]string{
	0:   "SUCCESS",
	1:   "SUBSCRIBED",
	2:   "DROPPED",
	3:   "UPDATE",
	4:   "DISCONNECTED",
	101: "FAILURE",
	103: "ACCESS_DENIED",
	104: "NOT_FOUND",
	105: "OUTSIDE_ALLOWED_RANGE",
	106: "INVALID_PARAMS",
	107: "REQUEST_LIMIT_VIOLATION",
}
var TimeBarReport_StatusCode_value = map[string]int32{
	"SUCCESS":                 0,
	"SUBSCRIBED":              1,
	"DROPPED":                 2,
	"UPDATE":                  3,
	"DISCONNECTED":            4,
	"FAILURE":                 101,
	"ACCESS_DENIED":           103,
	"NOT_FOUND":               104,
	"OUTSIDE_ALLOWED_RANGE":   105,
	"INVALID_PARAMS":          106,
	"REQUEST_LIMIT_VIOLATION": 107,
}

func (x TimeBarReport_StatusCode) Enum() *TimeBarReport_StatusCode {
	p := new(TimeBarReport_StatusCode)
	*p = x
	return p
}
func (x TimeBarReport_StatusCode) String() string {
	return proto.EnumName(TimeBarReport_StatusCode_name, int32(x))
}
func (x *TimeBarReport_StatusCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TimeBarReport_StatusCode_value, data, "TimeBarReport_StatusCode")
	if err != nil {
		return err
	}
	*x = TimeBarReport_StatusCode(value)
	return nil
}
func (TimeBarReport_StatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{139, 0}
}

// Type of request action.
type VolumeProfileRequest_RequestType int32

const (
	VolumeProfileRequest_GET  VolumeProfileRequest_RequestType = 1
	VolumeProfileRequest_DROP VolumeProfileRequest_RequestType = 3
)

var VolumeProfileRequest_RequestType_name = map[int32]string{
	1: "GET",
	3: "DROP",
}
var VolumeProfileRequest_RequestType_value = map[string]int32{
	"GET":  1,
	"DROP": 3,
}

func (x VolumeProfileRequest_RequestType) Enum() *VolumeProfileRequest_RequestType {
	p := new(VolumeProfileRequest_RequestType)
	*p = x
	return p
}
func (x VolumeProfileRequest_RequestType) String() string {
	return proto.EnumName(VolumeProfileRequest_RequestType_name, int32(x))
}
func (x *VolumeProfileRequest_RequestType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VolumeProfileRequest_RequestType_value, data, "VolumeProfileRequest_RequestType")
	if err != nil {
		return err
	}
	*x = VolumeProfileRequest_RequestType(value)
	return nil
}
func (VolumeProfileRequest_RequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{140, 0}
}

type VolumeProfileReport_ResultCode int32

const (
	// / success codes  (0 - 99)
	// Request is processed successfully.
	VolumeProfileReport_SUCCESS VolumeProfileReport_ResultCode = 0
	// Delayed request is dropped by a client.
	VolumeProfileReport_DROPPED VolumeProfileReport_ResultCode = 2
	// Request processing Status that indicates that currently
	// processing is impossible because of communication issues.
	// NOTE: Clients should not resend requests in this case,
	// the server will restore processing with sending SUCCESS Status
	// once communication issues are resolved. If client is not interested
	// in this request any longer it should send DROP request.
	VolumeProfileReport_DISCONNECTED VolumeProfileReport_ResultCode = 4
	// / failure codes (100+)
	// General failure.
	VolumeProfileReport_FAILURE VolumeProfileReport_ResultCode = 101
	// The user is not allowed to access this instrument data.
	VolumeProfileReport_ACCESS_DENIED VolumeProfileReport_ResultCode = 103
	// Requested information is not found.
	VolumeProfileReport_NOT_FOUND VolumeProfileReport_ResultCode = 104
	// Requested data is outside of allowed range.
	VolumeProfileReport_OUTSIDE_ALLOWED_RANGE VolumeProfileReport_ResultCode = 105
	// The limit of the request number has been violated.
	VolumeProfileReport_REQUEST_LIMIT_VIOLATION VolumeProfileReport_ResultCode = 106
)

var VolumeProfileReport_ResultCode_name = map[int32]string{
	0:   "SUCCESS",
	2:   "DROPPED",
	4:   "DISCONNECTED",
	101: "FAILURE",
	103: "ACCESS_DENIED",
	104: "NOT_FOUND",
	105: "OUTSIDE_ALLOWED_RANGE",
	106: "REQUEST_LIMIT_VIOLATION",
}
var VolumeProfileReport_ResultCode_value = map[string]int32{
	"SUCCESS":                 0,
	"DROPPED":                 2,
	"DISCONNECTED":            4,
	"FAILURE":                 101,
	"ACCESS_DENIED":           103,
	"NOT_FOUND":               104,
	"OUTSIDE_ALLOWED_RANGE":   105,
	"REQUEST_LIMIT_VIOLATION": 106,
}

func (x VolumeProfileReport_ResultCode) Enum() *VolumeProfileReport_ResultCode {
	p := new(VolumeProfileReport_ResultCode)
	*p = x
	return p
}
func (x VolumeProfileReport_ResultCode) String() string {
	return proto.EnumName(VolumeProfileReport_ResultCode_name, int32(x))
}
func (x *VolumeProfileReport_ResultCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VolumeProfileReport_ResultCode_value, data, "VolumeProfileReport_ResultCode")
	if err != nil {
		return err
	}
	*x = VolumeProfileReport_ResultCode(value)
	return nil
}
func (VolumeProfileReport_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{142, 0}
}

// Client to Server message, must include at least one field.
// Logon, LogonRoutineClient, RestoreOrJoinSession or ObtainDemoCredentials are required to be the first and the only message after connection.
// Client messages rate is limited, 1000 messages per 10 seconds by default.
// If this rate is exceeded then a user message is sent with details and the connection is closed.
// NOTE: This and other limits mentioned in this protocol are not guaranteed, they are given for reference only
// and are subject to change without prior notice.
type ClientMsg struct {
	// Session level messages from client.
	Logon                       *Logon                       `protobuf:"bytes,100,opt,name=logon" json:"logon,omitempty"`
	RestoreOrJoinSession        *RestoreOrJoinSession        `protobuf:"bytes,101,opt,name=restore_or_join_session,json=restoreOrJoinSession" json:"restore_or_join_session,omitempty"`
	Logoff                      *Logoff                      `protobuf:"bytes,102,opt,name=logoff" json:"logoff,omitempty"`
	PasswordChange              *PasswordChange              `protobuf:"bytes,103,opt,name=password_change,json=passwordChange" json:"password_change,omitempty"`
	ObtainDemoCredentials       *ObtainDemoCredentials       `protobuf:"bytes,104,opt,name=obtain_demo_credentials,json=obtainDemoCredentials" json:"obtain_demo_credentials,omitempty"`
	UserSessionStateRequest     *UserSessionStateRequest     `protobuf:"bytes,105,opt,name=user_session_state_request,json=userSessionStateRequest" json:"user_session_state_request,omitempty"`
	Ping                        *Ping                        `protobuf:"bytes,107,opt,name=ping" json:"ping,omitempty"`
	Pong                        *Pong                        `protobuf:"bytes,108,opt,name=pong" json:"pong,omitempty"`
	LogonRoutineClient          *LogonRoutineClient          `protobuf:"bytes,109,opt,name=logon_routine_client,json=logonRoutineClient" json:"logon_routine_client,omitempty"`
	PasswordChangeRoutineClient *PasswordChangeRoutineClient `protobuf:"bytes,110,opt,name=password_change_routine_client,json=passwordChangeRoutineClient" json:"password_change_routine_client,omitempty"`
	// Requests for different information with optional subscription for updates.
	// There are the following limits for information requests:
	// 1) Information requests rate is limited, 1000 requests per 100 seconds by default.
	// 2) Number of simultaneous information subscriptions is limited, a separate limit per information request type is used.
	// 3) Number of overall information requests per session is limited, a separate limit per information request type is used.
	InformationRequest []*InformationRequest `protobuf:"bytes,1,rep,name=information_request,json=informationRequest" json:"information_request,omitempty"`
	// Trade routing subscriptions from client.
	// There are the following limits for trade routing subscriptions:
	// 1) Number of simultaneous subscriptions is limited, 200 by default.
	// 2) Total number of either explicitly or implicitly subscribed accounts is limited, 5000 by default.
	//    Any subscription that leads to exceeding this limit is failed.
	TradeSubscription []*TradeSubscription `protobuf:"bytes,2,rep,name=trade_subscription,json=tradeSubscription" json:"trade_subscription,omitempty"`
	// Order requests.
	// Requests rate is limited, 300 orders per 10 seconds per Username by default.
	OrderRequest []*OrderRequest `protobuf:"bytes,3,rep,name=order_request,json=orderRequest" json:"order_request,omitempty"`
	// Market data subscriptions from client.
	// Subscriptions number is limited, 200 simultaneous subscriptions by default.
	// Subscriptions on options strikes (puts and calls) of the same option maturity are considered as a single subscription within the limit.
	MarketDataSubscription []*MarketDataSubscription `protobuf:"bytes,4,rep,name=market_data_subscription,json=marketDataSubscription" json:"market_data_subscription,omitempty"`
	// Requests for manipulations with user attributes (linked to the user and client_app_id).
	// There are the following limits for user attributes:
	//  1) storage space is limited, 100 KB by default for a user/client_app_id pair;
	//  2) requests rate is limited, 10 requests per 100 seconds by default.
	ReadUserAttributeRequest   []*ReadUserAttributeRequest   `protobuf:"bytes,5,rep,name=read_user_attribute_request,json=readUserAttributeRequest" json:"read_user_attribute_request,omitempty"`
	ModifyUserAttributeRequest []*ModifyUserAttributeRequest `protobuf:"bytes,6,rep,name=modify_user_attribute_request,json=modifyUserAttributeRequest" json:"modify_user_attribute_request,omitempty"`
	// Historical data requests.
	// Number of simultaneous historical requests in processing is limited, 10 by default.
	TimeAndSalesRequest          []*TimeAndSalesRequest  `protobuf:"bytes,7,rep,name=time_and_sales_request,json=timeAndSalesRequest" json:"time_and_sales_request,omitempty"`
	TimeBarRequest               []*TimeBarRequest       `protobuf:"bytes,8,rep,name=time_bar_request,json=timeBarRequest" json:"time_bar_request,omitempty"`
	VolumeProfileRequest         []*VolumeProfileRequest `protobuf:"bytes,9,rep,name=volume_profile_request,json=volumeProfileRequest" json:"volume_profile_request,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
	XXX_unrecognized             []byte `json:"-"`
}

func (m *ClientMsg) Reset()                    { *m = ClientMsg{} }
func (m *ClientMsg) String() string            { return proto.CompactTextString(m) }
func (*ClientMsg) ProtoMessage()               {}
func (*ClientMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

var extRange_ClientMsg = []proto.ExtensionRange{
	{50, 99},
}

func (*ClientMsg) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_ClientMsg
}

func (m *ClientMsg) GetLogon() *Logon {
	if m != nil {
		return m.Logon
	}
	return nil
}

func (m *ClientMsg) GetRestoreOrJoinSession() *RestoreOrJoinSession {
	if m != nil {
		return m.RestoreOrJoinSession
	}
	return nil
}

func (m *ClientMsg) GetLogoff() *Logoff {
	if m != nil {
		return m.Logoff
	}
	return nil
}

func (m *ClientMsg) GetPasswordChange() *PasswordChange {
	if m != nil {
		return m.PasswordChange
	}
	return nil
}

func (m *ClientMsg) GetObtainDemoCredentials() *ObtainDemoCredentials {
	if m != nil {
		return m.ObtainDemoCredentials
	}
	return nil
}

func (m *ClientMsg) GetUserSessionStateRequest() *UserSessionStateRequest {
	if m != nil {
		return m.UserSessionStateRequest
	}
	return nil
}

func (m *ClientMsg) GetPing() *Ping {
	if m != nil {
		return m.Ping
	}
	return nil
}

func (m *ClientMsg) GetPong() *Pong {
	if m != nil {
		return m.Pong
	}
	return nil
}

func (m *ClientMsg) GetLogonRoutineClient() *LogonRoutineClient {
	if m != nil {
		return m.LogonRoutineClient
	}
	return nil
}

func (m *ClientMsg) GetPasswordChangeRoutineClient() *PasswordChangeRoutineClient {
	if m != nil {
		return m.PasswordChangeRoutineClient
	}
	return nil
}

func (m *ClientMsg) GetInformationRequest() []*InformationRequest {
	if m != nil {
		return m.InformationRequest
	}
	return nil
}

func (m *ClientMsg) GetTradeSubscription() []*TradeSubscription {
	if m != nil {
		return m.TradeSubscription
	}
	return nil
}

func (m *ClientMsg) GetOrderRequest() []*OrderRequest {
	if m != nil {
		return m.OrderRequest
	}
	return nil
}

func (m *ClientMsg) GetMarketDataSubscription() []*MarketDataSubscription {
	if m != nil {
		return m.MarketDataSubscription
	}
	return nil
}

func (m *ClientMsg) GetReadUserAttributeRequest() []*ReadUserAttributeRequest {
	if m != nil {
		return m.ReadUserAttributeRequest
	}
	return nil
}

func (m *ClientMsg) GetModifyUserAttributeRequest() []*ModifyUserAttributeRequest {
	if m != nil {
		return m.ModifyUserAttributeRequest
	}
	return nil
}

func (m *ClientMsg) GetTimeAndSalesRequest() []*TimeAndSalesRequest {
	if m != nil {
		return m.TimeAndSalesRequest
	}
	return nil
}

func (m *ClientMsg) GetTimeBarRequest() []*TimeBarRequest {
	if m != nil {
		return m.TimeBarRequest
	}
	return nil
}

func (m *ClientMsg) GetVolumeProfileRequest() []*VolumeProfileRequest {
	if m != nil {
		return m.VolumeProfileRequest
	}
	return nil
}

// Server to Client message, server can include different fields in a single message
type ServerMsg struct {
	// Session level messages from server.
	LogonResult                 *LogonResult                   `protobuf:"bytes,100,opt,name=logon_result,json=logonResult" json:"logon_result,omitempty"`
	RestoreOrJoinSessionResult  *RestoreOrJoinSessionResult    `protobuf:"bytes,101,opt,name=restore_or_join_session_result,json=restoreOrJoinSessionResult" json:"restore_or_join_session_result,omitempty"`
	ConcurrentConnectionJoin    []*ConcurrentConnectionJoin    `protobuf:"bytes,111,rep,name=concurrent_connection_join,json=concurrentConnectionJoin" json:"concurrent_connection_join,omitempty"`
	LoggedOff                   *LoggedOff                     `protobuf:"bytes,102,opt,name=logged_off,json=loggedOff" json:"logged_off,omitempty"`
	PasswordChangeResult        *PasswordChangeResult          `protobuf:"bytes,103,opt,name=password_change_result,json=passwordChangeResult" json:"password_change_result,omitempty"`
	UserMessage                 []*UserMessage                 `protobuf:"bytes,104,rep,name=user_message,json=userMessage" json:"user_message,omitempty"`
	ObtainDemoCredentialsResult []*ObtainDemoCredentialsResult `protobuf:"bytes,105,rep,name=obtain_demo_credentials_result,json=obtainDemoCredentialsResult" json:"obtain_demo_credentials_result,omitempty"`
	UserSessionStateResult      []*UserSessionStateResult      `protobuf:"bytes,106,rep,name=user_session_state_result,json=userSessionStateResult" json:"user_session_state_result,omitempty"`
	Ping                        *Ping                          `protobuf:"bytes,107,opt,name=ping" json:"ping,omitempty"`
	Pong                        *Pong                          `protobuf:"bytes,108,opt,name=pong" json:"pong,omitempty"`
	LogonRoutineServer          *LogonRoutineServer            `protobuf:"bytes,109,opt,name=logon_routine_server,json=logonRoutineServer" json:"logon_routine_server,omitempty"`
	PasswordChangeRoutineServer *PasswordChangeRoutineServer   `protobuf:"bytes,110,opt,name=password_change_routine_server,json=passwordChangeRoutineServer" json:"password_change_routine_server,omitempty"`
	// Reports with requested information.
	InformationReport []*InformationReport `protobuf:"bytes,1,rep,name=information_report,json=informationReport" json:"information_report,omitempty"`
	// Trade routing messages from server.
	OrderRequestReject      []*OrderRequestReject      `protobuf:"bytes,2,rep,name=order_request_reject,json=orderRequestReject" json:"order_request_reject,omitempty"`
	TradeSubscriptionStatus []*TradeSubscriptionStatus `protobuf:"bytes,3,rep,name=trade_subscription_status,json=tradeSubscriptionStatus" json:"trade_subscription_status,omitempty"`
	TradeSnapshotCompletion []*TradeSnapshotCompletion `protobuf:"bytes,4,rep,name=trade_snapshot_completion,json=tradeSnapshotCompletion" json:"trade_snapshot_completion,omitempty"`
	OrderStatus             []*OrderStatus             `protobuf:"bytes,5,rep,name=order_status,json=orderStatus" json:"order_status,omitempty"`
	PositionStatus          []*PositionStatus          `protobuf:"bytes,6,rep,name=position_status,json=positionStatus" json:"position_status,omitempty"`
	CollateralStatus        []*CollateralStatus        `protobuf:"bytes,7,rep,name=collateral_status,json=collateralStatus" json:"collateral_status,omitempty"`
	// Market data messages from server.
	MarketDataSubscriptionStatus []*MarketDataSubscriptionStatus `protobuf:"bytes,8,rep,name=market_data_subscription_status,json=marketDataSubscriptionStatus" json:"market_data_subscription_status,omitempty"`
	RealTimeMarketData           []*RealTimeMarketData           `protobuf:"bytes,9,rep,name=real_time_market_data,json=realTimeMarketData" json:"real_time_market_data,omitempty"`
	// / Results of user attributes operations.
	ReadUserAttributeResult   []*ReadUserAttributeResult   `protobuf:"bytes,10,rep,name=read_user_attribute_result,json=readUserAttributeResult" json:"read_user_attribute_result,omitempty"`
	ModifyUserAttributeResult []*ModifyUserAttributeResult `protobuf:"bytes,11,rep,name=modify_user_attribute_result,json=modifyUserAttributeResult" json:"modify_user_attribute_result,omitempty"`
	// / Historical data.
	TimeAndSalesReport           []*TimeAndSalesReport  `protobuf:"bytes,12,rep,name=time_and_sales_report,json=timeAndSalesReport" json:"time_and_sales_report,omitempty"`
	TimeBarReport                []*TimeBarReport       `protobuf:"bytes,13,rep,name=time_bar_report,json=timeBarReport" json:"time_bar_report,omitempty"`
	VolumeProfileReport          []*VolumeProfileReport `protobuf:"bytes,14,rep,name=volume_profile_report,json=volumeProfileReport" json:"volume_profile_report,omitempty"`
	proto.XXX_InternalExtensions `json:"-"`
	XXX_unrecognized             []byte `json:"-"`
}

func (m *ServerMsg) Reset()                    { *m = ServerMsg{} }
func (m *ServerMsg) String() string            { return proto.CompactTextString(m) }
func (*ServerMsg) ProtoMessage()               {}
func (*ServerMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

var extRange_ServerMsg = []proto.ExtensionRange{
	{50, 99},
}

func (*ServerMsg) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_ServerMsg
}

func (m *ServerMsg) GetLogonResult() *LogonResult {
	if m != nil {
		return m.LogonResult
	}
	return nil
}

func (m *ServerMsg) GetRestoreOrJoinSessionResult() *RestoreOrJoinSessionResult {
	if m != nil {
		return m.RestoreOrJoinSessionResult
	}
	return nil
}

func (m *ServerMsg) GetConcurrentConnectionJoin() []*ConcurrentConnectionJoin {
	if m != nil {
		return m.ConcurrentConnectionJoin
	}
	return nil
}

func (m *ServerMsg) GetLoggedOff() *LoggedOff {
	if m != nil {
		return m.LoggedOff
	}
	return nil
}

func (m *ServerMsg) GetPasswordChangeResult() *PasswordChangeResult {
	if m != nil {
		return m.PasswordChangeResult
	}
	return nil
}

func (m *ServerMsg) GetUserMessage() []*UserMessage {
	if m != nil {
		return m.UserMessage
	}
	return nil
}

func (m *ServerMsg) GetObtainDemoCredentialsResult() []*ObtainDemoCredentialsResult {
	if m != nil {
		return m.ObtainDemoCredentialsResult
	}
	return nil
}

func (m *ServerMsg) GetUserSessionStateResult() []*UserSessionStateResult {
	if m != nil {
		return m.UserSessionStateResult
	}
	return nil
}

func (m *ServerMsg) GetPing() *Ping {
	if m != nil {
		return m.Ping
	}
	return nil
}

func (m *ServerMsg) GetPong() *Pong {
	if m != nil {
		return m.Pong
	}
	return nil
}

func (m *ServerMsg) GetLogonRoutineServer() *LogonRoutineServer {
	if m != nil {
		return m.LogonRoutineServer
	}
	return nil
}

func (m *ServerMsg) GetPasswordChangeRoutineServer() *PasswordChangeRoutineServer {
	if m != nil {
		return m.PasswordChangeRoutineServer
	}
	return nil
}

func (m *ServerMsg) GetInformationReport() []*InformationReport {
	if m != nil {
		return m.InformationReport
	}
	return nil
}

func (m *ServerMsg) GetOrderRequestReject() []*OrderRequestReject {
	if m != nil {
		return m.OrderRequestReject
	}
	return nil
}

func (m *ServerMsg) GetTradeSubscriptionStatus() []*TradeSubscriptionStatus {
	if m != nil {
		return m.TradeSubscriptionStatus
	}
	return nil
}

func (m *ServerMsg) GetTradeSnapshotCompletion() []*TradeSnapshotCompletion {
	if m != nil {
		return m.TradeSnapshotCompletion
	}
	return nil
}

func (m *ServerMsg) GetOrderStatus() []*OrderStatus {
	if m != nil {
		return m.OrderStatus
	}
	return nil
}

func (m *ServerMsg) GetPositionStatus() []*PositionStatus {
	if m != nil {
		return m.PositionStatus
	}
	return nil
}

func (m *ServerMsg) GetCollateralStatus() []*CollateralStatus {
	if m != nil {
		return m.CollateralStatus
	}
	return nil
}

func (m *ServerMsg) GetMarketDataSubscriptionStatus() []*MarketDataSubscriptionStatus {
	if m != nil {
		return m.MarketDataSubscriptionStatus
	}
	return nil
}

func (m *ServerMsg) GetRealTimeMarketData() []*RealTimeMarketData {
	if m != nil {
		return m.RealTimeMarketData
	}
	return nil
}

func (m *ServerMsg) GetReadUserAttributeResult() []*ReadUserAttributeResult {
	if m != nil {
		return m.ReadUserAttributeResult
	}
	return nil
}

func (m *ServerMsg) GetModifyUserAttributeResult() []*ModifyUserAttributeResult {
	if m != nil {
		return m.ModifyUserAttributeResult
	}
	return nil
}

func (m *ServerMsg) GetTimeAndSalesReport() []*TimeAndSalesReport {
	if m != nil {
		return m.TimeAndSalesReport
	}
	return nil
}

func (m *ServerMsg) GetTimeBarReport() []*TimeBarReport {
	if m != nil {
		return m.TimeBarReport
	}
	return nil
}

func (m *ServerMsg) GetVolumeProfileReport() []*VolumeProfileReport {
	if m != nil {
		return m.VolumeProfileReport
	}
	return nil
}

// Placeholder message of real-time Collapsing level enumeration (some libraries do not support enumerations outside of messages)
// Collapsing is a mechanism of eliminating some intermediate quotes to present more up-to-date market data
// instead of falling behind.
// It is started dynamically by server if client is not able to consume all requested feed timely
// e.g. because of a narrow network channel or client side hardware/ software issues.
type RealTimeCollapsing struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *RealTimeCollapsing) Reset()                    { *m = RealTimeCollapsing{} }
func (m *RealTimeCollapsing) String() string            { return proto.CompactTextString(m) }
func (*RealTimeCollapsing) ProtoMessage()               {}
func (*RealTimeCollapsing) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Logon into the system and opening a new session.
type Logon struct {
	// User login name.
	UserName *string `protobuf:"bytes,1,req,name=user_name,json=userName" json:"user_name,omitempty"`
	// User's password.
	Password *string `protobuf:"bytes,2,req,name=password" json:"password,omitempty"`
	// User's one time password, might be required according to the user's settings.
	OneTimePassword *string `protobuf:"bytes,3,opt,name=one_time_password,json=oneTimePassword" json:"one_time_password,omitempty"`
	// Private label identifies the Firm or Vendor that connects to the server, client_app_id field value is taken by default.
	PrivateLabel *string `protobuf:"bytes,4,opt,name=private_label,json=privateLabel" json:"private_label,omitempty"`
	// Identifier of the client application as assigned by CQG.
	ClientAppId *string `protobuf:"bytes,5,req,name=client_app_id,json=clientAppId" json:"client_app_id,omitempty"`
	// Version of a client application.
	ClientVersion *string `protobuf:"bytes,6,req,name=client_version,json=clientVersion" json:"client_version,omitempty"`
	// Optional field that indicates if possible concurrent sessions for this user should be forcedly dropped.
	// If it is set to false then Logon may fail with CONCURRENT_SESSION code.
	// If it is omitted or set to true then concurrent sessions for this user will be dropped.
	DropConcurrentSession *bool `protobuf:"varint,7,opt,name=drop_concurrent_session,json=dropConcurrentSession" json:"drop_concurrent_session,omitempty"`
	// Maximum allowed real-time market data collapsing level.
	// DOM_BBA_TRADES is the default allowed collapsing level.
	// This field is associated with RealTimeCollapsing.Level enum type.
	// Only one of collapsing_level and bandwidth can be specified.
	CollapsingLevel *uint32 `protobuf:"varint,8,opt,name=collapsing_level,json=collapsingLevel" json:"collapsing_level,omitempty"`
	// Current protocol version that is used by the client application.
	// It is strongly recommended for client applications to put PROTOCOL_VERSION_MAJOR and PROTOCOL_VERSION_MINOR values from a used protocol file.
	// If version information is not provided then Server assumes client uses 0.x version of the protocol and may disable some new protocol features.
	ProtocolVersionMinor *uint32 `protobuf:"varint,9,opt,name=protocol_version_minor,json=protocolVersionMinor" json:"protocol_version_minor,omitempty"`
	ProtocolVersionMajor *uint32 `protobuf:"varint,10,opt,name=protocol_version_major,json=protocolVersionMajor" json:"protocol_version_major,omitempty"`
	// List of settings for a new session.
	// This field is associated with SessionSetting enum type.
	SessionSettings []uint32 `protobuf:"varint,11,rep,name=session_settings,json=sessionSettings" json:"session_settings,omitempty"`
	// Real-time market data bandwidth limit (in KB per second).
	// Only one of collapsing_level and bandwidth can be specified.
	Bandwidth *uint32 `protobuf:"varint,12,opt,name=bandwidth" json:"bandwidth,omitempty"`
	// Dialect ID for used symbols.
	// CQG dialect is used if omitted.
	// Id for CQG dialect is 0.
	// Please contact CQG to get the list of supported dialects.
	DialectId        *string `protobuf:"bytes,13,opt,name=dialect_id,json=dialectId" json:"dialect_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Logon) Reset()                    { *m = Logon{} }
func (m *Logon) String() string            { return proto.CompactTextString(m) }
func (*Logon) ProtoMessage()               {}
func (*Logon) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Logon) GetUserName() string {
	if m != nil && m.UserName != nil {
		return *m.UserName
	}
	return ""
}

func (m *Logon) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *Logon) GetOneTimePassword() string {
	if m != nil && m.OneTimePassword != nil {
		return *m.OneTimePassword
	}
	return ""
}

func (m *Logon) GetPrivateLabel() string {
	if m != nil && m.PrivateLabel != nil {
		return *m.PrivateLabel
	}
	return ""
}

func (m *Logon) GetClientAppId() string {
	if m != nil && m.ClientAppId != nil {
		return *m.ClientAppId
	}
	return ""
}

func (m *Logon) GetClientVersion() string {
	if m != nil && m.ClientVersion != nil {
		return *m.ClientVersion
	}
	return ""
}

func (m *Logon) GetDropConcurrentSession() bool {
	if m != nil && m.DropConcurrentSession != nil {
		return *m.DropConcurrentSession
	}
	return false
}

func (m *Logon) GetCollapsingLevel() uint32 {
	if m != nil && m.CollapsingLevel != nil {
		return *m.CollapsingLevel
	}
	return 0
}

func (m *Logon) GetProtocolVersionMinor() uint32 {
	if m != nil && m.ProtocolVersionMinor != nil {
		return *m.ProtocolVersionMinor
	}
	return 0
}

func (m *Logon) GetProtocolVersionMajor() uint32 {
	if m != nil && m.ProtocolVersionMajor != nil {
		return *m.ProtocolVersionMajor
	}
	return 0
}

func (m *Logon) GetSessionSettings() []uint32 {
	if m != nil {
		return m.SessionSettings
	}
	return nil
}

func (m *Logon) GetBandwidth() uint32 {
	if m != nil && m.Bandwidth != nil {
		return *m.Bandwidth
	}
	return 0
}

func (m *Logon) GetDialectId() string {
	if m != nil && m.DialectId != nil {
		return *m.DialectId
	}
	return ""
}

// Result of the logon operation (for Logon and LogonRoutineClient messages).
type LogonResult struct {
	// One of the logon result codes.
	// This field is associated with ResultCode enum type.
	ResultCode *uint32 `protobuf:"varint,1,req,name=result_code,json=resultCode" json:"result_code,omitempty"`
	// Base time as ISO 8601 string (e.g. '2013-04-03T14:23:20')
	// all other times are number of milliseconds from this base time.
	BaseTime *string `protobuf:"bytes,2,req,name=base_time,json=baseTime" json:"base_time,omitempty"`
	// Token of a new session if logon succeeded.
	SessionToken *string `protobuf:"bytes,3,opt,name=session_token,json=sessionToken" json:"session_token,omitempty"`
	// Optional logon result message for failure details.
	TextMessage *string `protobuf:"bytes,4,opt,name=text_message,json=textMessage" json:"text_message,omitempty"`
	// URL for a client to reconnect in case of redirection.
	RedirectUrl *string `protobuf:"bytes,5,opt,name=redirect_url,json=redirectUrl" json:"redirect_url,omitempty"`
	// Current protocol version of server. Normally client application need nothing to do with it.
	ProtocolVersionMinor *uint32 `protobuf:"varint,6,req,name=protocol_version_minor,json=protocolVersionMinor" json:"protocol_version_minor,omitempty"`
	ProtocolVersionMajor *uint32 `protobuf:"varint,7,req,name=protocol_version_major,json=protocolVersionMajor" json:"protocol_version_major,omitempty"`
	// Unique user identification
	UserId *int32 `protobuf:"zigzag32,8,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	// The time at which the message was sent
	ServerTime       *int64 `protobuf:"zigzag64,9,req,name=server_time,json=serverTime" json:"server_time,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *LogonResult) Reset()                    { *m = LogonResult{} }
func (m *LogonResult) String() string            { return proto.CompactTextString(m) }
func (*LogonResult) ProtoMessage()               {}
func (*LogonResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *LogonResult) GetResultCode() uint32 {
	if m != nil && m.ResultCode != nil {
		return *m.ResultCode
	}
	return 0
}

func (m *LogonResult) GetBaseTime() string {
	if m != nil && m.BaseTime != nil {
		return *m.BaseTime
	}
	return ""
}

func (m *LogonResult) GetSessionToken() string {
	if m != nil && m.SessionToken != nil {
		return *m.SessionToken
	}
	return ""
}

func (m *LogonResult) GetTextMessage() string {
	if m != nil && m.TextMessage != nil {
		return *m.TextMessage
	}
	return ""
}

func (m *LogonResult) GetRedirectUrl() string {
	if m != nil && m.RedirectUrl != nil {
		return *m.RedirectUrl
	}
	return ""
}

func (m *LogonResult) GetProtocolVersionMinor() uint32 {
	if m != nil && m.ProtocolVersionMinor != nil {
		return *m.ProtocolVersionMinor
	}
	return 0
}

func (m *LogonResult) GetProtocolVersionMajor() uint32 {
	if m != nil && m.ProtocolVersionMajor != nil {
		return *m.ProtocolVersionMajor
	}
	return 0
}

func (m *LogonResult) GetUserId() int32 {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return 0
}

func (m *LogonResult) GetServerTime() int64 {
	if m != nil && m.ServerTime != nil {
		return *m.ServerTime
	}
	return 0
}

// Message for multi-step logon which user should use in case if it is required to use encoded password.
// Multi-step logon sequence has the following steps:
//      1) Client initiates logon negotiation by sending LogonRoutineClient.logon_init message to the server.
//      2) Server sends one or more LogonRoutineServer.password_request messages (this step may repeat after step #3).
//      3) Client sends list of LogonRoutineClient.password_response back to the server.
//      4) Server optionally asks accept trader's agreement (LogonRoutineServer.trader_agreement_url).
//      5) Client responds with LogonRoutineClient.trader_agreement_accepted equal to True
//         if the user accepts agreement, False or LogonRoutineClient.abort_logon otherwise.
//      6) Server sends LogonRoutineServer.logon_result as the final message of the negotiation with the results.
//   Client may stop the negotiation by sending LogonRoutineClient.abort_logon message in response to any server
//      LogonRoutineServer.password_request or LogonRoutineServer.trader_agreement_url requests.
// NOTE: only one of fields has to be specified.
type LogonRoutineClient struct {
	// Initiating of multi-step logon process by client.
	LogonInit *LogonInit `protobuf:"bytes,1,opt,name=logon_init,json=logonInit" json:"logon_init,omitempty"`
	// List of passwords in response to request from server.
	// The number of passwords in response should be equal to the number of passwords in request from server.
	PasswordResponse []*PasswordResponse `protobuf:"bytes,2,rep,name=password_response,json=passwordResponse" json:"password_response,omitempty"`
	// True means user has accepted the trader agreement.
	TraderAgreementAccepted *bool `protobuf:"varint,3,opt,name=trader_agreement_accepted,json=traderAgreementAccepted" json:"trader_agreement_accepted,omitempty"`
	// Aborting of multi-step logon process by client.
	AbortLogon       *AbortRoutine `protobuf:"bytes,4,opt,name=abort_logon,json=abortLogon" json:"abort_logon,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *LogonRoutineClient) Reset()                    { *m = LogonRoutineClient{} }
func (m *LogonRoutineClient) String() string            { return proto.CompactTextString(m) }
func (*LogonRoutineClient) ProtoMessage()               {}
func (*LogonRoutineClient) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *LogonRoutineClient) GetLogonInit() *LogonInit {
	if m != nil {
		return m.LogonInit
	}
	return nil
}

func (m *LogonRoutineClient) GetPasswordResponse() []*PasswordResponse {
	if m != nil {
		return m.PasswordResponse
	}
	return nil
}

func (m *LogonRoutineClient) GetTraderAgreementAccepted() bool {
	if m != nil && m.TraderAgreementAccepted != nil {
		return *m.TraderAgreementAccepted
	}
	return false
}

func (m *LogonRoutineClient) GetAbortLogon() *AbortRoutine {
	if m != nil {
		return m.AbortLogon
	}
	return nil
}

// Response to the LogonRoutineClient message. Only one of fields is specified.
type LogonRoutineServer struct {
	// Final message of the negotiation with the results.
	LogonResult *LogonResult `protobuf:"bytes,1,opt,name=logon_result,json=logonResult" json:"logon_result,omitempty"`
	// List of requested passwords.
	PasswordRequest []*PasswordRequest `protobuf:"bytes,2,rep,name=password_request,json=passwordRequest" json:"password_request,omitempty"`
	// URL pointing to the location of help information for this version of agreement.
	// Specified if user should accept trader's agreement in order to continue logon process.
	TraderAgreementUrl *string `protobuf:"bytes,3,opt,name=trader_agreement_url,json=traderAgreementUrl" json:"trader_agreement_url,omitempty"`
	XXX_unrecognized   []byte  `json:"-"`
}

func (m *LogonRoutineServer) Reset()                    { *m = LogonRoutineServer{} }
func (m *LogonRoutineServer) String() string            { return proto.CompactTextString(m) }
func (*LogonRoutineServer) ProtoMessage()               {}
func (*LogonRoutineServer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *LogonRoutineServer) GetLogonResult() *LogonResult {
	if m != nil {
		return m.LogonResult
	}
	return nil
}

func (m *LogonRoutineServer) GetPasswordRequest() []*PasswordRequest {
	if m != nil {
		return m.PasswordRequest
	}
	return nil
}

func (m *LogonRoutineServer) GetTraderAgreementUrl() string {
	if m != nil && m.TraderAgreementUrl != nil {
		return *m.TraderAgreementUrl
	}
	return ""
}

// Message for multi-step password change which user should use in case if it is required to use encoded password.
// Multi-step password change sequence has the following steps:
//      1) Client initiates password change procedure by sending PasswordChangeRoutineClient.init_password_change to the server.
//      2) Server sends one or more PasswordChangeRoutineServer.password_request messages (this step may repeat after step #3).
//      3) Client sends list of PasswordChangeRoutineClient.password_response back to the server.
//      4) Server sends PasswordChangeRoutineServer.password_change_result as the final message of the negotiation with the results.
//   Client may stop the negotiation by sending PasswordChangeRoutineClient.abort_password_change message in response to any server
//      PasswordChangeRoutineServer.password_request message.
// NOTE: only one of fields has to be specified.
type PasswordChangeRoutineClient struct {
	// True means user has decided to initiate password changing procedure.
	InitPasswordChange *bool `protobuf:"varint,1,opt,name=init_password_change,json=initPasswordChange" json:"init_password_change,omitempty"`
	// List of passwords in response to request from server.
	// The number of passwords in response should be equal to the number of passwords in request from server.
	PasswordResponse []*PasswordResponse `protobuf:"bytes,2,rep,name=password_response,json=passwordResponse" json:"password_response,omitempty"`
	// Aborting of multi-step password change process by client.
	AbortPasswordChange *AbortRoutine `protobuf:"bytes,3,opt,name=abort_password_change,json=abortPasswordChange" json:"abort_password_change,omitempty"`
	XXX_unrecognized    []byte        `json:"-"`
}

func (m *PasswordChangeRoutineClient) Reset()                    { *m = PasswordChangeRoutineClient{} }
func (m *PasswordChangeRoutineClient) String() string            { return proto.CompactTextString(m) }
func (*PasswordChangeRoutineClient) ProtoMessage()               {}
func (*PasswordChangeRoutineClient) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *PasswordChangeRoutineClient) GetInitPasswordChange() bool {
	if m != nil && m.InitPasswordChange != nil {
		return *m.InitPasswordChange
	}
	return false
}

func (m *PasswordChangeRoutineClient) GetPasswordResponse() []*PasswordResponse {
	if m != nil {
		return m.PasswordResponse
	}
	return nil
}

func (m *PasswordChangeRoutineClient) GetAbortPasswordChange() *AbortRoutine {
	if m != nil {
		return m.AbortPasswordChange
	}
	return nil
}

// Response to the PasswordChangeRoutineClient message. Only one of fields is specified.
type PasswordChangeRoutineServer struct {
	// List of requested passwords.
	PasswordRequest []*PasswordRequest `protobuf:"bytes,1,rep,name=password_request,json=passwordRequest" json:"password_request,omitempty"`
	// Final message of the negotiation with the results.
	PasswordChangeResult *PasswordChangeResult `protobuf:"bytes,2,opt,name=password_change_result,json=passwordChangeResult" json:"password_change_result,omitempty"`
	XXX_unrecognized     []byte                `json:"-"`
}

func (m *PasswordChangeRoutineServer) Reset()                    { *m = PasswordChangeRoutineServer{} }
func (m *PasswordChangeRoutineServer) String() string            { return proto.CompactTextString(m) }
func (*PasswordChangeRoutineServer) ProtoMessage()               {}
func (*PasswordChangeRoutineServer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *PasswordChangeRoutineServer) GetPasswordRequest() []*PasswordRequest {
	if m != nil {
		return m.PasswordRequest
	}
	return nil
}

func (m *PasswordChangeRoutineServer) GetPasswordChangeResult() *PasswordChangeResult {
	if m != nil {
		return m.PasswordChangeResult
	}
	return nil
}

// This message indicates that user has decided to abort the logon or password change processes.
type AbortRoutine struct {
	// Reason of logon or password change routine abort.
	Comment          *string `protobuf:"bytes,1,opt,name=comment" json:"comment,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *AbortRoutine) Reset()                    { *m = AbortRoutine{} }
func (m *AbortRoutine) String() string            { return proto.CompactTextString(m) }
func (*AbortRoutine) ProtoMessage()               {}
func (*AbortRoutine) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *AbortRoutine) GetComment() string {
	if m != nil && m.Comment != nil {
		return *m.Comment
	}
	return ""
}

// Initiating of multi-step logon process by client. See description of fields in Logon message.
type LogonInit struct {
	UserName              *string  `protobuf:"bytes,1,req,name=user_name,json=userName" json:"user_name,omitempty"`
	PrivateLabel          *string  `protobuf:"bytes,2,opt,name=private_label,json=privateLabel" json:"private_label,omitempty"`
	ClientAppId           *string  `protobuf:"bytes,3,req,name=client_app_id,json=clientAppId" json:"client_app_id,omitempty"`
	ClientVersion         *string  `protobuf:"bytes,4,req,name=client_version,json=clientVersion" json:"client_version,omitempty"`
	DropConcurrentSession *bool    `protobuf:"varint,5,opt,name=drop_concurrent_session,json=dropConcurrentSession" json:"drop_concurrent_session,omitempty"`
	CollapsingLevel       *uint32  `protobuf:"varint,6,opt,name=collapsing_level,json=collapsingLevel" json:"collapsing_level,omitempty"`
	ProtocolVersionMinor  *uint32  `protobuf:"varint,7,opt,name=protocol_version_minor,json=protocolVersionMinor" json:"protocol_version_minor,omitempty"`
	ProtocolVersionMajor  *uint32  `protobuf:"varint,8,opt,name=protocol_version_major,json=protocolVersionMajor" json:"protocol_version_major,omitempty"`
	SessionSettings       []uint32 `protobuf:"varint,9,rep,name=session_settings,json=sessionSettings" json:"session_settings,omitempty"`
	Bandwidth             *uint32  `protobuf:"varint,10,opt,name=bandwidth" json:"bandwidth,omitempty"`
	DialectId             *string  `protobuf:"bytes,11,opt,name=dialect_id,json=dialectId" json:"dialect_id,omitempty"`
	XXX_unrecognized      []byte   `json:"-"`
}

func (m *LogonInit) Reset()                    { *m = LogonInit{} }
func (m *LogonInit) String() string            { return proto.CompactTextString(m) }
func (*LogonInit) ProtoMessage()               {}
func (*LogonInit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *LogonInit) GetUserName() string {
	if m != nil && m.UserName != nil {
		return *m.UserName
	}
	return ""
}

func (m *LogonInit) GetPrivateLabel() string {
	if m != nil && m.PrivateLabel != nil {
		return *m.PrivateLabel
	}
	return ""
}

func (m *LogonInit) GetClientAppId() string {
	if m != nil && m.ClientAppId != nil {
		return *m.ClientAppId
	}
	return ""
}

func (m *LogonInit) GetClientVersion() string {
	if m != nil && m.ClientVersion != nil {
		return *m.ClientVersion
	}
	return ""
}

func (m *LogonInit) GetDropConcurrentSession() bool {
	if m != nil && m.DropConcurrentSession != nil {
		return *m.DropConcurrentSession
	}
	return false
}

func (m *LogonInit) GetCollapsingLevel() uint32 {
	if m != nil && m.CollapsingLevel != nil {
		return *m.CollapsingLevel
	}
	return 0
}

func (m *LogonInit) GetProtocolVersionMinor() uint32 {
	if m != nil && m.ProtocolVersionMinor != nil {
		return *m.ProtocolVersionMinor
	}
	return 0
}

func (m *LogonInit) GetProtocolVersionMajor() uint32 {
	if m != nil && m.ProtocolVersionMajor != nil {
		return *m.ProtocolVersionMajor
	}
	return 0
}

func (m *LogonInit) GetSessionSettings() []uint32 {
	if m != nil {
		return m.SessionSettings
	}
	return nil
}

func (m *LogonInit) GetBandwidth() uint32 {
	if m != nil && m.Bandwidth != nil {
		return *m.Bandwidth
	}
	return 0
}

func (m *LogonInit) GetDialectId() string {
	if m != nil && m.DialectId != nil {
		return *m.DialectId
	}
	return ""
}

// Parameters of requesting password from user.
type PasswordRequest struct {
	// ID of a request.
	RequestId *uint32 `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	// Type of password which server requests from the user.
	// This field is associated with PasswordType enum type.
	PasswordType *uint32 `protobuf:"varint,2,req,name=password_type,json=passwordType" json:"password_type,omitempty"`
	// Commonly understood code that can be used to show an additional localized prompt for certain password types.
	UserPromptType *string `protobuf:"bytes,3,opt,name=user_prompt_type,json=userPromptType" json:"user_prompt_type,omitempty"`
	// Alternate English text for clients which do not recognize user_prompt_type. This text can be displayed as-is to the user.
	// NOTE: user_prompt_type and user_prompt_type_alt are a pair (so either none or both are provided).
	UserPromptTypeAlt *string `protobuf:"bytes,4,opt,name=user_prompt_type_alt,json=userPromptTypeAlt" json:"user_prompt_type_alt,omitempty"`
	// Text that should be displayed to the user as-is along with the localized prompt implied by user_prompt_type.
	// If user_prompt_type_alt is used instead, this text should be displayed after it.
	// user_prompt will only be provided if user_prompt_type and user_prompt_type_alt are provided, but it is optional even then.
	UserPrompt *string `protobuf:"bytes,5,opt,name=user_prompt,json=userPrompt" json:"user_prompt,omitempty"`
	// Set of supported encodings for this request. Client should choose the encoding with highest priority from among those it implements.
	Encoding         []*Encoding `protobuf:"bytes,6,rep,name=encoding" json:"encoding,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *PasswordRequest) Reset()                    { *m = PasswordRequest{} }
func (m *PasswordRequest) String() string            { return proto.CompactTextString(m) }
func (*PasswordRequest) ProtoMessage()               {}
func (*PasswordRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *PasswordRequest) GetRequestId() uint32 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *PasswordRequest) GetPasswordType() uint32 {
	if m != nil && m.PasswordType != nil {
		return *m.PasswordType
	}
	return 0
}

func (m *PasswordRequest) GetUserPromptType() string {
	if m != nil && m.UserPromptType != nil {
		return *m.UserPromptType
	}
	return ""
}

func (m *PasswordRequest) GetUserPromptTypeAlt() string {
	if m != nil && m.UserPromptTypeAlt != nil {
		return *m.UserPromptTypeAlt
	}
	return ""
}

func (m *PasswordRequest) GetUserPrompt() string {
	if m != nil && m.UserPrompt != nil {
		return *m.UserPrompt
	}
	return ""
}

func (m *PasswordRequest) GetEncoding() []*Encoding {
	if m != nil {
		return m.Encoding
	}
	return nil
}

// Response to the PasswordRequest message.
type PasswordResponse struct {
	// ID of corresponding password request.
	RequestId *uint32 `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	// Commonly understood string that identifies the password encoding method.
	EncodingType *string `protobuf:"bytes,2,req,name=encoding_type,json=encodingType" json:"encoding_type,omitempty"`
	// User's password encoded with specified encoding method.
	Password         *string `protobuf:"bytes,3,req,name=password" json:"password,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PasswordResponse) Reset()                    { *m = PasswordResponse{} }
func (m *PasswordResponse) String() string            { return proto.CompactTextString(m) }
func (*PasswordResponse) ProtoMessage()               {}
func (*PasswordResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *PasswordResponse) GetRequestId() uint32 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *PasswordResponse) GetEncodingType() string {
	if m != nil && m.EncodingType != nil {
		return *m.EncodingType
	}
	return ""
}

func (m *PasswordResponse) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

// Description of the encoding method.
type Encoding struct {
	// Commonly understood string that identifies the encoding method.
	// The following encodings are available: "none", "ds3_rsa", "isprint_e2ee".
	EncodingType *string `protobuf:"bytes,1,req,name=encoding_type,json=encodingType" json:"encoding_type,omitempty"`
	// The priority for this encoding, value 1 is highest priority, 2 is next priority, etc.
	PriorityRank *uint32 `protobuf:"varint,2,req,name=priority_rank,json=priorityRank" json:"priority_rank,omitempty"`
	// Encoding parameters for this encoding method.
	EncodingParameter []*EncodingParameter `protobuf:"bytes,3,rep,name=encoding_parameter,json=encodingParameter" json:"encoding_parameter,omitempty"`
	XXX_unrecognized  []byte               `json:"-"`
}

func (m *Encoding) Reset()                    { *m = Encoding{} }
func (m *Encoding) String() string            { return proto.CompactTextString(m) }
func (*Encoding) ProtoMessage()               {}
func (*Encoding) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Encoding) GetEncodingType() string {
	if m != nil && m.EncodingType != nil {
		return *m.EncodingType
	}
	return ""
}

func (m *Encoding) GetPriorityRank() uint32 {
	if m != nil && m.PriorityRank != nil {
		return *m.PriorityRank
	}
	return 0
}

func (m *Encoding) GetEncodingParameter() []*EncodingParameter {
	if m != nil {
		return m.EncodingParameter
	}
	return nil
}

// The encoding parameter.
type EncodingParameter struct {
	// Encoding parameter's name.
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// Encoding parameter's value.
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EncodingParameter) Reset()                    { *m = EncodingParameter{} }
func (m *EncodingParameter) String() string            { return proto.CompactTextString(m) }
func (*EncodingParameter) ProtoMessage()               {}
func (*EncodingParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *EncodingParameter) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *EncodingParameter) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// Client request to restore session because of accidental disconnect or to join additional concurrent connection to existing session.
// This message allows to avoid prompting user for [one-time] password.
// In case of session restore client application has to [re-]subscribe and [re-]request necessary data.
// Permissions to use this functionality is regulated by ALLOW_SESSION_RESTORE/ALLOW_SESSION_JOIN session settings which are specified in Logon or LogonInit message.
type RestoreOrJoinSession struct {
	// Token of the session to restore/join, it has limited lifetime after disconnect of the last connection.
	SessionToken *string `protobuf:"bytes,1,req,name=session_token,json=sessionToken" json:"session_token,omitempty"`
	// Private label identifies the Firm or Vendor that connects to the server, client_app_id field value is taken by default.
	PrivateLabel *string `protobuf:"bytes,2,opt,name=private_label,json=privateLabel" json:"private_label,omitempty"`
	// Identifier of the client application as assigned by CQG.
	// This field is required to be specified and left optional only for backward compatibility.
	ClientAppId *string `protobuf:"bytes,3,opt,name=client_app_id,json=clientAppId" json:"client_app_id,omitempty"`
	// Maximum allowed real-time market data collapsing level.
	// DOM_BBA_TRADES is the default allowed collapsing level.
	// This field is associated with RealTimeCollapsing.Level enum type.
	// Only one of collapsing_level and bandwidth can be specified.
	CollapsingLevel *uint32 `protobuf:"varint,4,opt,name=collapsing_level,json=collapsingLevel" json:"collapsing_level,omitempty"`
	// Current protocol version that is used by the client application.
	// It is strongly recommended for client applications to put PROTOCOL_VERSION_MAJOR and PROTOCOL_VERSION_MINOR values from a used protocol file.
	// If version information is not provided then Server assumes client uses 0.x version of the protocol and may disable some new protocol features.
	ProtocolVersionMinor *uint32 `protobuf:"varint,5,opt,name=protocol_version_minor,json=protocolVersionMinor" json:"protocol_version_minor,omitempty"`
	ProtocolVersionMajor *uint32 `protobuf:"varint,6,opt,name=protocol_version_major,json=protocolVersionMajor" json:"protocol_version_major,omitempty"`
	// Real-time market data bandwidth limit (in KB per second).
	// Only one of collapsing_level and bandwidth can be specified.
	Bandwidth        *uint32 `protobuf:"varint,7,opt,name=bandwidth" json:"bandwidth,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RestoreOrJoinSession) Reset()                    { *m = RestoreOrJoinSession{} }
func (m *RestoreOrJoinSession) String() string            { return proto.CompactTextString(m) }
func (*RestoreOrJoinSession) ProtoMessage()               {}
func (*RestoreOrJoinSession) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *RestoreOrJoinSession) GetSessionToken() string {
	if m != nil && m.SessionToken != nil {
		return *m.SessionToken
	}
	return ""
}

func (m *RestoreOrJoinSession) GetPrivateLabel() string {
	if m != nil && m.PrivateLabel != nil {
		return *m.PrivateLabel
	}
	return ""
}

func (m *RestoreOrJoinSession) GetClientAppId() string {
	if m != nil && m.ClientAppId != nil {
		return *m.ClientAppId
	}
	return ""
}

func (m *RestoreOrJoinSession) GetCollapsingLevel() uint32 {
	if m != nil && m.CollapsingLevel != nil {
		return *m.CollapsingLevel
	}
	return 0
}

func (m *RestoreOrJoinSession) GetProtocolVersionMinor() uint32 {
	if m != nil && m.ProtocolVersionMinor != nil {
		return *m.ProtocolVersionMinor
	}
	return 0
}

func (m *RestoreOrJoinSession) GetProtocolVersionMajor() uint32 {
	if m != nil && m.ProtocolVersionMajor != nil {
		return *m.ProtocolVersionMajor
	}
	return 0
}

func (m *RestoreOrJoinSession) GetBandwidth() uint32 {
	if m != nil && m.Bandwidth != nil {
		return *m.Bandwidth
	}
	return 0
}

// Result of session restore or join attempt.
type RestoreOrJoinSessionResult struct {
	// Session restore/join result.
	// This field is associated with ResultCode enum type.
	ResultCode *uint32 `protobuf:"varint,1,req,name=result_code,json=resultCode" json:"result_code,omitempty"`
	// Session base time (see LogonResult.base_time).
	BaseTime *string `protobuf:"bytes,2,req,name=base_time,json=baseTime" json:"base_time,omitempty"`
	// Optional failure details.
	TextMessage *string `protobuf:"bytes,3,opt,name=text_message,json=textMessage" json:"text_message,omitempty"`
	// The time at which the message was sent
	ServerTime *int64 `protobuf:"zigzag64,4,req,name=server_time,json=serverTime" json:"server_time,omitempty"`
	// Session default dialect ID for used symbols (see Logon.dialect_id).
	DialectId        *string `protobuf:"bytes,5,opt,name=dialect_id,json=dialectId" json:"dialect_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RestoreOrJoinSessionResult) Reset()                    { *m = RestoreOrJoinSessionResult{} }
func (m *RestoreOrJoinSessionResult) String() string            { return proto.CompactTextString(m) }
func (*RestoreOrJoinSessionResult) ProtoMessage()               {}
func (*RestoreOrJoinSessionResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *RestoreOrJoinSessionResult) GetResultCode() uint32 {
	if m != nil && m.ResultCode != nil {
		return *m.ResultCode
	}
	return 0
}

func (m *RestoreOrJoinSessionResult) GetBaseTime() string {
	if m != nil && m.BaseTime != nil {
		return *m.BaseTime
	}
	return ""
}

func (m *RestoreOrJoinSessionResult) GetTextMessage() string {
	if m != nil && m.TextMessage != nil {
		return *m.TextMessage
	}
	return ""
}

func (m *RestoreOrJoinSessionResult) GetServerTime() int64 {
	if m != nil && m.ServerTime != nil {
		return *m.ServerTime
	}
	return 0
}

func (m *RestoreOrJoinSessionResult) GetDialectId() string {
	if m != nil && m.DialectId != nil {
		return *m.DialectId
	}
	return ""
}

// Notifies about joining of a concurrent connection to the session (see RestoreOrJoinSession).
type ConcurrentConnectionJoin struct {
	// Shows if new connection has been initiated by an application of the same type (with the same private_label and client_app_id fields).
	IsSameAppType    *bool  `protobuf:"varint,1,req,name=is_same_app_type,json=isSameAppType" json:"is_same_app_type,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ConcurrentConnectionJoin) Reset()                    { *m = ConcurrentConnectionJoin{} }
func (m *ConcurrentConnectionJoin) String() string            { return proto.CompactTextString(m) }
func (*ConcurrentConnectionJoin) ProtoMessage()               {}
func (*ConcurrentConnectionJoin) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ConcurrentConnectionJoin) GetIsSameAppType() bool {
	if m != nil && m.IsSameAppType != nil {
		return *m.IsSameAppType
	}
	return false
}

// Client request to logoff from the system and close the session.
type Logoff struct {
	// Optional logoff Reason.
	TextMessage      *string `protobuf:"bytes,1,opt,name=text_message,json=textMessage" json:"text_message,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Logoff) Reset()                    { *m = Logoff{} }
func (m *Logoff) String() string            { return proto.CompactTextString(m) }
func (*Logoff) ProtoMessage()               {}
func (*Logoff) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *Logoff) GetTextMessage() string {
	if m != nil && m.TextMessage != nil {
		return *m.TextMessage
	}
	return ""
}

// Server notification about closing user's session,
// server closes connection after this message.
type LoggedOff struct {
	// One of the logoff reasons.
	// This field is associated with LogoffReason enum type.
	LogoffReason *uint32 `protobuf:"varint,1,req,name=logoff_reason,json=logoffReason" json:"logoff_reason,omitempty"`
	// Optional logoff details.
	TextMessage *string `protobuf:"bytes,2,opt,name=text_message,json=textMessage" json:"text_message,omitempty"`
	// URL for redirection.
	RedirectUrl      *string `protobuf:"bytes,3,opt,name=redirect_url,json=redirectUrl" json:"redirect_url,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *LoggedOff) Reset()                    { *m = LoggedOff{} }
func (m *LoggedOff) String() string            { return proto.CompactTextString(m) }
func (*LoggedOff) ProtoMessage()               {}
func (*LoggedOff) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *LoggedOff) GetLogoffReason() uint32 {
	if m != nil && m.LogoffReason != nil {
		return *m.LogoffReason
	}
	return 0
}

func (m *LoggedOff) GetTextMessage() string {
	if m != nil && m.TextMessage != nil {
		return *m.TextMessage
	}
	return ""
}

func (m *LoggedOff) GetRedirectUrl() string {
	if m != nil && m.RedirectUrl != nil {
		return *m.RedirectUrl
	}
	return ""
}

// Message to change user's password.
type PasswordChange struct {
	// Currently used password.
	OldPassword *string `protobuf:"bytes,1,req,name=old_password,json=oldPassword" json:"old_password,omitempty"`
	// New password that user wants to use.
	NewPassword      *string `protobuf:"bytes,2,req,name=new_password,json=newPassword" json:"new_password,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PasswordChange) Reset()                    { *m = PasswordChange{} }
func (m *PasswordChange) String() string            { return proto.CompactTextString(m) }
func (*PasswordChange) ProtoMessage()               {}
func (*PasswordChange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *PasswordChange) GetOldPassword() string {
	if m != nil && m.OldPassword != nil {
		return *m.OldPassword
	}
	return ""
}

func (m *PasswordChange) GetNewPassword() string {
	if m != nil && m.NewPassword != nil {
		return *m.NewPassword
	}
	return ""
}

// Result of user password change (for PasswordChange and PasswordChangeRoutineClient messages).
type PasswordChangeResult struct {
	// This field is associated with ResultCode enum type.
	ResultCode *uint32 `protobuf:"varint,1,req,name=result_code,json=resultCode" json:"result_code,omitempty"`
	// Optional failure details.
	TextMessage      *string `protobuf:"bytes,2,opt,name=text_message,json=textMessage" json:"text_message,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PasswordChangeResult) Reset()                    { *m = PasswordChangeResult{} }
func (m *PasswordChangeResult) String() string            { return proto.CompactTextString(m) }
func (*PasswordChangeResult) ProtoMessage()               {}
func (*PasswordChangeResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *PasswordChangeResult) GetResultCode() uint32 {
	if m != nil && m.ResultCode != nil {
		return *m.ResultCode
	}
	return 0
}

func (m *PasswordChangeResult) GetTextMessage() string {
	if m != nil && m.TextMessage != nil {
		return *m.TextMessage
	}
	return ""
}

// request for temporary user name and password for demo
// Clients of ObtainDemoCredentials are responcible to verify provided e-mail (e.g. by sending passwords by e-mail only) and prevent possible abuse.
// ObtainDemoCredentials requests are accepted only if client ip address is in the list of allowed IP addresses for service requests
type ObtainDemoCredentials struct {
	// Identifier of the client application as assigned by CQG.
	ClientAppId *string `protobuf:"bytes,1,req,name=client_app_id,json=clientAppId" json:"client_app_id,omitempty"`
	// User first name
	FirstName *string `protobuf:"bytes,2,req,name=first_name,json=firstName" json:"first_name,omitempty"`
	// User second name
	SecondName *string `protobuf:"bytes,3,req,name=second_name,json=secondName" json:"second_name,omitempty"`
	// E-mail address of a user who requested demo access.
	EMail *string `protobuf:"bytes,4,req,name=e_mail,json=eMail" json:"e_mail,omitempty"`
	// Private label identifies the Firm or Vendor that connects to the server, client_app_id field value is taken by default.
	PrivateLabel     *string `protobuf:"bytes,5,opt,name=private_label,json=privateLabel" json:"private_label,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ObtainDemoCredentials) Reset()                    { *m = ObtainDemoCredentials{} }
func (m *ObtainDemoCredentials) String() string            { return proto.CompactTextString(m) }
func (*ObtainDemoCredentials) ProtoMessage()               {}
func (*ObtainDemoCredentials) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *ObtainDemoCredentials) GetClientAppId() string {
	if m != nil && m.ClientAppId != nil {
		return *m.ClientAppId
	}
	return ""
}

func (m *ObtainDemoCredentials) GetFirstName() string {
	if m != nil && m.FirstName != nil {
		return *m.FirstName
	}
	return ""
}

func (m *ObtainDemoCredentials) GetSecondName() string {
	if m != nil && m.SecondName != nil {
		return *m.SecondName
	}
	return ""
}

func (m *ObtainDemoCredentials) GetEMail() string {
	if m != nil && m.EMail != nil {
		return *m.EMail
	}
	return ""
}

func (m *ObtainDemoCredentials) GetPrivateLabel() string {
	if m != nil && m.PrivateLabel != nil {
		return *m.PrivateLabel
	}
	return ""
}

type ObtainDemoCredentialsResult struct {
	// This field is associated with ResultCode enum type.
	ResultCode *uint32 `protobuf:"varint,1,req,name=result_code,json=resultCode" json:"result_code,omitempty"`
	// demo user name
	UserName *string `protobuf:"bytes,2,opt,name=user_name,json=userName" json:"user_name,omitempty"`
	// demo password
	Password *string `protobuf:"bytes,3,opt,name=password" json:"password,omitempty"`
	// Optional details.
	TextMessage *string `protobuf:"bytes,4,opt,name=text_message,json=textMessage" json:"text_message,omitempty"`
	// Unique user identification.
	// Required in case of success.
	UserId *int32 `protobuf:"zigzag32,5,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	// Expiration date/time in UTC as ISO 8601 string (e.g. '2013-04-03T14:23:20Z').
	ExpirationUtc    *string `protobuf:"bytes,6,opt,name=expiration_utc,json=expirationUtc" json:"expiration_utc,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ObtainDemoCredentialsResult) Reset()                    { *m = ObtainDemoCredentialsResult{} }
func (m *ObtainDemoCredentialsResult) String() string            { return proto.CompactTextString(m) }
func (*ObtainDemoCredentialsResult) ProtoMessage()               {}
func (*ObtainDemoCredentialsResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *ObtainDemoCredentialsResult) GetResultCode() uint32 {
	if m != nil && m.ResultCode != nil {
		return *m.ResultCode
	}
	return 0
}

func (m *ObtainDemoCredentialsResult) GetUserName() string {
	if m != nil && m.UserName != nil {
		return *m.UserName
	}
	return ""
}

func (m *ObtainDemoCredentialsResult) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *ObtainDemoCredentialsResult) GetTextMessage() string {
	if m != nil && m.TextMessage != nil {
		return *m.TextMessage
	}
	return ""
}

func (m *ObtainDemoCredentialsResult) GetUserId() int32 {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return 0
}

func (m *ObtainDemoCredentialsResult) GetExpirationUtc() string {
	if m != nil && m.ExpirationUtc != nil {
		return *m.ExpirationUtc
	}
	return ""
}

// Text message from server.
type UserMessage struct {
	// This field is associated with MessageType enum type.
	MessageType *uint32 `protobuf:"varint,1,req,name=message_type,json=messageType" json:"message_type,omitempty"`
	// Information about source of the message.
	Source *string `protobuf:"bytes,2,req,name=source" json:"source,omitempty"`
	// Message subject.
	Subject *string `protobuf:"bytes,3,opt,name=subject" json:"subject,omitempty"`
	// Message text.
	Text *string `protobuf:"bytes,4,req,name=text" json:"text,omitempty"`
	// Optional time when this message is expired, it should be hidden from user after this time (UTC).
	ExpirationUtcTime *int64 `protobuf:"zigzag64,5,opt,name=expiration_utc_time,json=expirationUtcTime" json:"expiration_utc_time,omitempty"`
	XXX_unrecognized  []byte `json:"-"`
}

func (m *UserMessage) Reset()                    { *m = UserMessage{} }
func (m *UserMessage) String() string            { return proto.CompactTextString(m) }
func (*UserMessage) ProtoMessage()               {}
func (*UserMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *UserMessage) GetMessageType() uint32 {
	if m != nil && m.MessageType != nil {
		return *m.MessageType
	}
	return 0
}

func (m *UserMessage) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

func (m *UserMessage) GetSubject() string {
	if m != nil && m.Subject != nil {
		return *m.Subject
	}
	return ""
}

func (m *UserMessage) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

func (m *UserMessage) GetExpirationUtcTime() int64 {
	if m != nil && m.ExpirationUtcTime != nil {
		return *m.ExpirationUtcTime
	}
	return 0
}

// Request information about user session.
// UserSessionState requests are accepted only if client ip address is in the list of allowed IP addresses for service requests
type UserSessionStateRequest struct {
	SessionToken     *string `protobuf:"bytes,1,req,name=session_token,json=sessionToken" json:"session_token,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *UserSessionStateRequest) Reset()                    { *m = UserSessionStateRequest{} }
func (m *UserSessionStateRequest) String() string            { return proto.CompactTextString(m) }
func (*UserSessionStateRequest) ProtoMessage()               {}
func (*UserSessionStateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *UserSessionStateRequest) GetSessionToken() string {
	if m != nil && m.SessionToken != nil {
		return *m.SessionToken
	}
	return ""
}

type UserSessionStateResult struct {
	// Session token from UserSessionStateRequest.
	SessionToken *string `protobuf:"bytes,1,req,name=session_token,json=sessionToken" json:"session_token,omitempty"`
	// This field is associated with ResultCode enum type.
	ResultCode *uint32 `protobuf:"varint,2,req,name=result_code,json=resultCode" json:"result_code,omitempty"`
	// / User session information.
	UserId           *int32  `protobuf:"zigzag32,3,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	Username         *string `protobuf:"bytes,4,opt,name=Username" json:"Username,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *UserSessionStateResult) Reset()                    { *m = UserSessionStateResult{} }
func (m *UserSessionStateResult) String() string            { return proto.CompactTextString(m) }
func (*UserSessionStateResult) ProtoMessage()               {}
func (*UserSessionStateResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *UserSessionStateResult) GetSessionToken() string {
	if m != nil && m.SessionToken != nil {
		return *m.SessionToken
	}
	return ""
}

func (m *UserSessionStateResult) GetResultCode() uint32 {
	if m != nil && m.ResultCode != nil {
		return *m.ResultCode
	}
	return 0
}

func (m *UserSessionStateResult) GetUserId() int32 {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return 0
}

func (m *UserSessionStateResult) GetUsername() string {
	if m != nil && m.Username != nil {
		return *m.Username
	}
	return ""
}

// Ping request which can be initiated by any side to ensure connection is alive. Both client and
// server sides must respond such request with Pong.
type Ping struct {
	// Token routed back in Pong response.
	Token *string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	// UTC time when this request was composed. Used for network latency diagnostics.
	PingUtcTime      *int64 `protobuf:"zigzag64,2,req,name=ping_utc_time,json=pingUtcTime" json:"ping_utc_time,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Ping) Reset()                    { *m = Ping{} }
func (m *Ping) String() string            { return proto.CompactTextString(m) }
func (*Ping) ProtoMessage()               {}
func (*Ping) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *Ping) GetToken() string {
	if m != nil && m.Token != nil {
		return *m.Token
	}
	return ""
}

func (m *Ping) GetPingUtcTime() int64 {
	if m != nil && m.PingUtcTime != nil {
		return *m.PingUtcTime
	}
	return 0
}

// Pong response which must be sent in response on Ping request.
type Pong struct {
	// Token passed in Ping request.
	Token *string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	// Corresponding value from Ping request.
	PingUtcTime *int64 `protobuf:"zigzag64,2,req,name=ping_utc_time,json=pingUtcTime" json:"ping_utc_time,omitempty"`
	// UTC time when this response was composed.
	PongUtcTime      *int64 `protobuf:"zigzag64,3,req,name=pong_utc_time,json=pongUtcTime" json:"pong_utc_time,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Pong) Reset()                    { *m = Pong{} }
func (m *Pong) String() string            { return proto.CompactTextString(m) }
func (*Pong) ProtoMessage()               {}
func (*Pong) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *Pong) GetToken() string {
	if m != nil && m.Token != nil {
		return *m.Token
	}
	return ""
}

func (m *Pong) GetPingUtcTime() int64 {
	if m != nil && m.PingUtcTime != nil {
		return *m.PingUtcTime
	}
	return 0
}

func (m *Pong) GetPongUtcTime() int64 {
	if m != nil && m.PongUtcTime != nil {
		return *m.PongUtcTime
	}
	return 0
}

// Message to define a synthetic or a user defined strategy, a tree where terminal nodes (legs) are concrete contracts,
// non-terminal ones are nested strategies.
// Nodes are defined from the BUY perspective.
// Maximum strategy nesting level is 2, i.e. strategy of strategies of legs.
// Maximum number of leg in the whole strategy is 40.
type StrategyDefinition struct {
	// The strategy is of the aggregation type.
	Aggregation *bool `protobuf:"varint,1,opt,name=aggregation" json:"aggregation,omitempty"`
	// If specified defines exchange strategy.
	ExchangeStrategy *ExchangeStrategy `protobuf:"bytes,2,opt,name=exchange_strategy,json=exchangeStrategy" json:"exchange_strategy,omitempty"`
	// Strategy tick size (correct price format). The tick size of the 1st leg is default.
	TickSize *float64 `protobuf:"fixed64,3,opt,name=tick_size,json=tickSize" json:"tick_size,omitempty"`
	// Additive offset for computation of strategy price.
	// 0 is default.
	PriceOffset *float64 `protobuf:"fixed64,4,opt,name=price_offset,json=priceOffset" json:"price_offset,omitempty"`
	// Controls how to handle fractional quantities when calculating leg quantities for an order on this strategy,
	// One of RoundLegMode enums, DOWN is default. Ignored for aggregations and exchange strategies.
	RoundLegMode *uint32 `protobuf:"varint,5,opt,name=round_leg_mode,json=roundLegMode" json:"round_leg_mode,omitempty"`
	// Unique node index within the root strategy to apply strategy trading parameters and to associate an order.
	NodeIndex *uint32 `protobuf:"varint,6,req,name=node_index,json=nodeIndex" json:"node_index,omitempty"`
	// Legs or nested strategies.
	NodeDefinition []*StrategyNodeDefinition `protobuf:"bytes,7,rep,name=node_definition,json=nodeDefinition" json:"node_definition,omitempty"`
	// User text associated with the strategy. Allowed to be specified only for non-exchange strategies.
	UserDescription  *string `protobuf:"bytes,8,opt,name=user_description,json=userDescription" json:"user_description,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *StrategyDefinition) Reset()                    { *m = StrategyDefinition{} }
func (m *StrategyDefinition) String() string            { return proto.CompactTextString(m) }
func (*StrategyDefinition) ProtoMessage()               {}
func (*StrategyDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *StrategyDefinition) GetAggregation() bool {
	if m != nil && m.Aggregation != nil {
		return *m.Aggregation
	}
	return false
}

func (m *StrategyDefinition) GetExchangeStrategy() *ExchangeStrategy {
	if m != nil {
		return m.ExchangeStrategy
	}
	return nil
}

func (m *StrategyDefinition) GetTickSize() float64 {
	if m != nil && m.TickSize != nil {
		return *m.TickSize
	}
	return 0
}

func (m *StrategyDefinition) GetPriceOffset() float64 {
	if m != nil && m.PriceOffset != nil {
		return *m.PriceOffset
	}
	return 0
}

func (m *StrategyDefinition) GetRoundLegMode() uint32 {
	if m != nil && m.RoundLegMode != nil {
		return *m.RoundLegMode
	}
	return 0
}

func (m *StrategyDefinition) GetNodeIndex() uint32 {
	if m != nil && m.NodeIndex != nil {
		return *m.NodeIndex
	}
	return 0
}

func (m *StrategyDefinition) GetNodeDefinition() []*StrategyNodeDefinition {
	if m != nil {
		return m.NodeDefinition
	}
	return nil
}

func (m *StrategyDefinition) GetUserDescription() string {
	if m != nil && m.UserDescription != nil {
		return *m.UserDescription
	}
	return ""
}

// Defines a strategy created by an individual and registered by an exchange for general open market trading.
// Must be a root strategy without nested nodes and cannot be an aggregation.
type ExchangeStrategy struct {
	// Value of this field might be chosen from the predefined list to specify exchange strategy type.
	// Please contact CQG to get the list of supported types.
	// "custom" if omitted.
	ExchangeStrategyType *string `protobuf:"bytes,1,opt,name=exchange_strategy_type,json=exchangeStrategyType" json:"exchange_strategy_type,omitempty"`
	XXX_unrecognized     []byte  `json:"-"`
}

func (m *ExchangeStrategy) Reset()                    { *m = ExchangeStrategy{} }
func (m *ExchangeStrategy) String() string            { return proto.CompactTextString(m) }
func (*ExchangeStrategy) ProtoMessage()               {}
func (*ExchangeStrategy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *ExchangeStrategy) GetExchangeStrategyType() string {
	if m != nil && m.ExchangeStrategyType != nil {
		return *m.ExchangeStrategyType
	}
	return ""
}

// Defines a leg (resolved contract) of a strategy.
type LegDefinition struct {
	// Id of the leg contract.
	ContractId *uint32 `protobuf:"varint,1,req,name=contract_id,json=contractId" json:"contract_id,omitempty"`
	// Unique node index within the root strategy to apply strategy trading parameters and to associate an order.
	NodeIndex *uint32 `protobuf:"varint,2,req,name=node_index,json=nodeIndex" json:"node_index,omitempty"`
	// Leg quantity ratio, signed decimal, number of leg contracts to buy(positive) or sell(negative). Must be integer for an aggregation.
	QtyRatio *float64 `protobuf:"fixed64,3,req,name=qty_ratio,json=qtyRatio" json:"qty_ratio,omitempty"`
	// Leg price calculation ratio, signed decimal, coefficient in strategy price formula before the leg contract.
	// Same as qty_ratio if omitted.
	PriceRatio *float64 `protobuf:"fixed64,4,opt,name=price_ratio,json=priceRatio" json:"price_ratio,omitempty"`
	// Price offset for this leg (correct price format), only specified for legs of an aggregation or a multiplicative strategy.
	// 0 is default.
	PriceOffset      *float64 `protobuf:"fixed64,5,opt,name=price_offset,json=priceOffset" json:"price_offset,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *LegDefinition) Reset()                    { *m = LegDefinition{} }
func (m *LegDefinition) String() string            { return proto.CompactTextString(m) }
func (*LegDefinition) ProtoMessage()               {}
func (*LegDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *LegDefinition) GetContractId() uint32 {
	if m != nil && m.ContractId != nil {
		return *m.ContractId
	}
	return 0
}

func (m *LegDefinition) GetNodeIndex() uint32 {
	if m != nil && m.NodeIndex != nil {
		return *m.NodeIndex
	}
	return 0
}

func (m *LegDefinition) GetQtyRatio() float64 {
	if m != nil && m.QtyRatio != nil {
		return *m.QtyRatio
	}
	return 0
}

func (m *LegDefinition) GetPriceRatio() float64 {
	if m != nil && m.PriceRatio != nil {
		return *m.PriceRatio
	}
	return 0
}

func (m *LegDefinition) GetPriceOffset() float64 {
	if m != nil && m.PriceOffset != nil {
		return *m.PriceOffset
	}
	return 0
}

// Defines a strategy nested inside a parent strategy.
type NestedStrategy struct {
	// Nested strategy definition.
	Definition *StrategyDefinition `protobuf:"bytes,1,req,name=definition" json:"definition,omitempty"`
	// Quantity ratio, signed decimal, number of leg contracts to buy(positive) or sell(negative).
	// Default is 1.
	QtyRatio *float64 `protobuf:"fixed64,2,opt,name=qty_ratio,json=qtyRatio" json:"qty_ratio,omitempty"`
	// Leg price calculation ratio, signed decimal, coefficient in strategy price formula.
	// Same as qty_ratio if omitted.
	PriceRatio       *float64 `protobuf:"fixed64,3,opt,name=price_ratio,json=priceRatio" json:"price_ratio,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *NestedStrategy) Reset()                    { *m = NestedStrategy{} }
func (m *NestedStrategy) String() string            { return proto.CompactTextString(m) }
func (*NestedStrategy) ProtoMessage()               {}
func (*NestedStrategy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *NestedStrategy) GetDefinition() *StrategyDefinition {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *NestedStrategy) GetQtyRatio() float64 {
	if m != nil && m.QtyRatio != nil {
		return *m.QtyRatio
	}
	return 0
}

func (m *NestedStrategy) GetPriceRatio() float64 {
	if m != nil && m.PriceRatio != nil {
		return *m.PriceRatio
	}
	return 0
}

// Child node definition within the parent strategy tree. Can be either a resolved contract (leg) or a nested strategy.
type StrategyNodeDefinition struct {
	// Specified node operation, one of NodeOperation enums, the default is SUM.
	NodeOperation *uint32 `protobuf:"varint,2,opt,name=node_operation,json=nodeOperation" json:"node_operation,omitempty"`
	// Leg definition, if the node is a resolved contract.
	Leg *LegDefinition `protobuf:"bytes,3,opt,name=leg" json:"leg,omitempty"`
	// Nested strategy, mutually exclusive with 'leg' attribute.
	NestedStrategy   *NestedStrategy `protobuf:"bytes,4,opt,name=nested_strategy,json=nestedStrategy" json:"nested_strategy,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *StrategyNodeDefinition) Reset()                    { *m = StrategyNodeDefinition{} }
func (m *StrategyNodeDefinition) String() string            { return proto.CompactTextString(m) }
func (*StrategyNodeDefinition) ProtoMessage()               {}
func (*StrategyNodeDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *StrategyNodeDefinition) GetNodeOperation() uint32 {
	if m != nil && m.NodeOperation != nil {
		return *m.NodeOperation
	}
	return 0
}

func (m *StrategyNodeDefinition) GetLeg() *LegDefinition {
	if m != nil {
		return m.Leg
	}
	return nil
}

func (m *StrategyNodeDefinition) GetNestedStrategy() *NestedStrategy {
	if m != nil {
		return m.NestedStrategy
	}
	return nil
}

// Describes tick size and value, and the range of prices they apply in.
type TickSizeByPrice struct {
	// Size or a single market tick in correct price format.
	TickSize *float64 `protobuf:"fixed64,1,req,name=tick_size,json=tickSize" json:"tick_size,omitempty"`
	// Contract tick money value in the contract's Currency.
	// Zero if not applicable (e.g. for indexes).
	TickValue *float64 `protobuf:"fixed64,2,req,name=tick_value,json=tickValue" json:"tick_value,omitempty"`
	// The tick size and value apply from this price (inclusive) and upper, to the next TickSizeByPrice.minimum_price, if any.
	// The price is in correct price format.
	MinimumPrice     *float64 `protobuf:"fixed64,3,req,name=minimum_price,json=minimumPrice" json:"minimum_price,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *TickSizeByPrice) Reset()                    { *m = TickSizeByPrice{} }
func (m *TickSizeByPrice) String() string            { return proto.CompactTextString(m) }
func (*TickSizeByPrice) ProtoMessage()               {}
func (*TickSizeByPrice) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *TickSizeByPrice) GetTickSize() float64 {
	if m != nil && m.TickSize != nil {
		return *m.TickSize
	}
	return 0
}

func (m *TickSizeByPrice) GetTickValue() float64 {
	if m != nil && m.TickValue != nil {
		return *m.TickValue
	}
	return 0
}

func (m *TickSizeByPrice) GetMinimumPrice() float64 {
	if m != nil && m.MinimumPrice != nil {
		return *m.MinimumPrice
	}
	return 0
}

// Describes tick size and value applied within some range of dates.
type TickSizeByDateTillExpiration struct {
	// Id of the record.  Starts from 0.  The record with Id of 0 applies immediately before contract expiration, Id of 1
	// applies before 0th, etc.
	Id *uint32 `protobuf:"varint,1,req,name=Id" json:"Id,omitempty"`
	// Size or a single market tick in correct price format.
	TickSize *float64 `protobuf:"fixed64,2,req,name=tick_size,json=tickSize" json:"tick_size,omitempty"`
	// Contract tick money value in the contract's Currency.
	// Zero if not applicable (e.g. for indexes).
	TickValue        *float64 `protobuf:"fixed64,3,req,name=tick_value,json=tickValue" json:"tick_value,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *TickSizeByDateTillExpiration) Reset()                    { *m = TickSizeByDateTillExpiration{} }
func (m *TickSizeByDateTillExpiration) String() string            { return proto.CompactTextString(m) }
func (*TickSizeByDateTillExpiration) ProtoMessage()               {}
func (*TickSizeByDateTillExpiration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *TickSizeByDateTillExpiration) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *TickSizeByDateTillExpiration) GetTickSize() float64 {
	if m != nil && m.TickSize != nil {
		return *m.TickSize
	}
	return 0
}

func (m *TickSizeByDateTillExpiration) GetTickValue() float64 {
	if m != nil && m.TickValue != nil {
		return *m.TickValue
	}
	return 0
}

type ContractMetadata struct {
	// Server assigned ID for a contract, it is not the same across sessions.
	ContractId *uint32 `protobuf:"varint,1,req,name=contract_id,json=contractId" json:"contract_id,omitempty"`
	// Full contract symbol.
	ContractSymbol *string `protobuf:"bytes,2,req,name=contract_symbol,json=contractSymbol" json:"contract_symbol,omitempty"`
	// Scale to convert prices from this protocol to correct prices
	// (correctPrice = price * correctPriceScale).
	CorrectPriceScale *float64 `protobuf:"fixed64,3,req,name=correct_price_scale,json=correctPriceScale" json:"correct_price_scale,omitempty"`
	// Display Price Scale is a number that defines conversion of float correct price to
	// a 'native' integer display format and back
	// Below is the table of possible scale values
	// -------------------------------------------------------
	// | Scale |       Name            |    Description      |
	// -------------------------------------------------------
	// | 0     |One                     |Don't scale         |
	// | 1     |TenMinusOne             |Divide by 10        |
	// | 2     |TenMinusTwo             |Divide by 100       |
	// | 3     |TenMinusThree           |Divide by 1000      |
	// | 4     |TenMinusFour            |Divide by 10000     |
	// | 5     |TenMinusFive            |Divide by 100000    |
	// | 6     |TenMinusSix             |Divide by 1000000   |
	// | 7     |TenMinusSeven           |Divide by 10000000  |
	// | 8     |TenMinusEight           |Divide by 100000000 |
	// | 9     |TenMinusNine            |Divide by 1000000000|
	// | 10    |TenMinusTen             |Divide by 10^10     |
	// | 11    |TenMinusEleven          |Divide by 10^11     |
	// | 12    |TenMinusTwelve          |Divide by 10^12     |
	// | 13    |TenMinusThirteen        |Divide by 10^13     |
	// | 14    |TenMinusFourteen        |Divide by 10^14     |
	// | 15    |TenMinusFifteen         |Divide by 10^15     |
	// | 101   |Halves                  |Divide by 2         |
	// | 102   |Fourths                 |Divide by 4         |
	// | 103   |Eighths                 |Divide by 8         |
	// | 104   |Sixteenths              |Divide by 16        |
	// | 105   |ThirtySeconds           |Divide by 32        |
	// | 106   |SixtyFourths            |Divide by 64        |
	// | 107   |OneHundredTwentyEighths |Divide by 128       |
	// | 108   |TwoHundredFiftySixths   |Divide by 256       |
	// | 109   |FiveHundredTwelths      |Divide by 512       |
	// | 110   |OneThousandTwentyFourths|Divide by 1024      |
	// | 201   |HalfThirtySeconds       |Similar to 64ths    |
	// | 202   |QuarterThirtySeconds    |Similar to 128ths   |
	// | 203   |EighthThirtySeconds     |Similar to 256ths   |
	// | 204   |HalfSixtyFourths        |Similar to 128ths   |
	// | 205   |QuarterSixtyFourths     |Similar to 256ths   |
	// -------------------------------------------------------
	DisplayPriceScale *uint32 `protobuf:"varint,4,req,name=display_price_scale,json=displayPriceScale" json:"display_price_scale,omitempty"`
	// Contract description.
	Description *string `protobuf:"bytes,5,req,name=description" json:"description,omitempty"`
	// Contract display name.
	Title *string `protobuf:"bytes,6,req,name=title" json:"title,omitempty"`
	// Size or a single market tick in correct price format.
	TickSize *float64 `protobuf:"fixed64,7,req,name=tick_size,json=tickSize" json:"tick_size,omitempty"`
	// Contract Currency code (ISO 4217 based).
	// Empty string if not applicable (e.g. for indexes).
	Currency *string `protobuf:"bytes,8,req,name=Currency" json:"Currency,omitempty"`
	// Contract tick money value in the contract's Currency.
	// Zero if not applicable (e.g. for indexes).
	TickValue *float64 `protobuf:"fixed64,9,req,name=tick_value,json=tickValue" json:"tick_value,omitempty"`
	// CFI code (Classification of Financial Instruments, ISO 10962).
	CfiCode *string `protobuf:"bytes,10,req,name=cfi_code,json=cfiCode" json:"cfi_code,omitempty"`
	// True if this contract is the most active one for derivatives.
	IsMostActive *bool `protobuf:"varint,11,opt,name=is_most_active,json=isMostActive" json:"is_most_active,omitempty"`
	// Contract trading date for derivatives
	// (local exchange date in time format, use date part only).
	LastTradingDate *int64 `protobuf:"zigzag64,12,opt,name=last_trading_date,json=lastTradingDate" json:"last_trading_date,omitempty"`
	// Contract first notice date
	// (local exchange date in time format, use date part only).
	FirstNoticeDate *int64 `protobuf:"zigzag64,13,opt,name=first_notice_date,json=firstNoticeDate" json:"first_notice_date,omitempty"`
	// Underlying contract symbol (e.g. for options).
	UnderlyingContractSymbol *string `protobuf:"bytes,14,opt,name=underlying_contract_symbol,json=underlyingContractSymbol" json:"underlying_contract_symbol,omitempty"`
	// This field is associated with MarginStyle enum type.
	MarginStyle *uint32 `protobuf:"varint,15,opt,name=margin_style,json=marginStyle" json:"margin_style,omitempty"`
	// Name of a group of contracts that share the same properties (e.g. commodity name for futures and options)
	InstrumentGroupName *string `protobuf:"bytes,16,req,name=instrument_group_name,json=instrumentGroupName" json:"instrument_group_name,omitempty"`
	// ID of a session information this contract is related to.
	SessionInfoId *int32 `protobuf:"zigzag32,17,req,name=session_info_id,json=sessionInfoId" json:"session_info_id,omitempty"`
	// Market segment MIC (ISO 10383) of the contract (if available).
	Mic *string `protobuf:"bytes,18,opt,name=mic" json:"mic,omitempty"`
	// if user is allowed to receive only delayed data of the contract
	// then this parameter is set to the delay value in milliseconds.
	Delay *int64 `protobuf:"zigzag64,20,opt,name=delay" json:"delay,omitempty"`
	// instrument group name without the prefix
	ShortInstrumentGroupName *string `protobuf:"bytes,21,req,name=short_instrument_group_name,json=shortInstrumentGroupName" json:"short_instrument_group_name,omitempty"`
	// description of the instrument group
	InstrumentGroupDescription *string `protobuf:"bytes,22,req,name=instrument_group_description,json=instrumentGroupDescription" json:"instrument_group_description,omitempty"`
	// Variable tick size by contract price (if available for the contract)
	// If variable tick sizes by contract price are available, tick_size and tick_value specify the minimal tick size
	// and value among these.
	// Only one of tick_sizes_by_price and tick_sizes_by_dte can be specified.
	TickSizesByPrice []*TickSizeByPrice `protobuf:"bytes,23,rep,name=tick_sizes_by_price,json=tickSizesByPrice" json:"tick_sizes_by_price,omitempty"`
	// Variable tick size by date till expiration (if available for the contract).  Sorted by Id in ascending order.
	// If variable tick sizes by DTE are available, tick_size and tick_value specify the tick size and value applicable at
	// the moment of symbol resolution.
	// Only one of tick_sizes_by_price and tick_sizes_by_dte can be specified.
	TickSizesByDte []*TickSizeByDateTillExpiration `protobuf:"bytes,24,rep,name=tick_sizes_by_dte,json=tickSizesByDte" json:"tick_sizes_by_dte,omitempty"`
	// Specifies which rule of TickSizeByDateTillExpiration applies now.
	TickSizesByDteId *uint32 `protobuf:"varint,25,opt,name=tick_sizes_by_dte_id,json=tickSizesByDteId" json:"tick_sizes_by_dte_id,omitempty"`
	// option strike display value.
	Strike *int32 `protobuf:"zigzag32,26,opt,name=strike" json:"strike,omitempty"`
	// option strike price value (directly in correct format).
	StrikePrice *float64 `protobuf:"fixed64,27,opt,name=strike_price,json=strikePrice" json:"strike_price,omitempty"`
	// Dialect of the contract symbol.
	// 0 - CQG dialect.
	DialectId *string `protobuf:"bytes,28,opt,name=dialect_id,json=dialectId" json:"dialect_id,omitempty"`
	// Two-letter exchange country code (ISO 3166-1 alpha 2).
	CountryCode *string `protobuf:"bytes,29,req,name=country_code,json=countryCode" json:"country_code,omitempty"`
	// Strategy definition if the contract is of a synthetic or a user defined strategy.
	StrategyDefinition *StrategyDefinition `protobuf:"bytes,30,opt,name=strategy_definition,json=strategyDefinition" json:"strategy_definition,omitempty"`
	XXX_unrecognized   []byte              `json:"-"`
}

func (m *ContractMetadata) Reset()                    { *m = ContractMetadata{} }
func (m *ContractMetadata) String() string            { return proto.CompactTextString(m) }
func (*ContractMetadata) ProtoMessage()               {}
func (*ContractMetadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *ContractMetadata) GetContractId() uint32 {
	if m != nil && m.ContractId != nil {
		return *m.ContractId
	}
	return 0
}

func (m *ContractMetadata) GetContractSymbol() string {
	if m != nil && m.ContractSymbol != nil {
		return *m.ContractSymbol
	}
	return ""
}

func (m *ContractMetadata) GetCorrectPriceScale() float64 {
	if m != nil && m.CorrectPriceScale != nil {
		return *m.CorrectPriceScale
	}
	return 0
}

func (m *ContractMetadata) GetDisplayPriceScale() uint32 {
	if m != nil && m.DisplayPriceScale != nil {
		return *m.DisplayPriceScale
	}
	return 0
}

func (m *ContractMetadata) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *ContractMetadata) GetTitle() string {
	if m != nil && m.Title != nil {
		return *m.Title
	}
	return ""
}

func (m *ContractMetadata) GetTickSize() float64 {
	if m != nil && m.TickSize != nil {
		return *m.TickSize
	}
	return 0
}

func (m *ContractMetadata) GetCurrency() string {
	if m != nil && m.Currency != nil {
		return *m.Currency
	}
	return ""
}

func (m *ContractMetadata) GetTickValue() float64 {
	if m != nil && m.TickValue != nil {
		return *m.TickValue
	}
	return 0
}

func (m *ContractMetadata) GetCfiCode() string {
	if m != nil && m.CfiCode != nil {
		return *m.CfiCode
	}
	return ""
}

func (m *ContractMetadata) GetIsMostActive() bool {
	if m != nil && m.IsMostActive != nil {
		return *m.IsMostActive
	}
	return false
}

func (m *ContractMetadata) GetLastTradingDate() int64 {
	if m != nil && m.LastTradingDate != nil {
		return *m.LastTradingDate
	}
	return 0
}

func (m *ContractMetadata) GetFirstNoticeDate() int64 {
	if m != nil && m.FirstNoticeDate != nil {
		return *m.FirstNoticeDate
	}
	return 0
}

func (m *ContractMetadata) GetUnderlyingContractSymbol() string {
	if m != nil && m.UnderlyingContractSymbol != nil {
		return *m.UnderlyingContractSymbol
	}
	return ""
}

func (m *ContractMetadata) GetMarginStyle() uint32 {
	if m != nil && m.MarginStyle != nil {
		return *m.MarginStyle
	}
	return 0
}

func (m *ContractMetadata) GetInstrumentGroupName() string {
	if m != nil && m.InstrumentGroupName != nil {
		return *m.InstrumentGroupName
	}
	return ""
}

func (m *ContractMetadata) GetSessionInfoId() int32 {
	if m != nil && m.SessionInfoId != nil {
		return *m.SessionInfoId
	}
	return 0
}

func (m *ContractMetadata) GetMic() string {
	if m != nil && m.Mic != nil {
		return *m.Mic
	}
	return ""
}

func (m *ContractMetadata) GetDelay() int64 {
	if m != nil && m.Delay != nil {
		return *m.Delay
	}
	return 0
}

func (m *ContractMetadata) GetShortInstrumentGroupName() string {
	if m != nil && m.ShortInstrumentGroupName != nil {
		return *m.ShortInstrumentGroupName
	}
	return ""
}

func (m *ContractMetadata) GetInstrumentGroupDescription() string {
	if m != nil && m.InstrumentGroupDescription != nil {
		return *m.InstrumentGroupDescription
	}
	return ""
}

func (m *ContractMetadata) GetTickSizesByPrice() []*TickSizeByPrice {
	if m != nil {
		return m.TickSizesByPrice
	}
	return nil
}

func (m *ContractMetadata) GetTickSizesByDte() []*TickSizeByDateTillExpiration {
	if m != nil {
		return m.TickSizesByDte
	}
	return nil
}

func (m *ContractMetadata) GetTickSizesByDteId() uint32 {
	if m != nil && m.TickSizesByDteId != nil {
		return *m.TickSizesByDteId
	}
	return 0
}

func (m *ContractMetadata) GetStrike() int32 {
	if m != nil && m.Strike != nil {
		return *m.Strike
	}
	return 0
}

func (m *ContractMetadata) GetStrikePrice() float64 {
	if m != nil && m.StrikePrice != nil {
		return *m.StrikePrice
	}
	return 0
}

func (m *ContractMetadata) GetDialectId() string {
	if m != nil && m.DialectId != nil {
		return *m.DialectId
	}
	return ""
}

func (m *ContractMetadata) GetCountryCode() string {
	if m != nil && m.CountryCode != nil {
		return *m.CountryCode
	}
	return ""
}

func (m *ContractMetadata) GetStrategyDefinition() *StrategyDefinition {
	if m != nil {
		return m.StrategyDefinition
	}
	return nil
}

// Request for information.
// There must be only one request type (e.g. accountsRequest and lastStatementBalancesRequest can not be sent at the same time).
type InformationRequest struct {
	// ID of a request and optional subscription that should be unique enough to match responses and updates with corresponding requests.
	Id *uint32 `protobuf:"varint,1,req,name=Id" json:"Id,omitempty"`
	// If set to true then corresponding reports are also sent when requested information is changed during the session,
	// if set to false then subscription is dropped,
	// if omitted then data is returned without changing subscription Status.
	Subscribe *bool `protobuf:"varint,2,opt,name=subscribe" json:"subscribe,omitempty"`
	// Request for authorized accounts for trading.
	// Only one subscription is possible.
	// Requests rate is limited, 100 per 24 hours by default.
	// Requests are accepted only if the user is not subscribed and there is no pending request for this information at the moment.
	AccountsRequest *AccountsRequest `protobuf:"bytes,3,opt,name=accounts_request,json=accountsRequest" json:"accounts_request,omitempty"`
	// Request symbol resolution with optional subscription.
	// Requests rate is limited, 10000 per 24 hours by default.
	// NOTE: subscription is essential to follow active contract switching.
	SymbolResolutionRequest *SymbolResolutionRequest `protobuf:"bytes,4,opt,name=symbol_resolution_request,json=symbolResolutionRequest" json:"symbol_resolution_request,omitempty"`
	// Request for balances from the last statement for all authorized accounts.
	// Only one subscription is possible.
	// Requests rate is limited, 100 per 24 hours by default.
	// Requests are accepted only if the user is not subscribed and there is no pending request for this information at the moment.
	LastStatementBalancesRequest *LastStatementBalancesRequest `protobuf:"bytes,5,opt,name=last_statement_balances_request,json=lastStatementBalancesRequest" json:"last_statement_balances_request,omitempty"`
	// Request for Currency rates for all brokerages user's accounts belong to.
	// Only one subscription is possible.
	// Requests rate is limited, 100 per 24 hours by default.
	// Requests are accepted only if the user is not subscribed and there is no pending request for this information at the moment.
	CurrencyRatesRequest *CurrencyRatesRequest `protobuf:"bytes,6,opt,name=currency_rates_request,json=currencyRatesRequest" json:"currency_rates_request,omitempty"`
	// Request for session information.
	// Number of simultaneous requests in processing is limited, 10 by default.
	// Number of simultaneous session information update subscriptions is limited, 200 by default.
	// Requests are accepted only if the user is not subscribed for this information at the moment.
	SessionInformationRequest *SessionInformationRequest `protobuf:"bytes,7,opt,name=session_information_request,json=sessionInformationRequest" json:"session_information_request,omitempty"`
	// Request for a list of historical orders (including all transactions) according to a search criteria.
	// Number of simultaneous requests in processing is limited, 1 by default.
	// The request depth is limited, 30 days by default.
	// Subscription is not supported for this request.
	HistoricalOrdersRequest *HistoricalOrdersRequest `protobuf:"bytes,13,opt,name=historical_orders_request,json=historicalOrdersRequest" json:"historical_orders_request,omitempty"`
	// Request a list of child symbols for an underlying contract.
	// Number of simultaneous requests in processing is limited, 5 by default.
	// Number of simultaneous update subscriptions is limited, 100 by default.
	SymbolsByUnderlyingRequest *SymbolsByUnderlyingRequest `protobuf:"bytes,14,opt,name=symbols_by_underlying_request,json=symbolsByUnderlyingRequest" json:"symbols_by_underlying_request,omitempty"`
	// Request a list of child symbols for a higher level symbol.
	// Number of simultaneous requests in processing is limited, 5 by default.
	// Number of simultaneous update subscriptions is limited, 100 by default.
	ChildSymbolsRequest *ChildSymbolsRequest `protobuf:"bytes,15,opt,name=child_symbols_request,json=childSymbolsRequest" json:"child_symbols_request,omitempty"`
	// Request at-the-money strike for the option maturity.
	// Number of simultaneous requests in processing is limited, 5 by default.
	// Number of simultaneous update subscriptions is limited, 100 by default.
	AtTheMoneyStrikeRequest *AtTheMoneyStrikeRequest `protobuf:"bytes,16,opt,name=at_the_money_strike_request,json=atTheMoneyStrikeRequest" json:"at_the_money_strike_request,omitempty"`
	// Request strategy definition with no subscription.
	// Requests rate is limited, 10000 per 24 hours by default.
	StrategyDefinitionRequest *StrategyDefinitionRequest `protobuf:"bytes,17,opt,name=strategy_definition_request,json=strategyDefinitionRequest" json:"strategy_definition_request,omitempty"`
	// Request for session timerange information.
	// Number of simultaneous requests in processing is limited, 10 by default.
	// The request range is limited. 1 year/1000 sessions by default.
	// Subsription is NOT supported for this request, so subscribe flag will be ignored.
	SessionTimerangeRequest *SessionTimeRangeRequest `protobuf:"bytes,18,opt,name=session_timerange_request,json=sessionTimerangeRequest" json:"session_timerange_request,omitempty"`
	// Request for trading day timerange information.
	// Number of simultaneous requests in processing is limited, 10 by default.
	// The request range is limited. 1 year/250 trading days by default.
	// Subsription is NOT supported for this request, so subscribe flag will be ignored.
	TradingDayTimerangeRequest *TradingDayTimeRangeRequest `protobuf:"bytes,19,opt,name=trading_day_timerange_request,json=tradingDayTimerangeRequest" json:"trading_day_timerange_request,omitempty"`
	XXX_unrecognized           []byte                      `json:"-"`
}

func (m *InformationRequest) Reset()                    { *m = InformationRequest{} }
func (m *InformationRequest) String() string            { return proto.CompactTextString(m) }
func (*InformationRequest) ProtoMessage()               {}
func (*InformationRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *InformationRequest) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *InformationRequest) GetSubscribe() bool {
	if m != nil && m.Subscribe != nil {
		return *m.Subscribe
	}
	return false
}

func (m *InformationRequest) GetAccountsRequest() *AccountsRequest {
	if m != nil {
		return m.AccountsRequest
	}
	return nil
}

func (m *InformationRequest) GetSymbolResolutionRequest() *SymbolResolutionRequest {
	if m != nil {
		return m.SymbolResolutionRequest
	}
	return nil
}

func (m *InformationRequest) GetLastStatementBalancesRequest() *LastStatementBalancesRequest {
	if m != nil {
		return m.LastStatementBalancesRequest
	}
	return nil
}

func (m *InformationRequest) GetCurrencyRatesRequest() *CurrencyRatesRequest {
	if m != nil {
		return m.CurrencyRatesRequest
	}
	return nil
}

func (m *InformationRequest) GetSessionInformationRequest() *SessionInformationRequest {
	if m != nil {
		return m.SessionInformationRequest
	}
	return nil
}

func (m *InformationRequest) GetHistoricalOrdersRequest() *HistoricalOrdersRequest {
	if m != nil {
		return m.HistoricalOrdersRequest
	}
	return nil
}

func (m *InformationRequest) GetSymbolsByUnderlyingRequest() *SymbolsByUnderlyingRequest {
	if m != nil {
		return m.SymbolsByUnderlyingRequest
	}
	return nil
}

func (m *InformationRequest) GetChildSymbolsRequest() *ChildSymbolsRequest {
	if m != nil {
		return m.ChildSymbolsRequest
	}
	return nil
}

func (m *InformationRequest) GetAtTheMoneyStrikeRequest() *AtTheMoneyStrikeRequest {
	if m != nil {
		return m.AtTheMoneyStrikeRequest
	}
	return nil
}

func (m *InformationRequest) GetStrategyDefinitionRequest() *StrategyDefinitionRequest {
	if m != nil {
		return m.StrategyDefinitionRequest
	}
	return nil
}

func (m *InformationRequest) GetSessionTimerangeRequest() *SessionTimeRangeRequest {
	if m != nil {
		return m.SessionTimerangeRequest
	}
	return nil
}

func (m *InformationRequest) GetTradingDayTimerangeRequest() *TradingDayTimeRangeRequest {
	if m != nil {
		return m.TradingDayTimerangeRequest
	}
	return nil
}

// Report with requested information and subscription updates.
// It will contain only one report type at the same time (related to Id).
type InformationReport struct {
	// Report ID is equal to a corresponding request and subscription ID.
	Id *uint32 `protobuf:"varint,1,req,name=Id" json:"Id,omitempty"`
	// True means that requested data is complete at the moment, false means more report messages are expected for completeness.
	IsReportComplete *bool `protobuf:"varint,2,opt,name=is_report_complete,json=isReportComplete,def=1" json:"is_report_complete,omitempty"`
	// This field is associated with StatusCode enum type.
	StatusCode *uint32 `protobuf:"varint,3,req,name=status_code,json=statusCode" json:"status_code,omitempty"`
	// Possible details of Status or failure.
	TextMessage *string `protobuf:"bytes,4,opt,name=text_message,json=textMessage" json:"text_message,omitempty"`
	// Report with trading accounts.
	AccountsReport *AccountsReport `protobuf:"bytes,5,opt,name=accounts_report,json=accountsReport" json:"accounts_report,omitempty"`
	// Resolved symbol initial information or update.
	SymbolResolutionReport *SymbolResolutionReport `protobuf:"bytes,6,opt,name=symbol_resolution_report,json=symbolResolutionReport" json:"symbol_resolution_report,omitempty"`
	// Report with balances from the last statement for all authorized accounts.
	LastStatementBalancesReport *LastStatementBalancesReport `protobuf:"bytes,7,opt,name=last_statement_balances_report,json=lastStatementBalancesReport" json:"last_statement_balances_report,omitempty"`
	// Report with Currency rates per brokerage.
	CurrencyRatesReport *CurrencyRatesReport `protobuf:"bytes,8,opt,name=currency_rates_report,json=currencyRatesReport" json:"currency_rates_report,omitempty"`
	// Report with session information.
	SessionInformationReport *SessionInformationReport `protobuf:"bytes,9,opt,name=session_information_report,json=sessionInformationReport" json:"session_information_report,omitempty"`
	// Report with a list of historical orders according to specified parameters.
	HistoricalOrdersReport *HistoricalOrdersReport `protobuf:"bytes,15,opt,name=historical_orders_report,json=historicalOrdersReport" json:"historical_orders_report,omitempty"`
	// Report with a list of symbols for an underlying contract.
	SymbolsByUnderlyingReport *SymbolsByUnderlyingReport `protobuf:"bytes,16,opt,name=symbols_by_underlying_report,json=symbolsByUnderlyingReport" json:"symbols_by_underlying_report,omitempty"`
	// Report with a list of child symbols.
	ChildSymbolsReport *ChildSymbolsReport `protobuf:"bytes,17,opt,name=child_symbols_report,json=childSymbolsReport" json:"child_symbols_report,omitempty"`
	// Report with at-the-money strikes.
	AtTheMoneyStrikeReport *AtTheMoneyStrikeReport `protobuf:"bytes,18,opt,name=at_the_money_strike_report,json=atTheMoneyStrikeReport" json:"at_the_money_strike_report,omitempty"`
	// Report with the defined strategy metadata
	StrategyDefinitionReport *StrategyDefinitionReport `protobuf:"bytes,19,opt,name=strategy_definition_report,json=strategyDefinitionReport" json:"strategy_definition_report,omitempty"`
	// Report with session timerange information
	SessionTimerangeReport *SessionTimeRangeReport `protobuf:"bytes,20,opt,name=session_timerange_report,json=sessionTimerangeReport" json:"session_timerange_report,omitempty"`
	// Report with trading day timerange information
	TradingDayTimerangeReport *TradingDayTimeRangeReport `protobuf:"bytes,21,opt,name=trading_day_timerange_report,json=tradingDayTimerangeReport" json:"trading_day_timerange_report,omitempty"`
	XXX_unrecognized          []byte                     `json:"-"`
}

func (m *InformationReport) Reset()                    { *m = InformationReport{} }
func (m *InformationReport) String() string            { return proto.CompactTextString(m) }
func (*InformationReport) ProtoMessage()               {}
func (*InformationReport) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

const Default_InformationReport_IsReportComplete bool = true

func (m *InformationReport) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *InformationReport) GetIsReportComplete() bool {
	if m != nil && m.IsReportComplete != nil {
		return *m.IsReportComplete
	}
	return Default_InformationReport_IsReportComplete
}

func (m *InformationReport) GetStatusCode() uint32 {
	if m != nil && m.StatusCode != nil {
		return *m.StatusCode
	}
	return 0
}

func (m *InformationReport) GetTextMessage() string {
	if m != nil && m.TextMessage != nil {
		return *m.TextMessage
	}
	return ""
}

func (m *InformationReport) GetAccountsReport() *AccountsReport {
	if m != nil {
		return m.AccountsReport
	}
	return nil
}

func (m *InformationReport) GetSymbolResolutionReport() *SymbolResolutionReport {
	if m != nil {
		return m.SymbolResolutionReport
	}
	return nil
}

func (m *InformationReport) GetLastStatementBalancesReport() *LastStatementBalancesReport {
	if m != nil {
		return m.LastStatementBalancesReport
	}
	return nil
}

func (m *InformationReport) GetCurrencyRatesReport() *CurrencyRatesReport {
	if m != nil {
		return m.CurrencyRatesReport
	}
	return nil
}

func (m *InformationReport) GetSessionInformationReport() *SessionInformationReport {
	if m != nil {
		return m.SessionInformationReport
	}
	return nil
}

func (m *InformationReport) GetHistoricalOrdersReport() *HistoricalOrdersReport {
	if m != nil {
		return m.HistoricalOrdersReport
	}
	return nil
}

func (m *InformationReport) GetSymbolsByUnderlyingReport() *SymbolsByUnderlyingReport {
	if m != nil {
		return m.SymbolsByUnderlyingReport
	}
	return nil
}

func (m *InformationReport) GetChildSymbolsReport() *ChildSymbolsReport {
	if m != nil {
		return m.ChildSymbolsReport
	}
	return nil
}

func (m *InformationReport) GetAtTheMoneyStrikeReport() *AtTheMoneyStrikeReport {
	if m != nil {
		return m.AtTheMoneyStrikeReport
	}
	return nil
}

func (m *InformationReport) GetStrategyDefinitionReport() *StrategyDefinitionReport {
	if m != nil {
		return m.StrategyDefinitionReport
	}
	return nil
}

func (m *InformationReport) GetSessionTimerangeReport() *SessionTimeRangeReport {
	if m != nil {
		return m.SessionTimerangeReport
	}
	return nil
}

func (m *InformationReport) GetTradingDayTimerangeReport() *TradingDayTimeRangeReport {
	if m != nil {
		return m.TradingDayTimerangeReport
	}
	return nil
}

// Request for a list of accounts this user is authorized to use and/ or monitor, empty message.
type AccountsRequest struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *AccountsRequest) Reset()                    { *m = AccountsRequest{} }
func (m *AccountsRequest) String() string            { return proto.CompactTextString(m) }
func (*AccountsRequest) ProtoMessage()               {}
func (*AccountsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

// Response with a list of authorized accounts grouped by brokerage firms and internal sales series (Username groups),
// the same Username can not belong to more than one Username group.
type AccountsReport struct {
	// List or brokerages with accounts the user works with.
	Brokerage        []*Brokerage `protobuf:"bytes,1,rep,name=brokerage" json:"brokerage,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *AccountsReport) Reset()                    { *m = AccountsReport{} }
func (m *AccountsReport) String() string            { return proto.CompactTextString(m) }
func (*AccountsReport) ProtoMessage()               {}
func (*AccountsReport) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

func (m *AccountsReport) GetBrokerage() []*Brokerage {
	if m != nil {
		return m.Brokerage
	}
	return nil
}

// List of brokerage accounts.
type Brokerage struct {
	// Brokerage firm ID in CQG trade routing system.
	Id *uint32 `protobuf:"varint,1,req,name=Id" json:"Id,omitempty"`
	// Brokerage firm name.
	Name *string `protobuf:"bytes,2,req,name=name" json:"name,omitempty"`
	// List of sales series.
	SalesSeries      []*SalesSeries `protobuf:"bytes,3,rep,name=sales_series,json=salesSeries" json:"sales_series,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Brokerage) Reset()                    { *m = Brokerage{} }
func (m *Brokerage) String() string            { return proto.CompactTextString(m) }
func (*Brokerage) ProtoMessage()               {}
func (*Brokerage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

func (m *Brokerage) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Brokerage) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Brokerage) GetSalesSeries() []*SalesSeries {
	if m != nil {
		return m.SalesSeries
	}
	return nil
}

// List of accounts in a sales series group.
type SalesSeries struct {
	// Sales series number in CQG trade routing system.
	Number *string `protobuf:"bytes,1,req,name=number" json:"number,omitempty"`
	// Sales series name.
	Name *string `protobuf:"bytes,2,req,name=name" json:"name,omitempty"`
	// List of accounts.
	Account          []*Account `protobuf:"bytes,3,rep,name=Username" json:"Username,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *SalesSeries) Reset()                    { *m = SalesSeries{} }
func (m *SalesSeries) String() string            { return proto.CompactTextString(m) }
func (*SalesSeries) ProtoMessage()               {}
func (*SalesSeries) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

func (m *SalesSeries) GetNumber() string {
	if m != nil && m.Number != nil {
		return *m.Number
	}
	return ""
}

func (m *SalesSeries) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *SalesSeries) GetAccount() []*Account {
	if m != nil {
		return m.Account
	}
	return nil
}

// Trade routing Username data.
type Account struct {
	// Account ID in CQG trade routing system.
	AccountId *int32 `protobuf:"zigzag32,1,req,name=account_id,json=accountId" json:"account_id,omitempty"`
	// Account ID in Brokerage Firm.
	BrokerageAccountId *string `protobuf:"bytes,2,req,name=brokerage_account_id,json=brokerageAccountId" json:"brokerage_account_id,omitempty"`
	// Account name in CQG trade routing system.
	Name *string `protobuf:"bytes,3,req,name=name" json:"name,omitempty"`
	// Last statement date for this Username
	// (brokerage local date in time format, use date part only).
	LastStatementDate *int64 `protobuf:"zigzag64,4,req,name=last_statement_date,json=lastStatementDate" json:"last_statement_date,omitempty"`
	// True if user can only monitor this Username without trading.
	IsViewOnly *bool `protobuf:"varint,5,opt,name=is_view_only,json=isViewOnly" json:"is_view_only,omitempty"`
	// True if user was unauthorized and is not able to use/ see this Username anymore.
	IsUnauthorized *bool `protobuf:"varint,6,opt,name=is_unauthorized,json=isUnauthorized" json:"is_unauthorized,omitempty"`
	// ID of cluster of common properties the Username belongs to (if any).
	AccountClusterId *int64 `protobuf:"zigzag64,7,opt,name=account_cluster_id,json=accountClusterId" json:"account_cluster_id,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Account) Reset()                    { *m = Account{} }
func (m *Account) String() string            { return proto.CompactTextString(m) }
func (*Account) ProtoMessage()               {}
func (*Account) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

func (m *Account) GetAccountId() int32 {
	if m != nil && m.AccountId != nil {
		return *m.AccountId
	}
	return 0
}

func (m *Account) GetBrokerageAccountId() string {
	if m != nil && m.BrokerageAccountId != nil {
		return *m.BrokerageAccountId
	}
	return ""
}

func (m *Account) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Account) GetLastStatementDate() int64 {
	if m != nil && m.LastStatementDate != nil {
		return *m.LastStatementDate
	}
	return 0
}

func (m *Account) GetIsViewOnly() bool {
	if m != nil && m.IsViewOnly != nil {
		return *m.IsViewOnly
	}
	return false
}

func (m *Account) GetIsUnauthorized() bool {
	if m != nil && m.IsUnauthorized != nil {
		return *m.IsUnauthorized
	}
	return false
}

func (m *Account) GetAccountClusterId() int64 {
	if m != nil && m.AccountClusterId != nil {
		return *m.AccountClusterId
	}
	return 0
}

// Request to resolve a symbol pattern or specific symbol identifier to a specific contract with optional subscription for meta-data updates.
// Symbol resolution rules:
//   a) If the requested symbol points to a symbol prefix rather than a specific contract then it is resolved into the most active contract for
//      this symbol prefix (e.g. 'EP' is resolved to 'EPU3').
//      The update is sent when an active contract is changed (e.g. the update might contain the following 'EPZ3')
//   b) If the requested symbol points to a specific contract that is expired already then Status code NOT_FOUND is returned in InformationReport.
//   c) If the requested symbol points to a specific contract that is tradable right now then it is resolved to itself. Update is sent only when
//      meta-data for such contract is changed or expired. In case of expiration SymbolResolutionReport is returned with 'deleted' field set to True.
//   d) If requested symbol points to an option instrument without specific month and strike it is resolved to the lead (first non-spot) month
//      of the underlying future or its own front month if the underlying contract is not a future (e.g. 'C.EP' is resolved to 'C.EPU131600').
//      Update is sent only when the resolved option contract is expired (strike is not updated to follow underlying contract market price).
//   e) If requested symbol is a symbol prefix that follows '?N' or '??N' (where N is number, e.g. EP?2) then it is resolved to
//      Nth nearest contract.
//      N = 1 means 'front' contract, N = 2 means the nearest contract that follows the front, etc.
//      '?' and '??' are different for futures only and '?' means Nth nearest regular future and '??' means Nth nearest spot or regular future.
//      Update is sent when the front contract expired and replaced with the following contract (relative position change).
//      N = 0 is a special case that means 'most active' contract which works the same way as (a)
// NOTE: Available and active contract lists are updated within 24 hours of an expiring contract's final trading session.
//       Meta-data updates for affected contracts, when a subscription is present, are sent when the list updates occur.
//       Initial resolution requests use the same lists, so the best way to avoid inconsistency and unnecessary server load is to subscribe
//       and process updates when notified.
type SymbolResolutionRequest struct {
	// Symbol pattern to resolve.
	Symbol           *string `protobuf:"bytes,1,req,name=symbol" json:"symbol,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SymbolResolutionRequest) Reset()                    { *m = SymbolResolutionRequest{} }
func (m *SymbolResolutionRequest) String() string            { return proto.CompactTextString(m) }
func (*SymbolResolutionRequest) ProtoMessage()               {}
func (*SymbolResolutionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

func (m *SymbolResolutionRequest) GetSymbol() string {
	if m != nil && m.Symbol != nil {
		return *m.Symbol
	}
	return ""
}

// Symbol resolution result or update.
type SymbolResolutionReport struct {
	// Resolved contract meta-data.
	ContractMetadata *ContractMetadata `protobuf:"bytes,1,req,name=contract_metadata,json=contractMetadata" json:"contract_metadata,omitempty"`
	// Contract is expired (used for updates).
	Deleted          *bool  `protobuf:"varint,2,opt,name=deleted" json:"deleted,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SymbolResolutionReport) Reset()                    { *m = SymbolResolutionReport{} }
func (m *SymbolResolutionReport) String() string            { return proto.CompactTextString(m) }
func (*SymbolResolutionReport) ProtoMessage()               {}
func (*SymbolResolutionReport) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

func (m *SymbolResolutionReport) GetContractMetadata() *ContractMetadata {
	if m != nil {
		return m.ContractMetadata
	}
	return nil
}

func (m *SymbolResolutionReport) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

// Request for balances from the last statement for all authorized accounts.
type LastStatementBalancesRequest struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *LastStatementBalancesRequest) Reset()                    { *m = LastStatementBalancesRequest{} }
func (m *LastStatementBalancesRequest) String() string            { return proto.CompactTextString(m) }
func (*LastStatementBalancesRequest) ProtoMessage()               {}
func (*LastStatementBalancesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{46} }

// Report with balances from the last statement for all authorized accounts,
// they will be sent as a response to a corresponding request
// and after each statement processing (if subscribed).
type LastStatementBalancesReport struct {
	Balance          []*Balance `protobuf:"bytes,1,rep,name=balance" json:"balance,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *LastStatementBalancesReport) Reset()                    { *m = LastStatementBalancesReport{} }
func (m *LastStatementBalancesReport) String() string            { return proto.CompactTextString(m) }
func (*LastStatementBalancesReport) ProtoMessage()               {}
func (*LastStatementBalancesReport) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{47} }

func (m *LastStatementBalancesReport) GetBalance() []*Balance {
	if m != nil {
		return m.Balance
	}
	return nil
}

// Balance record for one of the accounts and one of the currencies (Id is used as a key for updates).
// Values like OTE, UPL and MVO are from statements and won't be updated in real time but after each next statement.
// Money related values are in the specified Currency.
// NOTE: There could be more then one balance for one Username and one Currency.
//       Not all values for a balance record are provided by all statements, it is up to Brokerage to include such values and only
//       Currency and ending cash balance are required to be valid.
type Balance struct {
	// Surrogate Id as a key for updates.
	Id *int32 `protobuf:"zigzag32,1,req,name=Id" json:"Id,omitempty"`
	// Account of this balance record.
	AccountId *int32 `protobuf:"zigzag32,2,req,name=account_id,json=accountId" json:"account_id,omitempty"`
	// Statement date this positions is related.
	StatementDate *int64 `protobuf:"zigzag64,3,req,name=statement_date,json=statementDate" json:"statement_date,omitempty"`
	// Currency code (ISO 4217 based).
	Currency *string `protobuf:"bytes,4,req,name=Currency" json:"Currency,omitempty"`
	// Ending Cash Balance.
	Balance *float64 `protobuf:"fixed64,5,req,name=balance" json:"balance,omitempty"`
	// Total Account Value.
	TotalValue *float64 `protobuf:"fixed64,6,req,name=total_value,json=totalValue" json:"total_value,omitempty"`
	// Open Trade Equity for Futures.
	Ote *float64 `protobuf:"fixed64,7,req,name=ote" json:"ote,omitempty"`
	// Unrealized profit-loss.
	Upl *float64 `protobuf:"fixed64,8,req,name=Upl" json:"Upl,omitempty"`
	// Market Value of options.
	Mvo *float64 `protobuf:"fixed64,9,req,name=Mvo" json:"Mvo,omitempty"`
	// Cash Excess.
	CashExcess *float64 `protobuf:"fixed64,10,req,name=cash_excess,json=cashExcess" json:"cash_excess,omitempty"`
	// Collateral on Deposit.
	Collateral *float64 `protobuf:"fixed64,11,req,name=collateral" json:"collateral,omitempty"`
	// Initial Margin Requirements.
	InitialMargin    *float64 `protobuf:"fixed64,12,req,name=initial_margin,json=initialMargin" json:"initial_margin,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Balance) Reset()                    { *m = Balance{} }
func (m *Balance) String() string            { return proto.CompactTextString(m) }
func (*Balance) ProtoMessage()               {}
func (*Balance) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{48} }

func (m *Balance) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Balance) GetAccountId() int32 {
	if m != nil && m.AccountId != nil {
		return *m.AccountId
	}
	return 0
}

func (m *Balance) GetStatementDate() int64 {
	if m != nil && m.StatementDate != nil {
		return *m.StatementDate
	}
	return 0
}

func (m *Balance) GetCurrency() string {
	if m != nil && m.Currency != nil {
		return *m.Currency
	}
	return ""
}

func (m *Balance) GetBalance() float64 {
	if m != nil && m.Balance != nil {
		return *m.Balance
	}
	return 0
}

func (m *Balance) GetTotalValue() float64 {
	if m != nil && m.TotalValue != nil {
		return *m.TotalValue
	}
	return 0
}

func (m *Balance) GetOte() float64 {
	if m != nil && m.Ote != nil {
		return *m.Ote
	}
	return 0
}

func (m *Balance) GetUpl() float64 {
	if m != nil && m.Upl != nil {
		return *m.Upl
	}
	return 0
}

func (m *Balance) GetMvo() float64 {
	if m != nil && m.Mvo != nil {
		return *m.Mvo
	}
	return 0
}

func (m *Balance) GetCashExcess() float64 {
	if m != nil && m.CashExcess != nil {
		return *m.CashExcess
	}
	return 0
}

func (m *Balance) GetCollateral() float64 {
	if m != nil && m.Collateral != nil {
		return *m.Collateral
	}
	return 0
}

func (m *Balance) GetInitialMargin() float64 {
	if m != nil && m.InitialMargin != nil {
		return *m.InitialMargin
	}
	return 0
}

// Request for Currency rates for all brokerages user's accounts belong to.
type CurrencyRatesRequest struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *CurrencyRatesRequest) Reset()                    { *m = CurrencyRatesRequest{} }
func (m *CurrencyRatesRequest) String() string            { return proto.CompactTextString(m) }
func (*CurrencyRatesRequest) ProtoMessage()               {}
func (*CurrencyRatesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{49} }

// Report with Currency rates per brokerage.
// It will be sent as a response to a corresponding request
// and after each statement processing (if subscribed).
type CurrencyRatesReport struct {
	// List of rates per brokerage the user is authorized to.
	BrokerageCurrencyRates []*BrokerageCurrencyRates `protobuf:"bytes,1,rep,name=brokerage_currency_rates,json=brokerageCurrencyRates" json:"brokerage_currency_rates,omitempty"`
	XXX_unrecognized       []byte                    `json:"-"`
}

func (m *CurrencyRatesReport) Reset()                    { *m = CurrencyRatesReport{} }
func (m *CurrencyRatesReport) String() string            { return proto.CompactTextString(m) }
func (*CurrencyRatesReport) ProtoMessage()               {}
func (*CurrencyRatesReport) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{50} }

func (m *CurrencyRatesReport) GetBrokerageCurrencyRates() []*BrokerageCurrencyRates {
	if m != nil {
		return m.BrokerageCurrencyRates
	}
	return nil
}

// Currency rates of one brokerage.
type BrokerageCurrencyRates struct {
	// Brokerage ID.
	BrokerageId *uint32 `protobuf:"varint,1,req,name=brokerage_id,json=brokerageId" json:"brokerage_id,omitempty"`
	// Master Currency code to which rates are provided (ISO 4217 based).
	MasterCurrency *string `protobuf:"bytes,2,req,name=master_currency,json=masterCurrency" json:"master_currency,omitempty"`
	// Statement date.
	StatementDate *int64 `protobuf:"zigzag64,3,req,name=statement_date,json=statementDate" json:"statement_date,omitempty"`
	// List of brokerage rates.
	CurrencyRate     []*CurrencyRate `protobuf:"bytes,4,rep,name=currency_rate,json=currencyRate" json:"currency_rate,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *BrokerageCurrencyRates) Reset()                    { *m = BrokerageCurrencyRates{} }
func (m *BrokerageCurrencyRates) String() string            { return proto.CompactTextString(m) }
func (*BrokerageCurrencyRates) ProtoMessage()               {}
func (*BrokerageCurrencyRates) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{51} }

func (m *BrokerageCurrencyRates) GetBrokerageId() uint32 {
	if m != nil && m.BrokerageId != nil {
		return *m.BrokerageId
	}
	return 0
}

func (m *BrokerageCurrencyRates) GetMasterCurrency() string {
	if m != nil && m.MasterCurrency != nil {
		return *m.MasterCurrency
	}
	return ""
}

func (m *BrokerageCurrencyRates) GetStatementDate() int64 {
	if m != nil && m.StatementDate != nil {
		return *m.StatementDate
	}
	return 0
}

func (m *BrokerageCurrencyRates) GetCurrencyRate() []*CurrencyRate {
	if m != nil {
		return m.CurrencyRate
	}
	return nil
}

// Rate of one Currency to a master Currency for the brokerage.
type CurrencyRate struct {
	// Currency code (ISO 4217 based).
	Currency *string `protobuf:"bytes,2,req,name=Currency" json:"Currency,omitempty"`
	// Exchange rate.
	Rate             *float64 `protobuf:"fixed64,3,req,name=rate" json:"rate,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *CurrencyRate) Reset()                    { *m = CurrencyRate{} }
func (m *CurrencyRate) String() string            { return proto.CompactTextString(m) }
func (*CurrencyRate) ProtoMessage()               {}
func (*CurrencyRate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{52} }

func (m *CurrencyRate) GetCurrency() string {
	if m != nil && m.Currency != nil {
		return *m.Currency
	}
	return ""
}

func (m *CurrencyRate) GetRate() float64 {
	if m != nil && m.Rate != nil {
		return *m.Rate
	}
	return 0
}

// Request for session information per instrument group.
type SessionInformationRequest struct {
	// ID of a session information from contract meta-data.
	SessionInfoId *int32 `protobuf:"zigzag32,1,req,name=session_info_id,json=sessionInfoId" json:"session_info_id,omitempty"`
	// UTC time from which session information is requested (e.g. if historical session times are necessary)
	// Current time is used by default.
	FromUtcTime *int64 `protobuf:"zigzag64,2,opt,name=from_utc_time,json=fromUtcTime" json:"from_utc_time,omitempty"`
	// UTC time up to which session information is requested (e.g. if future session times are necessary)
	// Current time is used by default. This field must not be used with subscriptions.
	ToUtcTime        *int64 `protobuf:"zigzag64,3,opt,name=to_utc_time,json=toUtcTime" json:"to_utc_time,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SessionInformationRequest) Reset()                    { *m = SessionInformationRequest{} }
func (m *SessionInformationRequest) String() string            { return proto.CompactTextString(m) }
func (*SessionInformationRequest) ProtoMessage()               {}
func (*SessionInformationRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{53} }

func (m *SessionInformationRequest) GetSessionInfoId() int32 {
	if m != nil && m.SessionInfoId != nil {
		return *m.SessionInfoId
	}
	return 0
}

func (m *SessionInformationRequest) GetFromUtcTime() int64 {
	if m != nil && m.FromUtcTime != nil {
		return *m.FromUtcTime
	}
	return 0
}

func (m *SessionInformationRequest) GetToUtcTime() int64 {
	if m != nil && m.ToUtcTime != nil {
		return *m.ToUtcTime
	}
	return 0
}

// Report with session information.
type SessionInformationReport struct {
	// Session information ID.
	SessionInfoId *int32 `protobuf:"zigzag32,1,req,name=session_info_id,json=sessionInfoId" json:"session_info_id,omitempty"`
	// List of session segment records.
	SessionSegment   []*SessionSegment `protobuf:"bytes,2,rep,name=session_segment,json=sessionSegment" json:"session_segment,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *SessionInformationReport) Reset()                    { *m = SessionInformationReport{} }
func (m *SessionInformationReport) String() string            { return proto.CompactTextString(m) }
func (*SessionInformationReport) ProtoMessage()               {}
func (*SessionInformationReport) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{54} }

func (m *SessionInformationReport) GetSessionInfoId() int32 {
	if m != nil && m.SessionInfoId != nil {
		return *m.SessionInfoId
	}
	return 0
}

func (m *SessionInformationReport) GetSessionSegment() []*SessionSegment {
	if m != nil {
		return m.SessionSegment
	}
	return nil
}

// Session segment record.
type SessionSegment struct {
	// Session segment ID useful for updates.
	SessionSegmentId *int32 `protobuf:"zigzag32,1,req,name=session_segment_id,json=sessionSegmentId" json:"session_segment_id,omitempty"`
	// Session group is deleted (used for updates).
	Deleted *bool `protobuf:"varint,2,opt,name=deleted" json:"deleted,omitempty"`
	// UTC time from which this session information is effective (inclusive).
	// It is omitted if this session information was the same since Instrument group was introduced.
	FromUtcTime *int64 `protobuf:"zigzag64,3,opt,name=from_utc_time,json=fromUtcTime" json:"from_utc_time,omitempty"`
	// UTC time up to which this session information is effective (exclusive).
	// It is omitted if this session information is not planned yet to be changed.
	ToUtcTime *int64 `protobuf:"zigzag64,4,opt,name=to_utc_time,json=toUtcTime" json:"to_utc_time,omitempty"`
	// Schedule for all sessions.
	SessionSchedule []*SessionSchedule `protobuf:"bytes,5,rep,name=session_schedule,json=sessionSchedule" json:"session_schedule,omitempty"`
	// Trading day schedule.
	TradingDay []*TradingDay `protobuf:"bytes,6,rep,name=trading_day,json=tradingDay" json:"trading_day,omitempty"`
	// Daily holidays. May have some sessions interday, but daily bar is not created.
	DailyHoliday     []*SessionHoliday `protobuf:"bytes,7,rep,name=daily_holiday,json=dailyHoliday" json:"daily_holiday,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *SessionSegment) Reset()                    { *m = SessionSegment{} }
func (m *SessionSegment) String() string            { return proto.CompactTextString(m) }
func (*SessionSegment) ProtoMessage()               {}
func (*SessionSegment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{55} }

func (m *SessionSegment) GetSessionSegmentId() int32 {
	if m != nil && m.SessionSegmentId != nil {
		return *m.SessionSegmentId
	}
	return 0
}

func (m *SessionSegment) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

func (m *SessionSegment) GetFromUtcTime() int64 {
	if m != nil && m.FromUtcTime != nil {
		return *m.FromUtcTime
	}
	return 0
}

func (m *SessionSegment) GetToUtcTime() int64 {
	if m != nil && m.ToUtcTime != nil {
		return *m.ToUtcTime
	}
	return 0
}

func (m *SessionSegment) GetSessionSchedule() []*SessionSchedule {
	if m != nil {
		return m.SessionSchedule
	}
	return nil
}

func (m *SessionSegment) GetTradingDay() []*TradingDay {
	if m != nil {
		return m.TradingDay
	}
	return nil
}

func (m *SessionSegment) GetDailyHoliday() []*SessionHoliday {
	if m != nil {
		return m.DailyHoliday
	}
	return nil
}

// Session schedule.
type SessionSchedule struct {
	// Session name.
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// List of session times per day of week.
	SessionDay []*SessionDay `protobuf:"bytes,2,rep,name=session_day,json=sessionDay" json:"session_day,omitempty"`
	// List of exchange specific dates when this session is closed.
	SessionHoliday []*SessionHoliday `protobuf:"bytes,3,rep,name=session_holiday,json=sessionHoliday" json:"session_holiday,omitempty"`
	// True if this is a primary session.
	IsPrimary        *bool  `protobuf:"varint,4,opt,name=is_primary,json=isPrimary" json:"is_primary,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SessionSchedule) Reset()                    { *m = SessionSchedule{} }
func (m *SessionSchedule) String() string            { return proto.CompactTextString(m) }
func (*SessionSchedule) ProtoMessage()               {}
func (*SessionSchedule) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{56} }

func (m *SessionSchedule) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *SessionSchedule) GetSessionDay() []*SessionDay {
	if m != nil {
		return m.SessionDay
	}
	return nil
}

func (m *SessionSchedule) GetSessionHoliday() []*SessionHoliday {
	if m != nil {
		return m.SessionHoliday
	}
	return nil
}

func (m *SessionSchedule) GetIsPrimary() bool {
	if m != nil && m.IsPrimary != nil {
		return *m.IsPrimary
	}
	return false
}

// Trading day schedule.
type TradingDay struct {
	// Days of week list with the same day schedule.
	DayOfWeek []DayOfWeek `protobuf:"varint,1,rep,name=day_of_week,json=dayOfWeek,enum=main.DayOfWeek" json:"day_of_week,omitempty"`
	// Trading day start offset in milliseconds from 00:00 UTC.
	StartOffset      *int64 `protobuf:"zigzag64,2,opt,name=start_offset,json=startOffset" json:"start_offset,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TradingDay) Reset()                    { *m = TradingDay{} }
func (m *TradingDay) String() string            { return proto.CompactTextString(m) }
func (*TradingDay) ProtoMessage()               {}
func (*TradingDay) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{57} }

func (m *TradingDay) GetDayOfWeek() []DayOfWeek {
	if m != nil {
		return m.DayOfWeek
	}
	return nil
}

func (m *TradingDay) GetStartOffset() int64 {
	if m != nil && m.StartOffset != nil {
		return *m.StartOffset
	}
	return 0
}

// Session times per day of week.
// All time offsets are in milliseconds from 00:00 UTC time of a specific date that corresponds to specific day of week.
// Offset values are optional and can be positive and negative
// (e.g. session can be completely 'pre-open' so only pre_open_offset and post_close_offset values are set).
// NOTE: Session times may not match exact exchange schedule especially if exchange have dynamic times
// (e.g. session starts after publishing a settlement, after underlying contract trade, etc.)
// or if exchange sends market data outside of session boundaries (e.g. late trades)
type SessionDay struct {
	// Days of week list with the same day schedule.
	DayOfWeek []DayOfWeek `protobuf:"varint,1,rep,name=day_of_week,json=dayOfWeek,enum=main.DayOfWeek" json:"day_of_week,omitempty"`
	// Session pre-open time offset.
	PreOpenOffset *int64 `protobuf:"zigzag64,2,opt,name=pre_open_offset,json=preOpenOffset" json:"pre_open_offset,omitempty"`
	// Session open time offset.
	OpenOffset *int64 `protobuf:"zigzag64,3,opt,name=open_offset,json=openOffset" json:"open_offset,omitempty"`
	// Session close time offset.
	CloseOffset *int64 `protobuf:"zigzag64,4,opt,name=close_offset,json=closeOffset" json:"close_offset,omitempty"`
	// Session post-close time offset.
	PostCloseOffset  *int64 `protobuf:"zigzag64,5,opt,name=post_close_offset,json=postCloseOffset" json:"post_close_offset,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SessionDay) Reset()                    { *m = SessionDay{} }
func (m *SessionDay) String() string            { return proto.CompactTextString(m) }
func (*SessionDay) ProtoMessage()               {}
func (*SessionDay) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{58} }

func (m *SessionDay) GetDayOfWeek() []DayOfWeek {
	if m != nil {
		return m.DayOfWeek
	}
	return nil
}

func (m *SessionDay) GetPreOpenOffset() int64 {
	if m != nil && m.PreOpenOffset != nil {
		return *m.PreOpenOffset
	}
	return 0
}

func (m *SessionDay) GetOpenOffset() int64 {
	if m != nil && m.OpenOffset != nil {
		return *m.OpenOffset
	}
	return 0
}

func (m *SessionDay) GetCloseOffset() int64 {
	if m != nil && m.CloseOffset != nil {
		return *m.CloseOffset
	}
	return 0
}

func (m *SessionDay) GetPostCloseOffset() int64 {
	if m != nil && m.PostCloseOffset != nil {
		return *m.PostCloseOffset
	}
	return 0
}

// Session holiday record.
type SessionHoliday struct {
	// Date of a holiday.
	HolidayDate *int64 `protobuf:"zigzag64,1,req,name=holiday_date,json=holidayDate" json:"holiday_date,omitempty"`
	// Name of a holiday.
	HolidayName      *string `protobuf:"bytes,2,req,name=holiday_name,json=holidayName" json:"holiday_name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SessionHoliday) Reset()                    { *m = SessionHoliday{} }
func (m *SessionHoliday) String() string            { return proto.CompactTextString(m) }
func (*SessionHoliday) ProtoMessage()               {}
func (*SessionHoliday) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{59} }

func (m *SessionHoliday) GetHolidayDate() int64 {
	if m != nil && m.HolidayDate != nil {
		return *m.HolidayDate
	}
	return 0
}

func (m *SessionHoliday) GetHolidayName() string {
	if m != nil && m.HolidayName != nil {
		return *m.HolidayName
	}
	return ""
}

// Request a list of symbols (options) by an underlying contract
type SymbolsByUnderlyingRequest struct {
	UnderlyingContractId *uint32 `protobuf:"varint,1,req,name=underlying_contract_id,json=underlyingContractId" json:"underlying_contract_id,omitempty"`
	XXX_unrecognized     []byte  `json:"-"`
}

func (m *SymbolsByUnderlyingRequest) Reset()                    { *m = SymbolsByUnderlyingRequest{} }
func (m *SymbolsByUnderlyingRequest) String() string            { return proto.CompactTextString(m) }
func (*SymbolsByUnderlyingRequest) ProtoMessage()               {}
func (*SymbolsByUnderlyingRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{60} }

func (m *SymbolsByUnderlyingRequest) GetUnderlyingContractId() uint32 {
	if m != nil && m.UnderlyingContractId != nil {
		return *m.UnderlyingContractId
	}
	return 0
}

// Report with a list of symbols.
// When the list is updated by a subscribtion
// (e.g. some option maturity is expired or a new one appears)
// the list includes only new or deleted symbols.
type SymbolsByUnderlyingReport struct {
	// List of related symbols (option maturities without strikes)
	Symbol           []*Symbol `protobuf:"bytes,1,rep,name=symbol" json:"symbol,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *SymbolsByUnderlyingReport) Reset()                    { *m = SymbolsByUnderlyingReport{} }
func (m *SymbolsByUnderlyingReport) String() string            { return proto.CompactTextString(m) }
func (*SymbolsByUnderlyingReport) ProtoMessage()               {}
func (*SymbolsByUnderlyingReport) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{61} }

func (m *SymbolsByUnderlyingReport) GetSymbol() []*Symbol {
	if m != nil {
		return m.Symbol
	}
	return nil
}

// Request a list of child symbols for a higher level symbol.
type ChildSymbolsRequest struct {
	// Id of the parent symbol.
	ParentSymbolId   *string `protobuf:"bytes,1,req,name=parent_symbol_id,json=parentSymbolId" json:"parent_symbol_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ChildSymbolsRequest) Reset()                    { *m = ChildSymbolsRequest{} }
func (m *ChildSymbolsRequest) String() string            { return proto.CompactTextString(m) }
func (*ChildSymbolsRequest) ProtoMessage()               {}
func (*ChildSymbolsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{62} }

func (m *ChildSymbolsRequest) GetParentSymbolId() string {
	if m != nil && m.ParentSymbolId != nil {
		return *m.ParentSymbolId
	}
	return ""
}

// Report with a list of child symbols.
type ChildSymbolsReport struct {
	// List of child symbols.
	Symbol           []*Symbol `protobuf:"bytes,1,rep,name=symbol" json:"symbol,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *ChildSymbolsReport) Reset()                    { *m = ChildSymbolsReport{} }
func (m *ChildSymbolsReport) String() string            { return proto.CompactTextString(m) }
func (*ChildSymbolsReport) ProtoMessage()               {}
func (*ChildSymbolsReport) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{63} }

func (m *ChildSymbolsReport) GetSymbol() []*Symbol {
	if m != nil {
		return m.Symbol
	}
	return nil
}

// Request at-the-money strike for the option maturity
type AtTheMoneyStrikeRequest struct {
	// Option maturity symbol Id representing the parent symbol for the option strike list of the same underlying and maturity period (see Symbol.Id).
	OptionMaturitySymbolId *string `protobuf:"bytes,1,req,name=option_maturity_symbol_id,json=optionMaturitySymbolId" json:"option_maturity_symbol_id,omitempty"`
	XXX_unrecognized       []byte  `json:"-"`
}

func (m *AtTheMoneyStrikeRequest) Reset()                    { *m = AtTheMoneyStrikeRequest{} }
func (m *AtTheMoneyStrikeRequest) String() string            { return proto.CompactTextString(m) }
func (*AtTheMoneyStrikeRequest) ProtoMessage()               {}
func (*AtTheMoneyStrikeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{64} }

func (m *AtTheMoneyStrikeRequest) GetOptionMaturitySymbolId() string {
	if m != nil && m.OptionMaturitySymbolId != nil {
		return *m.OptionMaturitySymbolId
	}
	return ""
}

// Report with at-the-money strikes.
type AtTheMoneyStrikeReport struct {
	// Option at-the-money strike.
	// It is omitted if at-the-money strike cannot be calculated at the moment (e.g. due to lack of real time data).
	Strike           *int32 `protobuf:"zigzag32,1,opt,name=strike" json:"strike,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *AtTheMoneyStrikeReport) Reset()                    { *m = AtTheMoneyStrikeReport{} }
func (m *AtTheMoneyStrikeReport) String() string            { return proto.CompactTextString(m) }
func (*AtTheMoneyStrikeReport) ProtoMessage()               {}
func (*AtTheMoneyStrikeReport) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{65} }

func (m *AtTheMoneyStrikeReport) GetStrike() int32 {
	if m != nil && m.Strike != nil {
		return *m.Strike
	}
	return 0
}

// Request for session open/close times.
type SessionTimeRangeRequest struct {
	// ID of a session information from contract meta-data.
	SessionInfoId *int32 `protobuf:"zigzag32,1,req,name=session_info_id,json=sessionInfoId" json:"session_info_id,omitempty"`
	// Exactly two of the next three fields have to be set:
	// UTC time of start of the time range to get information for.
	// Sessions with post-close time > from_utc_time are returned.
	FromUtcTime *int64 `protobuf:"zigzag64,2,opt,name=from_utc_time,json=fromUtcTime" json:"from_utc_time,omitempty"`
	// UTC time of end of the time range to get information for.
	// Sessions with pre-open time < to_utc_time are returned.
	ToUtcTime *int64 `protobuf:"zigzag64,3,opt,name=to_utc_time,json=toUtcTime" json:"to_utc_time,omitempty"`
	// Number of session timeranges to return.
	// If used with from_utc_time then it is the number of timeranges to return starting from that time.
	// If used with to_utc_time then it is the number of timeranges to return preceding that time.
	Count            *uint32 `protobuf:"varint,4,opt,name=count" json:"count,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SessionTimeRangeRequest) Reset()                    { *m = SessionTimeRangeRequest{} }
func (m *SessionTimeRangeRequest) String() string            { return proto.CompactTextString(m) }
func (*SessionTimeRangeRequest) ProtoMessage()               {}
func (*SessionTimeRangeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{66} }

func (m *SessionTimeRangeRequest) GetSessionInfoId() int32 {
	if m != nil && m.SessionInfoId != nil {
		return *m.SessionInfoId
	}
	return 0
}

func (m *SessionTimeRangeRequest) GetFromUtcTime() int64 {
	if m != nil && m.FromUtcTime != nil {
		return *m.FromUtcTime
	}
	return 0
}

func (m *SessionTimeRangeRequest) GetToUtcTime() int64 {
	if m != nil && m.ToUtcTime != nil {
		return *m.ToUtcTime
	}
	return 0
}

func (m *SessionTimeRangeRequest) GetCount() uint32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

// This may come in multiple chunks if many items are reported.
type SessionTimeRangeReport struct {
	// Session open/close times.
	SessionTimeRanges []*SessionTimeRange `protobuf:"bytes,1,rep,name=session_time_ranges,json=sessionTimeRanges" json:"session_time_ranges,omitempty"`
	// Request was done for the range that was too long, so it was truncated.
	Truncated        *bool  `protobuf:"varint,2,opt,name=truncated" json:"truncated,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SessionTimeRangeReport) Reset()                    { *m = SessionTimeRangeReport{} }
func (m *SessionTimeRangeReport) String() string            { return proto.CompactTextString(m) }
func (*SessionTimeRangeReport) ProtoMessage()               {}
func (*SessionTimeRangeReport) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{67} }

func (m *SessionTimeRangeReport) GetSessionTimeRanges() []*SessionTimeRange {
	if m != nil {
		return m.SessionTimeRanges
	}
	return nil
}

func (m *SessionTimeRangeReport) GetTruncated() bool {
	if m != nil && m.Truncated != nil {
		return *m.Truncated
	}
	return false
}

// Session open/close times and trading day date.
type SessionTimeRange struct {
	// UTC time of session pre-open.
	PreOpenUtcTime *int64 `protobuf:"zigzag64,1,req,name=pre_open_utc_time,json=preOpenUtcTime" json:"pre_open_utc_time,omitempty"`
	// UTC time of session open.
	OpenUtcTime *int64 `protobuf:"zigzag64,2,req,name=open_utc_time,json=openUtcTime" json:"open_utc_time,omitempty"`
	// UTC time of session close.
	CloseUtcTime *int64 `protobuf:"zigzag64,3,req,name=close_utc_time,json=closeUtcTime" json:"close_utc_time,omitempty"`
	// UTC time of session post close.
	PostCloseUtcTime *int64 `protobuf:"zigzag64,4,req,name=post_close_utc_time,json=postCloseUtcTime" json:"post_close_utc_time,omitempty"`
	// Trading date the session belongs to, local to exchange, time part is not used (set to 00:00).
	TradeDate *int64 `protobuf:"zigzag64,5,req,name=trade_date,json=tradeDate" json:"trade_date,omitempty"`
	// Session name.
	SessionName      *string `protobuf:"bytes,6,req,name=session_name,json=sessionName" json:"session_name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SessionTimeRange) Reset()                    { *m = SessionTimeRange{} }
func (m *SessionTimeRange) String() string            { return proto.CompactTextString(m) }
func (*SessionTimeRange) ProtoMessage()               {}
func (*SessionTimeRange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{68} }

func (m *SessionTimeRange) GetPreOpenUtcTime() int64 {
	if m != nil && m.PreOpenUtcTime != nil {
		return *m.PreOpenUtcTime
	}
	return 0
}

func (m *SessionTimeRange) GetOpenUtcTime() int64 {
	if m != nil && m.OpenUtcTime != nil {
		return *m.OpenUtcTime
	}
	return 0
}

func (m *SessionTimeRange) GetCloseUtcTime() int64 {
	if m != nil && m.CloseUtcTime != nil {
		return *m.CloseUtcTime
	}
	return 0
}

func (m *SessionTimeRange) GetPostCloseUtcTime() int64 {
	if m != nil && m.PostCloseUtcTime != nil {
		return *m.PostCloseUtcTime
	}
	return 0
}

func (m *SessionTimeRange) GetTradeDate() int64 {
	if m != nil && m.TradeDate != nil {
		return *m.TradeDate
	}
	return 0
}

func (m *SessionTimeRange) GetSessionName() string {
	if m != nil && m.SessionName != nil {
		return *m.SessionName
	}
	return ""
}

// Request for trading day open/close times.
type TradingDayTimeRangeRequest struct {
	// ID of a session information from contract meta-data.
	SessionInfoId *int32 `protobuf:"zigzag32,1,req,name=session_info_id,json=sessionInfoId" json:"session_info_id,omitempty"`
	// True if holidays should be included in the response.
	IncludeHolidays *bool `protobuf:"varint,2,opt,name=include_holidays,json=includeHolidays" json:"include_holidays,omitempty"`
	// Exactly two of the next three fields have to be set:
	// UTC time of start of the time range to get information for.
	// Trading days with end time > from_utc_time are returned.
	FromUtcTime *int64 `protobuf:"zigzag64,3,opt,name=from_utc_time,json=fromUtcTime" json:"from_utc_time,omitempty"`
	// UTC time of end of the time range to get information for.
	// Trading days with start time < to_utc_time are returned.
	ToUtcTime *int64 `protobuf:"zigzag64,4,opt,name=to_utc_time,json=toUtcTime" json:"to_utc_time,omitempty"`
	// Number of trading day timeranges to return.
	// If used with from_utc_time then it is the number of timeranges to return starting from that time.
	// If used with to_utc_time then it is the number of timeranges to return preceding that time.
	Count            *uint32 `protobuf:"varint,5,opt,name=count" json:"count,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TradingDayTimeRangeRequest) Reset()                    { *m = TradingDayTimeRangeRequest{} }
func (m *TradingDayTimeRangeRequest) String() string            { return proto.CompactTextString(m) }
func (*TradingDayTimeRangeRequest) ProtoMessage()               {}
func (*TradingDayTimeRangeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{69} }

func (m *TradingDayTimeRangeRequest) GetSessionInfoId() int32 {
	if m != nil && m.SessionInfoId != nil {
		return *m.SessionInfoId
	}
	return 0
}

func (m *TradingDayTimeRangeRequest) GetIncludeHolidays() bool {
	if m != nil && m.IncludeHolidays != nil {
		return *m.IncludeHolidays
	}
	return false
}

func (m *TradingDayTimeRangeRequest) GetFromUtcTime() int64 {
	if m != nil && m.FromUtcTime != nil {
		return *m.FromUtcTime
	}
	return 0
}

func (m *TradingDayTimeRangeRequest) GetToUtcTime() int64 {
	if m != nil && m.ToUtcTime != nil {
		return *m.ToUtcTime
	}
	return 0
}

func (m *TradingDayTimeRangeRequest) GetCount() uint32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

// This may come in multiple chunks if many items are reported.
type TradingDayTimeRangeReport struct {
	// Trading day start/end times.
	TradingDayTimeRanges []*TradingDayTimeRange `protobuf:"bytes,1,rep,name=trading_day_time_ranges,json=tradingDayTimeRanges" json:"trading_day_time_ranges,omitempty"`
	// Request was done for the range that was too long, so it was truncated.
	Truncated        *bool  `protobuf:"varint,2,opt,name=truncated" json:"truncated,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TradingDayTimeRangeReport) Reset()                    { *m = TradingDayTimeRangeReport{} }
func (m *TradingDayTimeRangeReport) String() string            { return proto.CompactTextString(m) }
func (*TradingDayTimeRangeReport) ProtoMessage()               {}
func (*TradingDayTimeRangeReport) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{70} }

func (m *TradingDayTimeRangeReport) GetTradingDayTimeRanges() []*TradingDayTimeRange {
	if m != nil {
		return m.TradingDayTimeRanges
	}
	return nil
}

func (m *TradingDayTimeRangeReport) GetTruncated() bool {
	if m != nil && m.Truncated != nil {
		return *m.Truncated
	}
	return false
}

// Trading day start/end times and date.
type TradingDayTimeRange struct {
	// Trading date, local to exchange, time part is not used (set to 00:00).
	TradeDate *int64 `protobuf:"zigzag64,1,req,name=trade_date,json=tradeDate" json:"trade_date,omitempty"`
	// The next two fields are not present for holidays,
	// because there’s no trading day for these dates, hence no start and end times.
	// UTC time of trading day start (first session pre-Open time).
	StartUtcTime *int64 `protobuf:"zigzag64,2,opt,name=start_utc_time,json=startUtcTime" json:"start_utc_time,omitempty"`
	// UTC time of trading day end (last session post-Close time).
	EndUtcTime       *int64 `protobuf:"zigzag64,3,opt,name=end_utc_time,json=endUtcTime" json:"end_utc_time,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TradingDayTimeRange) Reset()                    { *m = TradingDayTimeRange{} }
func (m *TradingDayTimeRange) String() string            { return proto.CompactTextString(m) }
func (*TradingDayTimeRange) ProtoMessage()               {}
func (*TradingDayTimeRange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{71} }

func (m *TradingDayTimeRange) GetTradeDate() int64 {
	if m != nil && m.TradeDate != nil {
		return *m.TradeDate
	}
	return 0
}

func (m *TradingDayTimeRange) GetStartUtcTime() int64 {
	if m != nil && m.StartUtcTime != nil {
		return *m.StartUtcTime
	}
	return 0
}

func (m *TradingDayTimeRange) GetEndUtcTime() int64 {
	if m != nil && m.EndUtcTime != nil {
		return *m.EndUtcTime
	}
	return 0
}

// Symbol structure
type Symbol struct {
	// Symbol Identifier.
	Id *string `protobuf:"bytes,1,req,name=Id" json:"Id,omitempty"`
	// Symbol readable name.
	Name *string `protobuf:"bytes,2,req,name=name" json:"name,omitempty"`
	// Symbol description.
	Description *string `protobuf:"bytes,3,req,name=description" json:"description,omitempty"`
	// CFI code (Classification of Financial Instruments, ISO 10962) if appropriate.
	CfiCode *string `protobuf:"bytes,4,opt,name=cfi_code,json=cfiCode" json:"cfi_code,omitempty"`
	// True if this symbol has child symbols.
	HasChildSymbols *bool `protobuf:"varint,5,opt,name=has_child_symbols,json=hasChildSymbols" json:"has_child_symbols,omitempty"`
	// Contract meta-data if a symbol is a specific contract
	ContractMetadata *ContractMetadata `protobuf:"bytes,6,opt,name=contract_metadata,json=contractMetadata" json:"contract_metadata,omitempty"`
	// Deleted flag is used in updates when the symbol is removed (e.g. expired)
	Deleted *bool `protobuf:"varint,7,opt,name=deleted" json:"deleted,omitempty"`
	// Last trading date for derivatives if applicable.
	// (local exchange date in time format, use date part only).
	LastTradingDate *int64 `protobuf:"zigzag64,8,opt,name=last_trading_date,json=lastTradingDate" json:"last_trading_date,omitempty"`
	// Month letter and 2-digit year identifying the expiration month of the symbol (or its underlying in case of options).
	// Doesn't depend on dialect.
	// Month and corresponding letter:
	// January   F
	// February  G
	// March     H
	// April     J
	// May       K
	// June      M
	// July      N
	// August    Q
	// September U
	// October   V
	// November  X
	// December  Z
	MaturityMonthYear *string `protobuf:"bytes,9,opt,name=maturity_month_year,json=maturityMonthYear" json:"maturity_month_year,omitempty"`
	// Name of a group of symbols that share the same properties (e.g. commodity name for futures and options)
	InstrumentGroupName *string `protobuf:"bytes,10,req,name=instrument_group_name,json=instrumentGroupName" json:"instrument_group_name,omitempty"`
	XXX_unrecognized    []byte  `json:"-"`
}

func (m *Symbol) Reset()                    { *m = Symbol{} }
func (m *Symbol) String() string            { return proto.CompactTextString(m) }
func (*Symbol) ProtoMessage()               {}
func (*Symbol) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{72} }

func (m *Symbol) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *Symbol) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Symbol) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *Symbol) GetCfiCode() string {
	if m != nil && m.CfiCode != nil {
		return *m.CfiCode
	}
	return ""
}

func (m *Symbol) GetHasChildSymbols() bool {
	if m != nil && m.HasChildSymbols != nil {
		return *m.HasChildSymbols
	}
	return false
}

func (m *Symbol) GetContractMetadata() *ContractMetadata {
	if m != nil {
		return m.ContractMetadata
	}
	return nil
}

func (m *Symbol) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

func (m *Symbol) GetLastTradingDate() int64 {
	if m != nil && m.LastTradingDate != nil {
		return *m.LastTradingDate
	}
	return 0
}

func (m *Symbol) GetMaturityMonthYear() string {
	if m != nil && m.MaturityMonthYear != nil {
		return *m.MaturityMonthYear
	}
	return ""
}

func (m *Symbol) GetInstrumentGroupName() string {
	if m != nil && m.InstrumentGroupName != nil {
		return *m.InstrumentGroupName
	}
	return ""
}

// Request to define a strategy as a contract
type StrategyDefinitionRequest struct {
	// Strategy to define.
	StrategyDefinition *StrategyDefinition `protobuf:"bytes,1,req,name=strategy_definition,json=strategyDefinition" json:"strategy_definition,omitempty"`
	XXX_unrecognized   []byte              `json:"-"`
}

func (m *StrategyDefinitionRequest) Reset()                    { *m = StrategyDefinitionRequest{} }
func (m *StrategyDefinitionRequest) String() string            { return proto.CompactTextString(m) }
func (*StrategyDefinitionRequest) ProtoMessage()               {}
func (*StrategyDefinitionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{73} }

func (m *StrategyDefinitionRequest) GetStrategyDefinition() *StrategyDefinition {
	if m != nil {
		return m.StrategyDefinition
	}
	return nil
}

// Report of the contract metadata assigned to the strategy.
type StrategyDefinitionReport struct {
	// Assigned strategy metadata.
	ContractMetadata *ContractMetadata `protobuf:"bytes,1,req,name=contract_metadata,json=contractMetadata" json:"contract_metadata,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *StrategyDefinitionReport) Reset()                    { *m = StrategyDefinitionReport{} }
func (m *StrategyDefinitionReport) String() string            { return proto.CompactTextString(m) }
func (*StrategyDefinitionReport) ProtoMessage()               {}
func (*StrategyDefinitionReport) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{74} }

func (m *StrategyDefinitionReport) GetContractMetadata() *ContractMetadata {
	if m != nil {
		return m.ContractMetadata
	}
	return nil
}

// Subscription to trade routing data and notifications about trading information updates.
// Client can be subscribed to several publications.
// If some Username is subscribed by several publications then client will receive a separate snapshot per subscription
// but one real time update with a list of subscriptions.
type TradeSubscription struct {
	// ID of a subscription that should be unique enough to match responses and updates with corresponding requests.
	Id *uint32 `protobuf:"varint,1,req,name=Id" json:"Id,omitempty"`
	// This field is associated with SubscriptionScope enum type.
	SubscriptionScope []uint32 `protobuf:"varint,2,rep,name=subscription_scope,json=subscriptionScope" json:"subscription_scope,omitempty"`
	// This field is associated with PublicationType enum type.
	PublicationType *uint32 `protobuf:"varint,3,opt,name=publication_type,json=publicationType" json:"publication_type,omitempty"`
	// Account ID when publicationType = ACCOUNT.
	AccountId *uint32 `protobuf:"varint,4,opt,name=account_id,json=accountId" json:"account_id,omitempty"`
	// Sales series number when publicationType = SALES_SERIES.
	// Note: sales_series_number might be not enough to find specific sales series,
	// so brokerage_id is needed to be specified as well.
	SalesSeriesNumber *string `protobuf:"bytes,5,opt,name=sales_series_number,json=salesSeriesNumber" json:"sales_series_number,omitempty"`
	// Brokerage ID when publicationType = BROKERAGE or SALES_SERIES.
	BrokerageId *uint32 `protobuf:"varint,6,opt,name=brokerage_id,json=brokerageId" json:"brokerage_id,omitempty"`
	// True to subscribe, false to unsubscribe (only Id value is used to unsubscribe).
	Subscribe *bool `protobuf:"varint,7,req,name=subscribe" json:"subscribe,omitempty"`
	// Optionally limit request to receive information about orders that were updated/ added after specified server related time (inclusive).
	// It is used to reduce amount of information necessary to send after re-connection.
	// Client should set this time equal to the last received order Status time ('status_utc_time' field) in UTC to avoid gaps and
	// be ready for duplicates that have to be detected by corresponding IDs.
	LastOrderUpdateUtcTime *int64 `protobuf:"zigzag64,8,opt,name=last_order_update_utc_time,json=lastOrderUpdateUtcTime" json:"last_order_update_utc_time,omitempty"`
	// True means sending only real time data and skip sending an initial orders snapshot, send initial snapshot otherwise.
	// NOTE: do not set this attribute after restoring session since some events might be missed to be delivered,
	// use last_order_update_utc_time instead.
	SkipOrdersSnapshot *bool `protobuf:"varint,9,opt,name=skip_orders_snapshot,json=skipOrdersSnapshot" json:"skip_orders_snapshot,omitempty"`
	// True means sending only FCM confirmed positions and their updates (if subscribed)
	// without matching with current day fills, send matched net positions otherwise.
	ConfirmedPositionsOnly *bool `protobuf:"varint,10,opt,name=confirmed_positions_only,json=confirmedPositionsOnly" json:"confirmed_positions_only,omitempty"`
	// This field is associated with MatchingAlgorithm enum type.
	// FIFO is used if omitted.
	MatchingAlgorithm *uint32 `protobuf:"varint,11,opt,name=matching_algorithm,json=matchingAlgorithm" json:"matching_algorithm,omitempty"`
	// If true or omitted then intraday trades are matched first and then intraday leftover is matched against previous close positions.
	// If false then previous day open positions and intraday fills are matched in a single pass.
	MatchIntradayFirst *bool `protobuf:"varint,12,opt,name=match_intraday_first,json=matchIntradayFirst" json:"match_intraday_first,omitempty"`
	// This field is associated with MatchingAlgorithm enum type.
	// Historical positions Matching algorithm. The same as matching_algorithm if omitted.
	// It is ignored if match_intraday_first is false.
	HistoricalMatchingAlgorithm *uint32 `protobuf:"varint,13,opt,name=historical_matching_algorithm,json=historicalMatchingAlgorithm" json:"historical_matching_algorithm,omitempty"`
	XXX_unrecognized            []byte  `json:"-"`
}

func (m *TradeSubscription) Reset()                    { *m = TradeSubscription{} }
func (m *TradeSubscription) String() string            { return proto.CompactTextString(m) }
func (*TradeSubscription) ProtoMessage()               {}
func (*TradeSubscription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{75} }

func (m *TradeSubscription) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *TradeSubscription) GetSubscriptionScope() []uint32 {
	if m != nil {
		return m.SubscriptionScope
	}
	return nil
}

func (m *TradeSubscription) GetPublicationType() uint32 {
	if m != nil && m.PublicationType != nil {
		return *m.PublicationType
	}
	return 0
}

func (m *TradeSubscription) GetAccountId() uint32 {
	if m != nil && m.AccountId != nil {
		return *m.AccountId
	}
	return 0
}

func (m *TradeSubscription) GetSalesSeriesNumber() string {
	if m != nil && m.SalesSeriesNumber != nil {
		return *m.SalesSeriesNumber
	}
	return ""
}

func (m *TradeSubscription) GetBrokerageId() uint32 {
	if m != nil && m.BrokerageId != nil {
		return *m.BrokerageId
	}
	return 0
}

func (m *TradeSubscription) GetSubscribe() bool {
	if m != nil && m.Subscribe != nil {
		return *m.Subscribe
	}
	return false
}

func (m *TradeSubscription) GetLastOrderUpdateUtcTime() int64 {
	if m != nil && m.LastOrderUpdateUtcTime != nil {
		return *m.LastOrderUpdateUtcTime
	}
	return 0
}

func (m *TradeSubscription) GetSkipOrdersSnapshot() bool {
	if m != nil && m.SkipOrdersSnapshot != nil {
		return *m.SkipOrdersSnapshot
	}
	return false
}

func (m *TradeSubscription) GetConfirmedPositionsOnly() bool {
	if m != nil && m.ConfirmedPositionsOnly != nil {
		return *m.ConfirmedPositionsOnly
	}
	return false
}

func (m *TradeSubscription) GetMatchingAlgorithm() uint32 {
	if m != nil && m.MatchingAlgorithm != nil {
		return *m.MatchingAlgorithm
	}
	return 0
}

func (m *TradeSubscription) GetMatchIntradayFirst() bool {
	if m != nil && m.MatchIntradayFirst != nil {
		return *m.MatchIntradayFirst
	}
	return false
}

func (m *TradeSubscription) GetHistoricalMatchingAlgorithm() uint32 {
	if m != nil && m.HistoricalMatchingAlgorithm != nil {
		return *m.HistoricalMatchingAlgorithm
	}
	return 0
}

// Server Status for a trade subscription.
// It is sent before or along with a snapshot of initial Status information.
type TradeSubscriptionStatus struct {
	// Subscription Id this result is sent for.
	Id *uint32 `protobuf:"varint,1,req,name=Id" json:"Id,omitempty"`
	// Subscription result.
	// This field is associated with StatusCode enum type.
	StatusCode *uint32 `protobuf:"varint,2,req,name=status_code,json=statusCode" json:"status_code,omitempty"`
	// Optional details.
	TextMessage      *string `protobuf:"bytes,3,opt,name=text_message,json=textMessage" json:"text_message,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TradeSubscriptionStatus) Reset()                    { *m = TradeSubscriptionStatus{} }
func (m *TradeSubscriptionStatus) String() string            { return proto.CompactTextString(m) }
func (*TradeSubscriptionStatus) ProtoMessage()               {}
func (*TradeSubscriptionStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{76} }

func (m *TradeSubscriptionStatus) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *TradeSubscriptionStatus) GetStatusCode() uint32 {
	if m != nil && m.StatusCode != nil {
		return *m.StatusCode
	}
	return 0
}

func (m *TradeSubscriptionStatus) GetTextMessage() string {
	if m != nil && m.TextMessage != nil {
		return *m.TextMessage
	}
	return ""
}

// Indicator that a snapshot of requested information is delivered and corresponding data is complete.
type TradeSnapshotCompletion struct {
	// ID of a corresponding trade subscription.
	SubscriptionId *uint32 `protobuf:"varint,1,req,name=subscription_id,json=subscriptionId" json:"subscription_id,omitempty"`
	// List of subscription scopes whose snapshots are completed.
	// Completion message for one scope is sent only once but they can be combined
	// (e.g. one completion message might come for ORDERS and another one later for POSITIONS and COLLATERAL).
	// This field is associated with TradeSubscription.SubscriptionScope enum type.
	SubscriptionScope []uint32 `protobuf:"varint,2,rep,name=subscription_scope,json=subscriptionScope" json:"subscription_scope,omitempty"`
	XXX_unrecognized  []byte   `json:"-"`
}

func (m *TradeSnapshotCompletion) Reset()                    { *m = TradeSnapshotCompletion{} }
func (m *TradeSnapshotCompletion) String() string            { return proto.CompactTextString(m) }
func (*TradeSnapshotCompletion) ProtoMessage()               {}
func (*TradeSnapshotCompletion) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{77} }

func (m *TradeSnapshotCompletion) GetSubscriptionId() uint32 {
	if m != nil && m.SubscriptionId != nil {
		return *m.SubscriptionId
	}
	return 0
}

func (m *TradeSnapshotCompletion) GetSubscriptionScope() []uint32 {
	if m != nil {
		return m.SubscriptionScope
	}
	return nil
}

// One of the order related requests. There must be only one optional order submessage specified per request.
// E.g NewOrder, but not NewOrder and CancelOrder.
type OrderRequest struct {
	// ID of a request that should be unique enough to match with possible OrderRequestReject.
	RequestId *uint32 `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	// New order request (place order).
	NewOrder *NewOrder `protobuf:"bytes,2,opt,name=new_order,json=newOrder" json:"new_order,omitempty"`
	// Modify order request.
	ModifyOrder *ModifyOrder `protobuf:"bytes,3,opt,name=modify_order,json=modifyOrder" json:"modify_order,omitempty"`
	// Cancel order request.
	CancelOrder *CancelOrder `protobuf:"bytes,4,opt,name=cancel_order,json=cancelOrder" json:"cancel_order,omitempty"`
	// Suspend (park) order.
	SuspendOrder *SuspendOrder `protobuf:"bytes,10,opt,name=suspend_order,json=suspendOrder" json:"suspend_order,omitempty"`
	// Activate suspended (parked) order.
	ActivateOrder *ActivateOrder `protobuf:"bytes,5,opt,name=activate_order,json=activateOrder" json:"activate_order,omitempty"`
	// Modify order's user attributes.
	ModifyUserAttributes *ModifyUserAttributes `protobuf:"bytes,6,opt,name=modify_user_attributes,json=modifyUserAttributes" json:"modify_user_attributes,omitempty"`
	// New compound order request (place compound order).
	NewCompoundOrder *NewCompoundOrder `protobuf:"bytes,8,opt,name=new_compound_order,json=newCompoundOrder" json:"new_compound_order,omitempty"`
	// Synthetic hangup liquidation with a MKT order.
	SyntheticLiquidate *SyntheticLiquidate `protobuf:"bytes,11,opt,name=synthetic_liquidate,json=syntheticLiquidate" json:"synthetic_liquidate,omitempty"`
	// Synthetic hangup liquidation with a LMT order.
	SyntheticScratch *SyntheticScratch `protobuf:"bytes,12,opt,name=synthetic_scratch,json=syntheticScratch" json:"synthetic_scratch,omitempty"`
	// Modify an order to get an immediate fill.
	GoMarket *GoMarket `protobuf:"bytes,13,opt,name=go_market,json=goMarket" json:"go_market,omitempty"`
	// Username of the user on whose behalf the order request is being sent.
	OnBehalfOfUser *string `protobuf:"bytes,7,opt,name=on_behalf_of_user,json=onBehalfOfUser" json:"on_behalf_of_user,omitempty"`
	// Regulatory Algorithm ID for client algorithm associated with this order, if any.
	// This field is applicable only for exchanges that use it, e.g. Eurex.
	// TransactionStatus message echoes back the value from the latest order request
	ClientRegulatoryAlgorithmId *uint32 `protobuf:"varint,9,opt,name=client_regulatory_algorithm_id,json=clientRegulatoryAlgorithmId" json:"client_regulatory_algorithm_id,omitempty"`
	XXX_unrecognized            []byte  `json:"-"`
}

func (m *OrderRequest) Reset()                    { *m = OrderRequest{} }
func (m *OrderRequest) String() string            { return proto.CompactTextString(m) }
func (*OrderRequest) ProtoMessage()               {}
func (*OrderRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{78} }

func (m *OrderRequest) GetRequestId() uint32 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *OrderRequest) GetNewOrder() *NewOrder {
	if m != nil {
		return m.NewOrder
	}
	return nil
}

func (m *OrderRequest) GetModifyOrder() *ModifyOrder {
	if m != nil {
		return m.ModifyOrder
	}
	return nil
}

func (m *OrderRequest) GetCancelOrder() *CancelOrder {
	if m != nil {
		return m.CancelOrder
	}
	return nil
}

func (m *OrderRequest) GetSuspendOrder() *SuspendOrder {
	if m != nil {
		return m.SuspendOrder
	}
	return nil
}

func (m *OrderRequest) GetActivateOrder() *ActivateOrder {
	if m != nil {
		return m.ActivateOrder
	}
	return nil
}

func (m *OrderRequest) GetModifyUserAttributes() *ModifyUserAttributes {
	if m != nil {
		return m.ModifyUserAttributes
	}
	return nil
}

func (m *OrderRequest) GetNewCompoundOrder() *NewCompoundOrder {
	if m != nil {
		return m.NewCompoundOrder
	}
	return nil
}

func (m *OrderRequest) GetSyntheticLiquidate() *SyntheticLiquidate {
	if m != nil {
		return m.SyntheticLiquidate
	}
	return nil
}

func (m *OrderRequest) GetSyntheticScratch() *SyntheticScratch {
	if m != nil {
		return m.SyntheticScratch
	}
	return nil
}

func (m *OrderRequest) GetGoMarket() *GoMarket {
	if m != nil {
		return m.GoMarket
	}
	return nil
}

func (m *OrderRequest) GetOnBehalfOfUser() string {
	if m != nil && m.OnBehalfOfUser != nil {
		return *m.OnBehalfOfUser
	}
	return ""
}

func (m *OrderRequest) GetClientRegulatoryAlgorithmId() uint32 {
	if m != nil && m.ClientRegulatoryAlgorithmId != nil {
		return *m.ClientRegulatoryAlgorithmId
	}
	return 0
}

// Low-level order request reject. It is sent only if direct order Status updates are impossible.
type OrderRequestReject struct {
	// ID of the order request this reject corresponds to.
	RequestId *uint32 `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	// Reject code. The list is provided separately.
	RejectCode *uint32 `protobuf:"varint,2,req,name=reject_code,json=rejectCode" json:"reject_code,omitempty"`
	// Optional reject details message.
	TextMessage      *string `protobuf:"bytes,3,opt,name=text_message,json=textMessage" json:"text_message,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *OrderRequestReject) Reset()                    { *m = OrderRequestReject{} }
func (m *OrderRequestReject) String() string            { return proto.CompactTextString(m) }
func (*OrderRequestReject) ProtoMessage()               {}
func (*OrderRequestReject) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{79} }

func (m *OrderRequestReject) GetRequestId() uint32 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *OrderRequestReject) GetRejectCode() uint32 {
	if m != nil && m.RejectCode != nil {
		return *m.RejectCode
	}
	return 0
}

func (m *OrderRequestReject) GetTextMessage() string {
	if m != nil && m.TextMessage != nil {
		return *m.TextMessage
	}
	return ""
}

// New order request.
type NewOrder struct {
	// Order to place.
	Order *Order `protobuf:"bytes,1,req,name=order" json:"order,omitempty"`
	// True if order should be suspended (parked) and wait a separate activate request or activation time.
	Suspend          *bool  `protobuf:"varint,2,opt,name=suspend" json:"suspend,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *NewOrder) Reset()                    { *m = NewOrder{} }
func (m *NewOrder) String() string            { return proto.CompactTextString(m) }
func (*NewOrder) ProtoMessage()               {}
func (*NewOrder) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{80} }

func (m *NewOrder) GetOrder() *Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *NewOrder) GetSuspend() bool {
	if m != nil && m.Suspend != nil {
		return *m.Suspend
	}
	return false
}

// Trade routing order. It is used as new order request and as a part of order Status updates.
type Order struct {
	// Id of an Username that is/ was used to place an order.
	AccountId *int32 `protobuf:"zigzag32,1,req,name=account_id,json=accountId" json:"account_id,omitempty"`
	// Client side time when an order was submitted (UTC).
	WhenUtcTime *int64 `protobuf:"zigzag64,2,req,name=when_utc_time,json=whenUtcTime" json:"when_utc_time,omitempty"`
	// Server side contract Id of the order (see ContractMetadata message).
	ContractId *uint32 `protobuf:"varint,3,req,name=contract_id,json=contractId" json:"contract_id,omitempty"`
	// Client order identifier, must be unique within a single trading day for day orders and across days for multi-day orders.
	// Maximum allowed length is 64 bytes.
	ClOrderId *string `protobuf:"bytes,4,req,name=cl_order_id,json=clOrderId" json:"cl_order_id,omitempty"`
	// Order type.
	// This field is associated with OrderType enum type.
	OrderType *uint32 `protobuf:"varint,5,req,name=order_type,json=orderType" json:"order_type,omitempty"`
	// List of applicable execution instructions.
	// This field is associated with ExecInstruction enum type.
	ExecInstruction []uint32 `protobuf:"varint,6,rep,name=exec_instruction,json=execInstruction" json:"exec_instruction,omitempty"`
	// Order duration.
	// This field is associated with Duration enum type.
	Duration *uint32 `protobuf:"varint,7,req,name=duration" json:"duration,omitempty"`
	// Date for GTD (local to exchange, date only value in time format) when the order should expire.
	GoodThruDate *int64 `protobuf:"zigzag64,8,opt,name=good_thru_date,json=goodThruDate" json:"good_thru_date,omitempty"`
	// Order side.
	// This field is associated with Side enum type.
	Side *uint32 `protobuf:"varint,9,req,name=side" json:"side,omitempty"`
	// Limit price of the order (required for Limit and Stop-limit orders).
	LimitPrice *int32 `protobuf:"zigzag32,10,opt,name=limit_price,json=limitPrice" json:"limit_price,omitempty"`
	// Stop price of the order (required for Stop and Stop-limit orders).
	StopPrice *int32 `protobuf:"zigzag32,11,opt,name=stop_price,json=stopPrice" json:"stop_price,omitempty"`
	// Total positive size of the order.
	Qty *uint32 `protobuf:"varint,12,req,name=qty" json:"qty,omitempty"`
	// Visible size of the order for Icebergs.
	VisibleQty *uint32 `protobuf:"varint,13,opt,name=visible_qty,json=visibleQty" json:"visible_qty,omitempty"`
	// Minimum visible positive size of the order
	// used for iceberg orders with 'random visible size',
	// must be < visible_qty.
	MinVisibleQty *uint32 `protobuf:"varint,14,opt,name=min_visible_qty,json=minVisibleQty" json:"min_visible_qty,omitempty"`
	// True if this is a manual order (order placed by the user direct action), automated otherwise.
	IsManual *bool `protobuf:"varint,15,req,name=is_manual,json=isManual" json:"is_manual,omitempty"`
	// True if order is used for closing/ reducing a position, opening/ increasing otherwise
	// (omit this field if there is no need to be explicit).
	IsClose *bool `protobuf:"varint,16,opt,name=is_close,json=isClose" json:"is_close,omitempty"`
	// True if the order is aggressive (Fixed Income specific order modifier).
	IsAggressive *bool `protobuf:"varint,17,opt,name=is_aggressive,json=isAggressive" json:"is_aggressive,omitempty"`
	// Maximum offset between market and limit prices for trail orders.
	TrailOffset *int32 `protobuf:"zigzag32,18,opt,name=trail_offset,json=trailOffset" json:"trail_offset,omitempty"`
	// Trailing limit peg to follow specific side of the market.
	// This field is associated with TrailingPeg enum type.
	TrailingPeg *uint32 `protobuf:"varint,19,opt,name=trailing_peg,json=trailingPeg" json:"trailing_peg,omitempty"`
	// Trigger quantity (threshold) as additional stop order activation condition.
	TriggerQty *uint32 `protobuf:"varint,20,opt,name=trigger_qty,json=triggerQty" json:"trigger_qty,omitempty"`
	// Time when order should be submitted to execution system as assigned by client (UTC).
	ActivationUtcTime *int64 `protobuf:"zigzag64,21,opt,name=activation_utc_time,json=activationUtcTime" json:"activation_utc_time,omitempty"`
	// Time when order should be suspended (parked) (UTC).
	SuspensionUtcTime *int64 `protobuf:"zigzag64,22,opt,name=suspension_utc_time,json=suspensionUtcTime" json:"suspension_utc_time,omitempty"`
	// User specific attributes.
	UserAttribute []*UserAttribute `protobuf:"bytes,23,rep,name=user_attribute,json=userAttribute" json:"user_attribute,omitempty"`
	// Date and time for GTT order (UTC) when the order should expire.
	GoodThruUtcTime *int64 `protobuf:"zigzag64,24,opt,name=good_thru_utc_time,json=goodThruUtcTime" json:"good_thru_utc_time,omitempty"`
	// Flag used by the client for marking the user attributes checked/unchecked.
	IsUserAttributeChecked *bool `protobuf:"varint,25,opt,name=is_user_attribute_checked,json=isUserAttributeChecked,def=1" json:"is_user_attribute_checked,omitempty"`
	// Synthtetic strategy trading parameters, applicable only if contract_id designates a synthetic strategy.
	// If the parameter is not applicable for the order the default value is used.
	StrategyTradingParameters *StrategyTradingParameters `protobuf:"bytes,26,opt,name=strategy_trading_parameters,json=strategyTradingParameters" json:"strategy_trading_parameters,omitempty"`
	XXX_unrecognized          []byte                     `json:"-"`
}

func (m *Order) Reset()                    { *m = Order{} }
func (m *Order) String() string            { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()               {}
func (*Order) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{81} }

const Default_Order_IsUserAttributeChecked bool = true

func (m *Order) GetAccountId() int32 {
	if m != nil && m.AccountId != nil {
		return *m.AccountId
	}
	return 0
}

func (m *Order) GetWhenUtcTime() int64 {
	if m != nil && m.WhenUtcTime != nil {
		return *m.WhenUtcTime
	}
	return 0
}

func (m *Order) GetContractId() uint32 {
	if m != nil && m.ContractId != nil {
		return *m.ContractId
	}
	return 0
}

func (m *Order) GetClOrderId() string {
	if m != nil && m.ClOrderId != nil {
		return *m.ClOrderId
	}
	return ""
}

func (m *Order) GetOrderType() uint32 {
	if m != nil && m.OrderType != nil {
		return *m.OrderType
	}
	return 0
}

func (m *Order) GetExecInstruction() []uint32 {
	if m != nil {
		return m.ExecInstruction
	}
	return nil
}

func (m *Order) GetDuration() uint32 {
	if m != nil && m.Duration != nil {
		return *m.Duration
	}
	return 0
}

func (m *Order) GetGoodThruDate() int64 {
	if m != nil && m.GoodThruDate != nil {
		return *m.GoodThruDate
	}
	return 0
}

func (m *Order) GetSide() uint32 {
	if m != nil && m.Side != nil {
		return *m.Side
	}
	return 0
}

func (m *Order) GetLimitPrice() int32 {
	if m != nil && m.LimitPrice != nil {
		return *m.LimitPrice
	}
	return 0
}

func (m *Order) GetStopPrice() int32 {
	if m != nil && m.StopPrice != nil {
		return *m.StopPrice
	}
	return 0
}

func (m *Order) GetQty() uint32 {
	if m != nil && m.Qty != nil {
		return *m.Qty
	}
	return 0
}

func (m *Order) GetVisibleQty() uint32 {
	if m != nil && m.VisibleQty != nil {
		return *m.VisibleQty
	}
	return 0
}

func (m *Order) GetMinVisibleQty() uint32 {
	if m != nil && m.MinVisibleQty != nil {
		return *m.MinVisibleQty
	}
	return 0
}

func (m *Order) GetIsManual() bool {
	if m != nil && m.IsManual != nil {
		return *m.IsManual
	}
	return false
}

func (m *Order) GetIsClose() bool {
	if m != nil && m.IsClose != nil {
		return *m.IsClose
	}
	return false
}

func (m *Order) GetIsAggressive() bool {
	if m != nil && m.IsAggressive != nil {
		return *m.IsAggressive
	}
	return false
}

func (m *Order) GetTrailOffset() int32 {
	if m != nil && m.TrailOffset != nil {
		return *m.TrailOffset
	}
	return 0
}

func (m *Order) GetTrailingPeg() uint32 {
	if m != nil && m.TrailingPeg != nil {
		return *m.TrailingPeg
	}
	return 0
}

func (m *Order) GetTriggerQty() uint32 {
	if m != nil && m.TriggerQty != nil {
		return *m.TriggerQty
	}
	return 0
}

func (m *Order) GetActivationUtcTime() int64 {
	if m != nil && m.ActivationUtcTime != nil {
		return *m.ActivationUtcTime
	}
	return 0
}

func (m *Order) GetSuspensionUtcTime() int64 {
	if m != nil && m.SuspensionUtcTime != nil {
		return *m.SuspensionUtcTime
	}
	return 0
}

func (m *Order) GetUserAttribute() []*UserAttribute {
	if m != nil {
		return m.UserAttribute
	}
	return nil
}

func (m *Order) GetGoodThruUtcTime() int64 {
	if m != nil && m.GoodThruUtcTime != nil {
		return *m.GoodThruUtcTime
	}
	return 0
}

func (m *Order) GetIsUserAttributeChecked() bool {
	if m != nil && m.IsUserAttributeChecked != nil {
		return *m.IsUserAttributeChecked
	}
	return Default_Order_IsUserAttributeChecked
}

func (m *Order) GetStrategyTradingParameters() *StrategyTradingParameters {
	if m != nil {
		return m.StrategyTradingParameters
	}
	return nil
}

// User defined attribute.
type UserAttribute struct {
	// Attribute name.
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// Attribute value (optional for modification if attribute is deleted).
	Value *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	// True if attribute has to be deleted during modify operation.
	Delete           *bool  `protobuf:"varint,3,opt,name=delete" json:"delete,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *UserAttribute) Reset()                    { *m = UserAttribute{} }
func (m *UserAttribute) String() string            { return proto.CompactTextString(m) }
func (*UserAttribute) ProtoMessage()               {}
func (*UserAttribute) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{82} }

func (m *UserAttribute) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *UserAttribute) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *UserAttribute) GetDelete() bool {
	if m != nil && m.Delete != nil {
		return *m.Delete
	}
	return false
}

// Synthetic strategy order's outright properties.
type SyntheticStrategyProperties struct {
	// Synthtetic strategy trading parameters.
	StrategyTradingParameters *StrategyTradingParameters `protobuf:"bytes,1,opt,name=strategy_trading_parameters,json=strategyTradingParameters" json:"strategy_trading_parameters,omitempty"`
	// Parent synthetic order Id that led to this order's (automatic) placement;
	// allows client to show the link to user.
	// Note: this is the original synthetic order's ID (OrderStatus.order_id), not affected by any modifications.
	OriginOrderId *string `protobuf:"bytes,2,opt,name=origin_order_id,json=originOrderId" json:"origin_order_id,omitempty"`
	// Id of the originally placed by trader root synthetic strategy order (The same as origin_order_id for the root immediate legs).
	RootOrderId *string `protobuf:"bytes,3,opt,name=root_order_id,json=rootOrderId" json:"root_order_id,omitempty"`
	// Node index of the synthetic order (specified by root_order_id);
	// allows client to associate this order with a particular node of the synthetic strategy (either a leg or a nested strategy).
	// LegDefinition.node_index or StrategyDefinition.node_index value.
	NodeIndex        *uint32 `protobuf:"varint,4,opt,name=node_index,json=nodeIndex" json:"node_index,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SyntheticStrategyProperties) Reset()                    { *m = SyntheticStrategyProperties{} }
func (m *SyntheticStrategyProperties) String() string            { return proto.CompactTextString(m) }
func (*SyntheticStrategyProperties) ProtoMessage()               {}
func (*SyntheticStrategyProperties) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{83} }

func (m *SyntheticStrategyProperties) GetStrategyTradingParameters() *StrategyTradingParameters {
	if m != nil {
		return m.StrategyTradingParameters
	}
	return nil
}

func (m *SyntheticStrategyProperties) GetOriginOrderId() string {
	if m != nil && m.OriginOrderId != nil {
		return *m.OriginOrderId
	}
	return ""
}

func (m *SyntheticStrategyProperties) GetRootOrderId() string {
	if m != nil && m.RootOrderId != nil {
		return *m.RootOrderId
	}
	return ""
}

func (m *SyntheticStrategyProperties) GetNodeIndex() uint32 {
	if m != nil && m.NodeIndex != nil {
		return *m.NodeIndex
	}
	return 0
}

// Modify order request, include only fields that are supposed to be modified.
type ModifyOrder struct {
	// Order Id assigned by server after last modification.
	OrderId *string `protobuf:"bytes,1,req,name=order_id,json=orderId" json:"order_id,omitempty"`
	// ID of the order's Username.
	AccountId *int32 `protobuf:"zigzag32,2,req,name=account_id,json=accountId" json:"account_id,omitempty"`
	// This client order ID of the order to modify.
	OrigClOrderId *string `protobuf:"bytes,3,req,name=orig_cl_order_id,json=origClOrderId" json:"orig_cl_order_id,omitempty"`
	// Client order ID of this modify request (will become new client order Id if modify is accepted).
	// Maximum allowed length is 64 bytes.
	ClOrderId *string `protobuf:"bytes,4,req,name=cl_order_id,json=clOrderId" json:"cl_order_id,omitempty"`
	// Client side time when a modify request was submitted (UTC).
	WhenUtcTime *int64 `protobuf:"zigzag64,5,req,name=when_utc_time,json=whenUtcTime" json:"when_utc_time,omitempty"`
	// Order size what the client wants the total size to become.
	Qty *uint32 `protobuf:"varint,6,opt,name=qty" json:"qty,omitempty"`
	// What the client wants the visible size to become.
	VisibleQty *uint32 `protobuf:"varint,7,opt,name=visible_qty,json=visibleQty" json:"visible_qty,omitempty"`
	// What the client wants the minimum visible size to become.
	MinVisibleQty *uint32 `protobuf:"varint,8,opt,name=min_visible_qty,json=minVisibleQty" json:"min_visible_qty,omitempty"`
	// What the client wants the limit price to become.
	LimitPrice *int32 `protobuf:"zigzag32,9,opt,name=limit_price,json=limitPrice" json:"limit_price,omitempty"`
	// What the client wants the stop price to become.
	StopPrice *int32 `protobuf:"zigzag32,10,opt,name=stop_price,json=stopPrice" json:"stop_price,omitempty"`
	// What the client wants the activation time to become (UTC).
	ActivationUtcTime *int64 `protobuf:"zigzag64,11,opt,name=activation_utc_time,json=activationUtcTime" json:"activation_utc_time,omitempty"`
	// True if activation time should be removed.
	RemoveActivationTime *bool `protobuf:"varint,12,opt,name=remove_activation_time,json=removeActivationTime" json:"remove_activation_time,omitempty"`
	// What the client wants the suspension time to become (UTC).
	SuspensionUtcTime *int64 `protobuf:"zigzag64,13,opt,name=suspension_utc_time,json=suspensionUtcTime" json:"suspension_utc_time,omitempty"`
	// True if suspension time should be removed.
	RemoveSuspensionUtcTime *bool `protobuf:"varint,14,opt,name=remove_suspension_utc_time,json=removeSuspensionUtcTime" json:"remove_suspension_utc_time,omitempty"`
	// What the client wants the order duration to become.
	// This field is associated with Order.Duration enum type.
	Duration *uint32 `protobuf:"varint,15,opt,name=duration" json:"duration,omitempty"`
	// What the client wants the order expiration date to become (see Order.good_thru_date).
	GoodThruDate *int64 `protobuf:"zigzag64,16,opt,name=good_thru_date,json=goodThruDate" json:"good_thru_date,omitempty"`
	// What the client wants the order expiration time to become (see Order.good_thru_utc_time).
	GoodThruUtcTime  *int64 `protobuf:"zigzag64,17,opt,name=good_thru_utc_time,json=goodThruUtcTime" json:"good_thru_utc_time,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ModifyOrder) Reset()                    { *m = ModifyOrder{} }
func (m *ModifyOrder) String() string            { return proto.CompactTextString(m) }
func (*ModifyOrder) ProtoMessage()               {}
func (*ModifyOrder) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{84} }

func (m *ModifyOrder) GetOrderId() string {
	if m != nil && m.OrderId != nil {
		return *m.OrderId
	}
	return ""
}

func (m *ModifyOrder) GetAccountId() int32 {
	if m != nil && m.AccountId != nil {
		return *m.AccountId
	}
	return 0
}

func (m *ModifyOrder) GetOrigClOrderId() string {
	if m != nil && m.OrigClOrderId != nil {
		return *m.OrigClOrderId
	}
	return ""
}

func (m *ModifyOrder) GetClOrderId() string {
	if m != nil && m.ClOrderId != nil {
		return *m.ClOrderId
	}
	return ""
}

func (m *ModifyOrder) GetWhenUtcTime() int64 {
	if m != nil && m.WhenUtcTime != nil {
		return *m.WhenUtcTime
	}
	return 0
}

func (m *ModifyOrder) GetQty() uint32 {
	if m != nil && m.Qty != nil {
		return *m.Qty
	}
	return 0
}

func (m *ModifyOrder) GetVisibleQty() uint32 {
	if m != nil && m.VisibleQty != nil {
		return *m.VisibleQty
	}
	return 0
}

func (m *ModifyOrder) GetMinVisibleQty() uint32 {
	if m != nil && m.MinVisibleQty != nil {
		return *m.MinVisibleQty
	}
	return 0
}

func (m *ModifyOrder) GetLimitPrice() int32 {
	if m != nil && m.LimitPrice != nil {
		return *m.LimitPrice
	}
	return 0
}

func (m *ModifyOrder) GetStopPrice() int32 {
	if m != nil && m.StopPrice != nil {
		return *m.StopPrice
	}
	return 0
}

func (m *ModifyOrder) GetActivationUtcTime() int64 {
	if m != nil && m.ActivationUtcTime != nil {
		return *m.ActivationUtcTime
	}
	return 0
}

func (m *ModifyOrder) GetRemoveActivationTime() bool {
	if m != nil && m.RemoveActivationTime != nil {
		return *m.RemoveActivationTime
	}
	return false
}

func (m *ModifyOrder) GetSuspensionUtcTime() int64 {
	if m != nil && m.SuspensionUtcTime != nil {
		return *m.SuspensionUtcTime
	}
	return 0
}

func (m *ModifyOrder) GetRemoveSuspensionUtcTime() bool {
	if m != nil && m.RemoveSuspensionUtcTime != nil {
		return *m.RemoveSuspensionUtcTime
	}
	return false
}

func (m *ModifyOrder) GetDuration() uint32 {
	if m != nil && m.Duration != nil {
		return *m.Duration
	}
	return 0
}

func (m *ModifyOrder) GetGoodThruDate() int64 {
	if m != nil && m.GoodThruDate != nil {
		return *m.GoodThruDate
	}
	return 0
}

func (m *ModifyOrder) GetGoodThruUtcTime() int64 {
	if m != nil && m.GoodThruUtcTime != nil {
		return *m.GoodThruUtcTime
	}
	return 0
}

// Cancel order request.
type CancelOrder struct {
	// Order Id assigned by server after last modification.
	OrderId *string `protobuf:"bytes,1,req,name=order_id,json=orderId" json:"order_id,omitempty"`
	// ID of the order's Username.
	AccountId *int32 `protobuf:"zigzag32,2,req,name=account_id,json=accountId" json:"account_id,omitempty"`
	// This client order ID of the order to cancel.
	OrigClOrderId *string `protobuf:"bytes,3,req,name=orig_cl_order_id,json=origClOrderId" json:"orig_cl_order_id,omitempty"`
	// Client order ID of this cancel request.
	// Maximum allowed length is 64 bytes.
	ClOrderId *string `protobuf:"bytes,4,req,name=cl_order_id,json=clOrderId" json:"cl_order_id,omitempty"`
	// Client side time when a modify request was submitted (UTC).
	WhenUtcTime      *int64 `protobuf:"zigzag64,5,req,name=when_utc_time,json=whenUtcTime" json:"when_utc_time,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CancelOrder) Reset()                    { *m = CancelOrder{} }
func (m *CancelOrder) String() string            { return proto.CompactTextString(m) }
func (*CancelOrder) ProtoMessage()               {}
func (*CancelOrder) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{85} }

func (m *CancelOrder) GetOrderId() string {
	if m != nil && m.OrderId != nil {
		return *m.OrderId
	}
	return ""
}

func (m *CancelOrder) GetAccountId() int32 {
	if m != nil && m.AccountId != nil {
		return *m.AccountId
	}
	return 0
}

func (m *CancelOrder) GetOrigClOrderId() string {
	if m != nil && m.OrigClOrderId != nil {
		return *m.OrigClOrderId
	}
	return ""
}

func (m *CancelOrder) GetClOrderId() string {
	if m != nil && m.ClOrderId != nil {
		return *m.ClOrderId
	}
	return ""
}

func (m *CancelOrder) GetWhenUtcTime() int64 {
	if m != nil && m.WhenUtcTime != nil {
		return *m.WhenUtcTime
	}
	return 0
}

// Activate suspended (parked) order request.
type ActivateOrder struct {
	// Order Id assigned by server after last modification.
	OrderId *string `protobuf:"bytes,1,req,name=order_id,json=orderId" json:"order_id,omitempty"`
	// ID of the order's Username.
	AccountId *int32 `protobuf:"zigzag32,2,req,name=account_id,json=accountId" json:"account_id,omitempty"`
	// This client order ID of the order to activate.
	OrigClOrderId *string `protobuf:"bytes,3,req,name=orig_cl_order_id,json=origClOrderId" json:"orig_cl_order_id,omitempty"`
	// Client order ID of this activation request (will become new client order Id if activation is accepted).
	// Maximum allowed length is 64 bytes.
	ClOrderId *string `protobuf:"bytes,4,req,name=cl_order_id,json=clOrderId" json:"cl_order_id,omitempty"`
	// Client side time when a modify request was submitted (UTC).
	WhenUtcTime      *int64 `protobuf:"zigzag64,5,req,name=when_utc_time,json=whenUtcTime" json:"when_utc_time,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ActivateOrder) Reset()                    { *m = ActivateOrder{} }
func (m *ActivateOrder) String() string            { return proto.CompactTextString(m) }
func (*ActivateOrder) ProtoMessage()               {}
func (*ActivateOrder) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{86} }

func (m *ActivateOrder) GetOrderId() string {
	if m != nil && m.OrderId != nil {
		return *m.OrderId
	}
	return ""
}

func (m *ActivateOrder) GetAccountId() int32 {
	if m != nil && m.AccountId != nil {
		return *m.AccountId
	}
	return 0
}

func (m *ActivateOrder) GetOrigClOrderId() string {
	if m != nil && m.OrigClOrderId != nil {
		return *m.OrigClOrderId
	}
	return ""
}

func (m *ActivateOrder) GetClOrderId() string {
	if m != nil && m.ClOrderId != nil {
		return *m.ClOrderId
	}
	return ""
}

func (m *ActivateOrder) GetWhenUtcTime() int64 {
	if m != nil && m.WhenUtcTime != nil {
		return *m.WhenUtcTime
	}
	return 0
}

// Modification of order's user attributes.
type ModifyUserAttributes struct {
	// ID of the order chain.
	ChainOrderId *string `protobuf:"bytes,1,req,name=chain_order_id,json=chainOrderId" json:"chain_order_id,omitempty"`
	// ID of the order's Username.
	AccountId *int32 `protobuf:"zigzag32,2,req,name=account_id,json=accountId" json:"account_id,omitempty"`
	// List of attributes to modify.
	UserAttribute []*UserAttribute `protobuf:"bytes,3,rep,name=user_attribute,json=userAttribute" json:"user_attribute,omitempty"`
	// Flag used by the client for marking the user attributes checked/unchecked.
	// Empty means to leave the flag the same as it was.
	IsChecked        *bool  `protobuf:"varint,4,opt,name=is_checked,json=isChecked" json:"is_checked,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ModifyUserAttributes) Reset()                    { *m = ModifyUserAttributes{} }
func (m *ModifyUserAttributes) String() string            { return proto.CompactTextString(m) }
func (*ModifyUserAttributes) ProtoMessage()               {}
func (*ModifyUserAttributes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{87} }

func (m *ModifyUserAttributes) GetChainOrderId() string {
	if m != nil && m.ChainOrderId != nil {
		return *m.ChainOrderId
	}
	return ""
}

func (m *ModifyUserAttributes) GetAccountId() int32 {
	if m != nil && m.AccountId != nil {
		return *m.AccountId
	}
	return 0
}

func (m *ModifyUserAttributes) GetUserAttribute() []*UserAttribute {
	if m != nil {
		return m.UserAttribute
	}
	return nil
}

func (m *ModifyUserAttributes) GetIsChecked() bool {
	if m != nil && m.IsChecked != nil {
		return *m.IsChecked
	}
	return false
}

// Placement of a compound order.
type NewCompoundOrder struct {
	// Compound order to place.
	CompoundOrder *CompoundOrder `protobuf:"bytes,1,req,name=compound_order,json=compoundOrder" json:"compound_order,omitempty"`
	// Indicates whether compound order execution shall happen on a partial fill (true or omitted)
	// or complete fill (false).
	PartialFillsHandling *bool  `protobuf:"varint,2,opt,name=partial_fills_handling,json=partialFillsHandling,def=1" json:"partial_fills_handling,omitempty"`
	XXX_unrecognized     []byte `json:"-"`
}

func (m *NewCompoundOrder) Reset()                    { *m = NewCompoundOrder{} }
func (m *NewCompoundOrder) String() string            { return proto.CompactTextString(m) }
func (*NewCompoundOrder) ProtoMessage()               {}
func (*NewCompoundOrder) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{88} }

const Default_NewCompoundOrder_PartialFillsHandling bool = true

func (m *NewCompoundOrder) GetCompoundOrder() *CompoundOrder {
	if m != nil {
		return m.CompoundOrder
	}
	return nil
}

func (m *NewCompoundOrder) GetPartialFillsHandling() bool {
	if m != nil && m.PartialFillsHandling != nil {
		return *m.PartialFillsHandling
	}
	return Default_NewCompoundOrder_PartialFillsHandling
}

// Compound order.
type CompoundOrder struct {
	// This field is associated with Type enum type.
	Type *uint32 `protobuf:"varint,1,req,name=type" json:"type,omitempty"`
	// ID of the compound order assigned by client.
	// Maximum allowed length is 64 bytes.
	ClCompoundId *string `protobuf:"bytes,2,req,name=cl_compound_id,json=clCompoundId" json:"cl_compound_id,omitempty"`
	// List of entires.
	CompoundOrderEntry []*CompoundOrderEntry `protobuf:"bytes,3,rep,name=compound_order_entry,json=compoundOrderEntry" json:"compound_order_entry,omitempty"`
	XXX_unrecognized   []byte                `json:"-"`
}

func (m *CompoundOrder) Reset()                    { *m = CompoundOrder{} }
func (m *CompoundOrder) String() string            { return proto.CompactTextString(m) }
func (*CompoundOrder) ProtoMessage()               {}
func (*CompoundOrder) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{89} }

func (m *CompoundOrder) GetType() uint32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *CompoundOrder) GetClCompoundId() string {
	if m != nil && m.ClCompoundId != nil {
		return *m.ClCompoundId
	}
	return ""
}

func (m *CompoundOrder) GetCompoundOrderEntry() []*CompoundOrderEntry {
	if m != nil {
		return m.CompoundOrderEntry
	}
	return nil
}

// Entry of a compound order. Only one of optional fields has to be specified.
type CompoundOrderEntry struct {
	// Regular order entry.
	Order *Order `protobuf:"bytes,1,opt,name=order" json:"order,omitempty"`
	// Sub-compound order entry.
	CompoundOrder    *CompoundOrder `protobuf:"bytes,2,opt,name=compound_order,json=compoundOrder" json:"compound_order,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *CompoundOrderEntry) Reset()                    { *m = CompoundOrderEntry{} }
func (m *CompoundOrderEntry) String() string            { return proto.CompactTextString(m) }
func (*CompoundOrderEntry) ProtoMessage()               {}
func (*CompoundOrderEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{90} }

func (m *CompoundOrderEntry) GetOrder() *Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *CompoundOrderEntry) GetCompoundOrder() *CompoundOrder {
	if m != nil {
		return m.CompoundOrder
	}
	return nil
}

// Suspend (park) order request.
type SuspendOrder struct {
	// Order Id assigned by server after last modification.
	OrderId *string `protobuf:"bytes,1,req,name=order_id,json=orderId" json:"order_id,omitempty"`
	// ID of the order's Username.
	AccountId *int32 `protobuf:"zigzag32,2,req,name=account_id,json=accountId" json:"account_id,omitempty"`
	// This client order ID of the order to suspend (park).
	OrigClOrderId *string `protobuf:"bytes,3,req,name=orig_cl_order_id,json=origClOrderId" json:"orig_cl_order_id,omitempty"`
	// Client order ID of this suspension request (will become new client order Id if suspension is accepted).
	// Maximum allowed length is 64 bytes.
	ClOrderId *string `protobuf:"bytes,4,req,name=cl_order_id,json=clOrderId" json:"cl_order_id,omitempty"`
	// Client side time when a modify request was submitted (UTC).
	WhenUtcTime *int64 `protobuf:"zigzag64,5,req,name=when_utc_time,json=whenUtcTime" json:"when_utc_time,omitempty"`
	// Time when the suspended (parked) order should automatically activate (UTC).
	// If not specified, order must be activated by ActivateOrder request
	ActivationUtcTime *int64 `protobuf:"zigzag64,6,opt,name=activation_utc_time,json=activationUtcTime" json:"activation_utc_time,omitempty"`
	XXX_unrecognized  []byte `json:"-"`
}

func (m *SuspendOrder) Reset()                    { *m = SuspendOrder{} }
func (m *SuspendOrder) String() string            { return proto.CompactTextString(m) }
func (*SuspendOrder) ProtoMessage()               {}
func (*SuspendOrder) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{91} }

func (m *SuspendOrder) GetOrderId() string {
	if m != nil && m.OrderId != nil {
		return *m.OrderId
	}
	return ""
}

func (m *SuspendOrder) GetAccountId() int32 {
	if m != nil && m.AccountId != nil {
		return *m.AccountId
	}
	return 0
}

func (m *SuspendOrder) GetOrigClOrderId() string {
	if m != nil && m.OrigClOrderId != nil {
		return *m.OrigClOrderId
	}
	return ""
}

func (m *SuspendOrder) GetClOrderId() string {
	if m != nil && m.ClOrderId != nil {
		return *m.ClOrderId
	}
	return ""
}

func (m *SuspendOrder) GetWhenUtcTime() int64 {
	if m != nil && m.WhenUtcTime != nil {
		return *m.WhenUtcTime
	}
	return 0
}

func (m *SuspendOrder) GetActivationUtcTime() int64 {
	if m != nil && m.ActivationUtcTime != nil {
		return *m.ActivationUtcTime
	}
	return 0
}

// Status of order.
type OrderStatus struct {
	// List of trade subscription IDs this Status is related to.
	SubscriptionId []uint32 `protobuf:"varint,1,rep,name=subscription_id,json=subscriptionId" json:"subscription_id,omitempty"`
	// True if this is a snapshot related message.
	// Since snapshot might be sent in several messages (including none), client should use TradeSnapshotCompletion message as
	// an indicator of complete snapshot delivery for a particular subscription.
	IsSnapshot *bool `protobuf:"varint,2,opt,name=is_snapshot,json=isSnapshot" json:"is_snapshot,omitempty"`
	// This field is associated with Status enum type.
	Status *uint32 `protobuf:"varint,3,req,name=Status" json:"Status,omitempty"`
	// Order ID assigned by server.
	// It is changed by server after each modify request acknowledgment.
	OrderId *string `protobuf:"bytes,4,req,name=order_id,json=orderId" json:"order_id,omitempty"`
	// Order ID assigned by server to originally placed order. It stays the same regardless of modification requests.
	ChainOrderId *string `protobuf:"bytes,5,req,name=chain_order_id,json=chainOrderId" json:"chain_order_id,omitempty"`
	// Order ID assigned by execution system (e.g. exchange).
	ExecOrderId *string `protobuf:"bytes,6,opt,name=exec_order_id,json=execOrderId" json:"exec_order_id,omitempty"`
	// Last order change time from server perspective (UTC).
	StatusUtcTime *int64 `protobuf:"zigzag64,7,req,name=status_utc_time,json=statusUtcTime" json:"status_utc_time,omitempty"`
	// Time when original order was submitted to the execution system by server (UTC).
	SubmissionUtcTime *int64 `protobuf:"zigzag64,8,req,name=submission_utc_time,json=submissionUtcTime" json:"submission_utc_time,omitempty"`
	// Filled quantity.
	FillQty *uint32 `protobuf:"varint,9,req,name=fill_qty,json=fillQty" json:"fill_qty,omitempty"`
	// Number of fill events.
	FillCnt *uint32 `protobuf:"varint,10,req,name=fill_cnt,json=fillCnt" json:"fill_cnt,omitempty"`
	// Average fill price.
	// NOTE: this price is aligned by a tick size so don't use it for OTE/UPL calculation but
	// use prices from individual TRADE elements.
	AvgFillPrice *int32 `protobuf:"zigzag32,11,req,name=avg_fill_price,json=avgFillPrice" json:"avg_fill_price,omitempty"`
	// Time when order should be submitted to execution system as assigned by server (UTC).
	ActiveAtUtcTime *int64 `protobuf:"zigzag64,12,opt,name=active_at_utc_time,json=activeAtUtcTime" json:"active_at_utc_time,omitempty"`
	// Remaining (unfilled) order quantity. It is not always equal
	// to order size minus filled size (for example, busted orders violate that).
	RemainingQty *uint32 `protobuf:"varint,13,req,name=remaining_qty,json=remainingQty" json:"remaining_qty,omitempty"`
	// order with updated attributes. server may not send it if order attributes remained the same since last update
	Order *Order `protobuf:"bytes,14,opt,name=order" json:"order,omitempty"`
	// List of [last] transactions. In case of initial snapshot (if last_orders_update_utc_time was not set in TradeSubscription)
	// all available transactions are sent. This list can be empty if this Status is sent to update order attributes only
	// (e.g. to update prices of trailing orders).
	TransactionStatus []*TransactionStatus `protobuf:"bytes,15,rep,name=transaction_status,json=transactionStatus" json:"transaction_status,omitempty"`
	// User who placed the order, or user on whose behalf the order was placed.
	EnteredByUser *string `protobuf:"bytes,16,req,name=entered_by_user,json=enteredByUser" json:"entered_by_user,omitempty"`
	// Statement date when this order was submitted.
	FirstStatementDate *int64 `protobuf:"zigzag64,17,req,name=first_statement_date,json=firstStatementDate" json:"first_statement_date,omitempty"`
	// Last statement date this order belongs to. It is set when order is cleaned by a statement report
	// so that order is not 'current' any longer.
	LastStatementDate *int64 `protobuf:"zigzag64,18,opt,name=last_statement_date,json=lastStatementDate" json:"last_statement_date,omitempty"`
	// Multiple OrderStatus and PositionStatus messages in a single ServerMsg can reference the same contract.
	// If the contract is unknown to the client before this ServerMsg, contract meta-data will be added in at least one of them.
	// If in your code you process orders first and positions second then during processing orders you may
	// encounter order with yet unknown contract_id.
	// In this case you should look for matching contract metadata in positions.
	// The opposite is also true: contract metadata for positions can be in order Status messages.
	ContractMetadata []*ContractMetadata `protobuf:"bytes,19,rep,name=contract_metadata,json=contractMetadata" json:"contract_metadata,omitempty"`
	// Id of an Username for this order Status.
	AccountId *int32 `protobuf:"zigzag32,20,req,name=account_id,json=accountId" json:"account_id,omitempty"`
	// If the order is part of a compound order then this field describe the structure of the compound.
	CompoundOrderStructure *CompoundOrderStructure `protobuf:"bytes,21,opt,name=compound_order_structure,json=compoundOrderStructure" json:"compound_order_structure,omitempty"`
	// The number of active (not resolved) hangs on this synthetic strategy order.
	HangCount *uint32 `protobuf:"varint,22,opt,name=hang_count,json=hangCount" json:"hang_count,omitempty"`
	// Synthetic order's outright properties
	StrategyProperties *SyntheticStrategyProperties `protobuf:"bytes,23,opt,name=strategy_properties,json=strategyProperties" json:"strategy_properties,omitempty"`
	XXX_unrecognized   []byte                       `json:"-"`
}

func (m *OrderStatus) Reset()                    { *m = OrderStatus{} }
func (m *OrderStatus) String() string            { return proto.CompactTextString(m) }
func (*OrderStatus) ProtoMessage()               {}
func (*OrderStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{92} }

func (m *OrderStatus) GetSubscriptionId() []uint32 {
	if m != nil {
		return m.SubscriptionId
	}
	return nil
}

func (m *OrderStatus) GetIsSnapshot() bool {
	if m != nil && m.IsSnapshot != nil {
		return *m.IsSnapshot
	}
	return false
}

func (m *OrderStatus) GetStatus() uint32 {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return 0
}

func (m *OrderStatus) GetOrderId() string {
	if m != nil && m.OrderId != nil {
		return *m.OrderId
	}
	return ""
}

func (m *OrderStatus) GetChainOrderId() string {
	if m != nil && m.ChainOrderId != nil {
		return *m.ChainOrderId
	}
	return ""
}

func (m *OrderStatus) GetExecOrderId() string {
	if m != nil && m.ExecOrderId != nil {
		return *m.ExecOrderId
	}
	return ""
}

func (m *OrderStatus) GetStatusUtcTime() int64 {
	if m != nil && m.StatusUtcTime != nil {
		return *m.StatusUtcTime
	}
	return 0
}

func (m *OrderStatus) GetSubmissionUtcTime() int64 {
	if m != nil && m.SubmissionUtcTime != nil {
		return *m.SubmissionUtcTime
	}
	return 0
}

func (m *OrderStatus) GetFillQty() uint32 {
	if m != nil && m.FillQty != nil {
		return *m.FillQty
	}
	return 0
}

func (m *OrderStatus) GetFillCnt() uint32 {
	if m != nil && m.FillCnt != nil {
		return *m.FillCnt
	}
	return 0
}

func (m *OrderStatus) GetAvgFillPrice() int32 {
	if m != nil && m.AvgFillPrice != nil {
		return *m.AvgFillPrice
	}
	return 0
}

func (m *OrderStatus) GetActiveAtUtcTime() int64 {
	if m != nil && m.ActiveAtUtcTime != nil {
		return *m.ActiveAtUtcTime
	}
	return 0
}

func (m *OrderStatus) GetRemainingQty() uint32 {
	if m != nil && m.RemainingQty != nil {
		return *m.RemainingQty
	}
	return 0
}

func (m *OrderStatus) GetOrder() *Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *OrderStatus) GetTransactionStatus() []*TransactionStatus {
	if m != nil {
		return m.TransactionStatus
	}
	return nil
}

func (m *OrderStatus) GetEnteredByUser() string {
	if m != nil && m.EnteredByUser != nil {
		return *m.EnteredByUser
	}
	return ""
}

func (m *OrderStatus) GetFirstStatementDate() int64 {
	if m != nil && m.FirstStatementDate != nil {
		return *m.FirstStatementDate
	}
	return 0
}

func (m *OrderStatus) GetLastStatementDate() int64 {
	if m != nil && m.LastStatementDate != nil {
		return *m.LastStatementDate
	}
	return 0
}

func (m *OrderStatus) GetContractMetadata() []*ContractMetadata {
	if m != nil {
		return m.ContractMetadata
	}
	return nil
}

func (m *OrderStatus) GetAccountId() int32 {
	if m != nil && m.AccountId != nil {
		return *m.AccountId
	}
	return 0
}

func (m *OrderStatus) GetCompoundOrderStructure() *CompoundOrderStructure {
	if m != nil {
		return m.CompoundOrderStructure
	}
	return nil
}

func (m *OrderStatus) GetHangCount() uint32 {
	if m != nil && m.HangCount != nil {
		return *m.HangCount
	}
	return 0
}

func (m *OrderStatus) GetStrategyProperties() *SyntheticStrategyProperties {
	if m != nil {
		return m.StrategyProperties
	}
	return nil
}

// Status of a specific transaction.
// All attributes are at the transaction moment.
type TransactionStatus struct {
	// This field is associated with Status enum type.
	Status *uint32 `protobuf:"varint,1,req,name=Status" json:"Status,omitempty"`
	// Order transaction identifier, unique within order chain.
	TransId *uint64 `protobuf:"varint,2,req,name=trans_id,json=transId" json:"trans_id,omitempty"`
	// Transaction time assigned by server (UTC).
	TransUtcTime *int64 `protobuf:"zigzag64,3,req,name=trans_utc_time,json=transUtcTime" json:"trans_utc_time,omitempty"`
	// Reference transaction ID to the previous fill transaction for a bust, cancel or correction.
	RefTransId *uint64 `protobuf:"varint,4,opt,name=ref_trans_id,json=refTransId" json:"ref_trans_id,omitempty"`
	// If order is modified, this client order ID of the order before modification.
	OrigClOrderId *string `protobuf:"bytes,5,opt,name=orig_cl_order_id,json=origClOrderId" json:"orig_cl_order_id,omitempty"`
	// Client order ID of the order at the transaction moment.
	ClOrderId *string `protobuf:"bytes,6,req,name=cl_order_id,json=clOrderId" json:"cl_order_id,omitempty"`
	// Filled quantity for fill transactions or updated quantity for fill correction.
	FillQty *uint32 `protobuf:"varint,7,opt,name=fill_qty,json=fillQty" json:"fill_qty,omitempty"`
	// Fill price for fill transactions or updated price for fill correction.
	FillPrice *int32 `protobuf:"zigzag32,8,opt,name=fill_price,json=fillPrice" json:"fill_price,omitempty"`
	// List of specific per leg trades (more than one for strategies).
	Trade []*Trade `protobuf:"bytes,9,rep,name=trade" json:"trade,omitempty"`
	// List of leg order fills that contribute to a synthetic strategy order fill.
	// Present if the transaction is of type FILL or FILL_CORRECT and this order is a synthetic strategy order.
	// Mutually exclusive with 'trade' attribute.
	StrategyLegFills []*StrategyLegFill `protobuf:"bytes,38,rep,name=strategy_leg_fills,json=strategyLegFills" json:"strategy_leg_fills,omitempty"`
	// Details of the hang
	SyntheticHang *SyntheticHang `protobuf:"bytes,39,opt,name=synthetic_hang,json=syntheticHang" json:"synthetic_hang,omitempty"`
	// If order is modified, this is the previous order size.
	PrevOrderQty *uint32 `protobuf:"varint,10,opt,name=prev_order_qty,json=prevOrderQty" json:"prev_order_qty,omitempty"`
	// If order is modified, this is the updated order size.
	OrderQty *uint32 `protobuf:"varint,11,opt,name=order_qty,json=orderQty" json:"order_qty,omitempty"`
	// If order is modified, this is the previous order limit price.
	PrevLimitPrice *int32 `protobuf:"zigzag32,12,opt,name=prev_limit_price,json=prevLimitPrice" json:"prev_limit_price,omitempty"`
	// If order is modified, this is the updated order limit price.
	LimitPrice *int32 `protobuf:"zigzag32,13,opt,name=limit_price,json=limitPrice" json:"limit_price,omitempty"`
	// If order is modified, this is the previous order stop price.
	PrevStopPrice *int32 `protobuf:"zigzag32,14,opt,name=prev_stop_price,json=prevStopPrice" json:"prev_stop_price,omitempty"`
	// If order is modified, this is the updated order stop price.
	StopPrice *int32 `protobuf:"zigzag32,15,opt,name=stop_price,json=stopPrice" json:"stop_price,omitempty"`
	// If order is modified, this is the previous visible order size.
	PrevVisibleQty *uint32 `protobuf:"varint,16,opt,name=prev_visible_qty,json=prevVisibleQty" json:"prev_visible_qty,omitempty"`
	// If order is modified, this is the updated visible order size.
	VisibleQty *uint32 `protobuf:"varint,17,opt,name=visible_qty,json=visibleQty" json:"visible_qty,omitempty"`
	// If order is modified, this is the previous min visible order size.
	PrevMinVisibleQty *uint32 `protobuf:"varint,18,opt,name=prev_min_visible_qty,json=prevMinVisibleQty" json:"prev_min_visible_qty,omitempty"`
	// If order is modified, this is the updated min visible order size.
	MinVisibleQty *uint32 `protobuf:"varint,19,opt,name=min_visible_qty,json=minVisibleQty" json:"min_visible_qty,omitempty"`
	// If fill is modified, the previous size is reported here.
	PrevFillQty *uint32 `protobuf:"varint,20,opt,name=prev_fill_qty,json=prevFillQty" json:"prev_fill_qty,omitempty"`
	// If fill is modified, the previous price is reported here.
	PrevFillPrice *int32 `protobuf:"zigzag32,21,opt,name=prev_fill_price,json=prevFillPrice" json:"prev_fill_price,omitempty"`
	// If order is modified, this is the previous order type.
	// This field is associated with Order.OrderType enum type.
	PrevOrderType *uint32 `protobuf:"varint,22,opt,name=prev_order_type,json=prevOrderType" json:"prev_order_type,omitempty"`
	// If order is modified, this is the updated order type.
	// This field is associated with Order.OrderType enum type.
	OrderType *uint32 `protobuf:"varint,23,opt,name=order_type,json=orderType" json:"order_type,omitempty"`
	// If order is modified, these are the previous exec instructions.
	// This field is associated with Order.ExecInstruction enum type.
	PrevExecInstruction []uint32 `protobuf:"varint,24,rep,name=prev_exec_instruction,json=prevExecInstruction" json:"prev_exec_instruction,omitempty"`
	// If order is modified, these are the updated exec instructions.
	// This field is associated with Order.ExecInstruction enum type.
	ExecInstruction []uint32 `protobuf:"varint,25,rep,name=exec_instruction,json=execInstruction" json:"exec_instruction,omitempty"`
	// If order is modified, this is the previous duration.
	// This field is associated with Order.Duration enum type.
	PrevDuration *uint32 `protobuf:"varint,26,opt,name=prev_duration,json=prevDuration" json:"prev_duration,omitempty"`
	// If order is modified, this is the new duration.
	// This field is associated with Order.Duration enum type.
	Duration *uint32 `protobuf:"varint,27,opt,name=duration" json:"duration,omitempty"`
	// If order is modified, this is the previous date then the order should expire  (see Order.good_thru_date).
	PrevGoodThruDate *int64 `protobuf:"zigzag64,28,opt,name=prev_good_thru_date,json=prevGoodThruDate" json:"prev_good_thru_date,omitempty"`
	// If order is modified, this is the updated date then the order should expire  (see Order.good_thru_date).
	GoodThruDate *int64 `protobuf:"zigzag64,29,opt,name=good_thru_date,json=goodThruDate" json:"good_thru_date,omitempty"`
	// If order request is rejected, this is rejection code (the list is provided separately).
	RejectCode *uint32 `protobuf:"varint,30,opt,name=reject_code,json=rejectCode" json:"reject_code,omitempty"`
	// If present, identifies the counterpart of the order fill, as reported by the execution system.
	FillCounterparty *string `protobuf:"bytes,31,opt,name=fill_counterparty,json=fillCounterparty" json:"fill_counterparty,omitempty"`
	// Order identifier assigned by server when sending the order to execution system.
	RouteClOrderId *string `protobuf:"bytes,32,opt,name=route_cl_order_id,json=routeClOrderId" json:"route_cl_order_id,omitempty"`
	// Additional transaction details.
	TextMessage *string `protobuf:"bytes,33,opt,name=text_message,json=textMessage" json:"text_message,omitempty"`
	// If order is modified, this is the previous time then the order should expire  (see Order.good_thru_utc_time).
	PrevGoodThruUtcTime *int64 `protobuf:"zigzag64,34,opt,name=prev_good_thru_utc_time,json=prevGoodThruUtcTime" json:"prev_good_thru_utc_time,omitempty"`
	// If order is modified, this is the updated time then the order should expire  (see Order.good_thru_utc).
	GoodThruUtcTime *int64 `protobuf:"zigzag64,35,opt,name=good_thru_utc_time,json=goodThruUtcTime" json:"good_thru_utc_time,omitempty"`
	// OrderRequest.client_regulatory_algorithm_id value echoed back from the latest order request.
	ClientRegulatoryAlgorithmId *uint32 `protobuf:"varint,36,opt,name=client_regulatory_algorithm_id,json=clientRegulatoryAlgorithmId" json:"client_regulatory_algorithm_id,omitempty"`
	// Regulatory Algorithm ID actually sent to the exchange for this order, if any.
	// Will differ from client_regulatory_algorithm_id if any CQG algorithm was applied to the order.
	EffectiveRegulatoryAlgorithmId *uint32 `protobuf:"varint,37,opt,name=effective_regulatory_algorithm_id,json=effectiveRegulatoryAlgorithmId" json:"effective_regulatory_algorithm_id,omitempty"`
	XXX_unrecognized               []byte  `json:"-"`
}

func (m *TransactionStatus) Reset()                    { *m = TransactionStatus{} }
func (m *TransactionStatus) String() string            { return proto.CompactTextString(m) }
func (*TransactionStatus) ProtoMessage()               {}
func (*TransactionStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{93} }

func (m *TransactionStatus) GetStatus() uint32 {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return 0
}

func (m *TransactionStatus) GetTransId() uint64 {
	if m != nil && m.TransId != nil {
		return *m.TransId
	}
	return 0
}

func (m *TransactionStatus) GetTransUtcTime() int64 {
	if m != nil && m.TransUtcTime != nil {
		return *m.TransUtcTime
	}
	return 0
}

func (m *TransactionStatus) GetRefTransId() uint64 {
	if m != nil && m.RefTransId != nil {
		return *m.RefTransId
	}
	return 0
}

func (m *TransactionStatus) GetOrigClOrderId() string {
	if m != nil && m.OrigClOrderId != nil {
		return *m.OrigClOrderId
	}
	return ""
}

func (m *TransactionStatus) GetClOrderId() string {
	if m != nil && m.ClOrderId != nil {
		return *m.ClOrderId
	}
	return ""
}

func (m *TransactionStatus) GetFillQty() uint32 {
	if m != nil && m.FillQty != nil {
		return *m.FillQty
	}
	return 0
}

func (m *TransactionStatus) GetFillPrice() int32 {
	if m != nil && m.FillPrice != nil {
		return *m.FillPrice
	}
	return 0
}

func (m *TransactionStatus) GetTrade() []*Trade {
	if m != nil {
		return m.Trade
	}
	return nil
}

func (m *TransactionStatus) GetStrategyLegFills() []*StrategyLegFill {
	if m != nil {
		return m.StrategyLegFills
	}
	return nil
}

func (m *TransactionStatus) GetSyntheticHang() *SyntheticHang {
	if m != nil {
		return m.SyntheticHang
	}
	return nil
}

func (m *TransactionStatus) GetPrevOrderQty() uint32 {
	if m != nil && m.PrevOrderQty != nil {
		return *m.PrevOrderQty
	}
	return 0
}

func (m *TransactionStatus) GetOrderQty() uint32 {
	if m != nil && m.OrderQty != nil {
		return *m.OrderQty
	}
	return 0
}

func (m *TransactionStatus) GetPrevLimitPrice() int32 {
	if m != nil && m.PrevLimitPrice != nil {
		return *m.PrevLimitPrice
	}
	return 0
}

func (m *TransactionStatus) GetLimitPrice() int32 {
	if m != nil && m.LimitPrice != nil {
		return *m.LimitPrice
	}
	return 0
}

func (m *TransactionStatus) GetPrevStopPrice() int32 {
	if m != nil && m.PrevStopPrice != nil {
		return *m.PrevStopPrice
	}
	return 0
}

func (m *TransactionStatus) GetStopPrice() int32 {
	if m != nil && m.StopPrice != nil {
		return *m.StopPrice
	}
	return 0
}

func (m *TransactionStatus) GetPrevVisibleQty() uint32 {
	if m != nil && m.PrevVisibleQty != nil {
		return *m.PrevVisibleQty
	}
	return 0
}

func (m *TransactionStatus) GetVisibleQty() uint32 {
	if m != nil && m.VisibleQty != nil {
		return *m.VisibleQty
	}
	return 0
}

func (m *TransactionStatus) GetPrevMinVisibleQty() uint32 {
	if m != nil && m.PrevMinVisibleQty != nil {
		return *m.PrevMinVisibleQty
	}
	return 0
}

func (m *TransactionStatus) GetMinVisibleQty() uint32 {
	if m != nil && m.MinVisibleQty != nil {
		return *m.MinVisibleQty
	}
	return 0
}

func (m *TransactionStatus) GetPrevFillQty() uint32 {
	if m != nil && m.PrevFillQty != nil {
		return *m.PrevFillQty
	}
	return 0
}

func (m *TransactionStatus) GetPrevFillPrice() int32 {
	if m != nil && m.PrevFillPrice != nil {
		return *m.PrevFillPrice
	}
	return 0
}

func (m *TransactionStatus) GetPrevOrderType() uint32 {
	if m != nil && m.PrevOrderType != nil {
		return *m.PrevOrderType
	}
	return 0
}

func (m *TransactionStatus) GetOrderType() uint32 {
	if m != nil && m.OrderType != nil {
		return *m.OrderType
	}
	return 0
}

func (m *TransactionStatus) GetPrevExecInstruction() []uint32 {
	if m != nil {
		return m.PrevExecInstruction
	}
	return nil
}

func (m *TransactionStatus) GetExecInstruction() []uint32 {
	if m != nil {
		return m.ExecInstruction
	}
	return nil
}

func (m *TransactionStatus) GetPrevDuration() uint32 {
	if m != nil && m.PrevDuration != nil {
		return *m.PrevDuration
	}
	return 0
}

func (m *TransactionStatus) GetDuration() uint32 {
	if m != nil && m.Duration != nil {
		return *m.Duration
	}
	return 0
}

func (m *TransactionStatus) GetPrevGoodThruDate() int64 {
	if m != nil && m.PrevGoodThruDate != nil {
		return *m.PrevGoodThruDate
	}
	return 0
}

func (m *TransactionStatus) GetGoodThruDate() int64 {
	if m != nil && m.GoodThruDate != nil {
		return *m.GoodThruDate
	}
	return 0
}

func (m *TransactionStatus) GetRejectCode() uint32 {
	if m != nil && m.RejectCode != nil {
		return *m.RejectCode
	}
	return 0
}

func (m *TransactionStatus) GetFillCounterparty() string {
	if m != nil && m.FillCounterparty != nil {
		return *m.FillCounterparty
	}
	return ""
}

func (m *TransactionStatus) GetRouteClOrderId() string {
	if m != nil && m.RouteClOrderId != nil {
		return *m.RouteClOrderId
	}
	return ""
}

func (m *TransactionStatus) GetTextMessage() string {
	if m != nil && m.TextMessage != nil {
		return *m.TextMessage
	}
	return ""
}

func (m *TransactionStatus) GetPrevGoodThruUtcTime() int64 {
	if m != nil && m.PrevGoodThruUtcTime != nil {
		return *m.PrevGoodThruUtcTime
	}
	return 0
}

func (m *TransactionStatus) GetGoodThruUtcTime() int64 {
	if m != nil && m.GoodThruUtcTime != nil {
		return *m.GoodThruUtcTime
	}
	return 0
}

func (m *TransactionStatus) GetClientRegulatoryAlgorithmId() uint32 {
	if m != nil && m.ClientRegulatoryAlgorithmId != nil {
		return *m.ClientRegulatoryAlgorithmId
	}
	return 0
}

func (m *TransactionStatus) GetEffectiveRegulatoryAlgorithmId() uint32 {
	if m != nil && m.EffectiveRegulatoryAlgorithmId != nil {
		return *m.EffectiveRegulatoryAlgorithmId
	}
	return 0
}

// Trade per specific outright contract.
type Trade struct {
	// Trade ID assigned by server, unique within Username.
	TradeId *string `protobuf:"bytes,1,req,name=trade_id,json=tradeId" json:"trade_id,omitempty"`
	// Server contract identifier.
	ContractId *uint32 `protobuf:"varint,2,req,name=contract_id,json=contractId" json:"contract_id,omitempty"`
	// Brokerage statement date this trade corresponds to (in time format, convert to date only).
	StatementDate *int64 `protobuf:"zigzag64,3,req,name=statement_date,json=statementDate" json:"statement_date,omitempty"`
	// Time of the trade (UTC).
	TradeUtcTime *int64 `protobuf:"zigzag64,4,req,name=trade_utc_time,json=tradeUtcTime" json:"trade_utc_time,omitempty"`
	// Exchange trade day this trade corresponds to (in time format, date only value).
	TradeDate *int64 `protobuf:"zigzag64,5,req,name=trade_date,json=tradeDate" json:"trade_date,omitempty"`
	// Trade price.
	Price *int32 `protobuf:"zigzag32,6,req,name=price" json:"price,omitempty"`
	// Trade side.
	// This field is associated with Order.Side enum type.
	Side *uint32 `protobuf:"varint,7,req,name=side" json:"side,omitempty"`
	// Trade size.
	Qty *uint32 `protobuf:"varint,8,req,name=qty" json:"qty,omitempty"`
	// If present, identifies the counter-party of the trade, as reported by the execution system
	// (may or may not match counter-party reported for the order fill).
	TradeCounterparty *string `protobuf:"bytes,9,opt,name=trade_counterparty,json=tradeCounterparty" json:"trade_counterparty,omitempty"`
	// Flag that trade was made as aggressive.
	IsAggressive *bool `protobuf:"varint,10,opt,name=is_aggressive,json=isAggressive" json:"is_aggressive,omitempty"`
	// Execution Id of the leg fill
	LegExecutionId   *string `protobuf:"bytes,11,opt,name=leg_execution_id,json=legExecutionId" json:"leg_execution_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Trade) Reset()                    { *m = Trade{} }
func (m *Trade) String() string            { return proto.CompactTextString(m) }
func (*Trade) ProtoMessage()               {}
func (*Trade) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{94} }

func (m *Trade) GetTradeId() string {
	if m != nil && m.TradeId != nil {
		return *m.TradeId
	}
	return ""
}

func (m *Trade) GetContractId() uint32 {
	if m != nil && m.ContractId != nil {
		return *m.ContractId
	}
	return 0
}

func (m *Trade) GetStatementDate() int64 {
	if m != nil && m.StatementDate != nil {
		return *m.StatementDate
	}
	return 0
}

func (m *Trade) GetTradeUtcTime() int64 {
	if m != nil && m.TradeUtcTime != nil {
		return *m.TradeUtcTime
	}
	return 0
}

func (m *Trade) GetTradeDate() int64 {
	if m != nil && m.TradeDate != nil {
		return *m.TradeDate
	}
	return 0
}

func (m *Trade) GetPrice() int32 {
	if m != nil && m.Price != nil {
		return *m.Price
	}
	return 0
}

func (m *Trade) GetSide() uint32 {
	if m != nil && m.Side != nil {
		return *m.Side
	}
	return 0
}

func (m *Trade) GetQty() uint32 {
	if m != nil && m.Qty != nil {
		return *m.Qty
	}
	return 0
}

func (m *Trade) GetTradeCounterparty() string {
	if m != nil && m.TradeCounterparty != nil {
		return *m.TradeCounterparty
	}
	return ""
}

func (m *Trade) GetIsAggressive() bool {
	if m != nil && m.IsAggressive != nil {
		return *m.IsAggressive
	}
	return false
}

func (m *Trade) GetLegExecutionId() string {
	if m != nil && m.LegExecutionId != nil {
		return *m.LegExecutionId
	}
	return ""
}

// Describes a leg order fill that contributes to a synthetic strategy order fill.
type StrategyLegFill struct {
	// Order Id for the leg order (the original OrderStatus.order_id)
	LegOrderId *string `protobuf:"bytes,1,req,name=leg_order_id,json=legOrderId" json:"leg_order_id,omitempty"`
	// Leg_execution_id of the corresponding Trade message for the leg order fill.
	LegExecutionId *string `protobuf:"bytes,2,req,name=leg_execution_id,json=legExecutionId" json:"leg_execution_id,omitempty"`
	// Quantity of the leg order fill used for this synthetic strategy order fill,
	// decimal (fractional quantities are possible for legs with non-integer quantity ratio).
	Qty              *float64 `protobuf:"fixed64,3,req,name=qty" json:"qty,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *StrategyLegFill) Reset()                    { *m = StrategyLegFill{} }
func (m *StrategyLegFill) String() string            { return proto.CompactTextString(m) }
func (*StrategyLegFill) ProtoMessage()               {}
func (*StrategyLegFill) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{95} }

func (m *StrategyLegFill) GetLegOrderId() string {
	if m != nil && m.LegOrderId != nil {
		return *m.LegOrderId
	}
	return ""
}

func (m *StrategyLegFill) GetLegExecutionId() string {
	if m != nil && m.LegExecutionId != nil {
		return *m.LegExecutionId
	}
	return ""
}

func (m *StrategyLegFill) GetQty() float64 {
	if m != nil && m.Qty != nil {
		return *m.Qty
	}
	return 0
}

// Details of hung quantity on a synthetic strategy order or existing hang resolution
type SyntheticHang struct {
	// Unique hang identifier supplied by server.
	HangId *int32 `protobuf:"zigzag32,1,req,name=hang_id,json=hangId" json:"hang_id,omitempty"`
	// Quantity (of the synthetic strategy order) hung, 0 indicates that hang is resolved.
	HungQty *uint32 `protobuf:"varint,2,req,name=hung_qty,json=hungQty" json:"hung_qty,omitempty"`
	// Orders participating in a synthetic strategy order hang.
	// Note: this is the original OrderStatus.order_id.
	OrderId          []string `protobuf:"bytes,3,rep,name=order_id,json=orderId" json:"order_id,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *SyntheticHang) Reset()                    { *m = SyntheticHang{} }
func (m *SyntheticHang) String() string            { return proto.CompactTextString(m) }
func (*SyntheticHang) ProtoMessage()               {}
func (*SyntheticHang) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{96} }

func (m *SyntheticHang) GetHangId() int32 {
	if m != nil && m.HangId != nil {
		return *m.HangId
	}
	return 0
}

func (m *SyntheticHang) GetHungQty() uint32 {
	if m != nil && m.HungQty != nil {
		return *m.HungQty
	}
	return 0
}

func (m *SyntheticHang) GetOrderId() []string {
	if m != nil {
		return m.OrderId
	}
	return nil
}

// Compound order structure.
type CompoundOrderStructure struct {
	// This field is associated with CompoundOrder.Type enum type.
	// Type of the compound order.
	Type *uint32 `protobuf:"varint,1,req,name=type" json:"type,omitempty"`
	// ID of the compound order assigned by client.
	ClCompoundId *string `protobuf:"bytes,2,req,name=cl_compound_id,json=clCompoundId" json:"cl_compound_id,omitempty"`
	// List of entires.
	CompoundOrderEntry []*CompoundOrderStructureEntry `protobuf:"bytes,3,rep,name=compound_order_entry,json=compoundOrderEntry" json:"compound_order_entry,omitempty"`
	XXX_unrecognized   []byte                         `json:"-"`
}

func (m *CompoundOrderStructure) Reset()                    { *m = CompoundOrderStructure{} }
func (m *CompoundOrderStructure) String() string            { return proto.CompactTextString(m) }
func (*CompoundOrderStructure) ProtoMessage()               {}
func (*CompoundOrderStructure) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{97} }

func (m *CompoundOrderStructure) GetType() uint32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *CompoundOrderStructure) GetClCompoundId() string {
	if m != nil && m.ClCompoundId != nil {
		return *m.ClCompoundId
	}
	return ""
}

func (m *CompoundOrderStructure) GetCompoundOrderEntry() []*CompoundOrderStructureEntry {
	if m != nil {
		return m.CompoundOrderEntry
	}
	return nil
}

// Entry of a compound order structure. One of optional fields is specified.
type CompoundOrderStructureEntry struct {
	// Regular order Id as assigned by server.
	ChainOrderId *string `protobuf:"bytes,1,opt,name=chain_order_id,json=chainOrderId" json:"chain_order_id,omitempty"`
	// Sub-compound order structure entry.
	CompoundOrderStructure *CompoundOrderStructure `protobuf:"bytes,2,opt,name=compound_order_structure,json=compoundOrderStructure" json:"compound_order_structure,omitempty"`
	XXX_unrecognized       []byte                  `json:"-"`
}

func (m *CompoundOrderStructureEntry) Reset()                    { *m = CompoundOrderStructureEntry{} }
func (m *CompoundOrderStructureEntry) String() string            { return proto.CompactTextString(m) }
func (*CompoundOrderStructureEntry) ProtoMessage()               {}
func (*CompoundOrderStructureEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{98} }

func (m *CompoundOrderStructureEntry) GetChainOrderId() string {
	if m != nil && m.ChainOrderId != nil {
		return *m.ChainOrderId
	}
	return ""
}

func (m *CompoundOrderStructureEntry) GetCompoundOrderStructure() *CompoundOrderStructure {
	if m != nil {
		return m.CompoundOrderStructure
	}
	return nil
}

// Parameters associated with a concrete leg.
type StrategyOrderLegParameters struct {
	// Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index or LegDefinition.node_index value).
	NodeIndex *uint32 `protobuf:"varint,1,req,name=node_index,json=nodeIndex" json:"node_index,omitempty"`
	// Account to place order on the leg.
	AccountId        *int32 `protobuf:"zigzag32,2,req,name=account_id,json=accountId" json:"account_id,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *StrategyOrderLegParameters) Reset()                    { *m = StrategyOrderLegParameters{} }
func (m *StrategyOrderLegParameters) String() string            { return proto.CompactTextString(m) }
func (*StrategyOrderLegParameters) ProtoMessage()               {}
func (*StrategyOrderLegParameters) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{99} }

func (m *StrategyOrderLegParameters) GetNodeIndex() uint32 {
	if m != nil && m.NodeIndex != nil {
		return *m.NodeIndex
	}
	return 0
}

func (m *StrategyOrderLegParameters) GetAccountId() int32 {
	if m != nil && m.AccountId != nil {
		return *m.AccountId
	}
	return 0
}

// Synthetic strategy MKT order parameters
type StrategyMarketOrderParameters struct {
	// Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index).
	NodeIndex *uint32 `protobuf:"varint,1,req,name=node_index,json=nodeIndex" json:"node_index,omitempty"`
	// For Iceberg orders:
	// 'true' means replenish qty on the filled leg immediately upon receiving primary fill;
	// 'false' means to 'freeze' the filled leg (don't add any more qty to it) until SS order
	//         is filled or its qty changes for some other Reason, e.g. replace request.
	ReplenishOnPrimaryFill *bool  `protobuf:"varint,2,opt,name=replenish_on_primary_fill,json=replenishOnPrimaryFill" json:"replenish_on_primary_fill,omitempty"`
	XXX_unrecognized       []byte `json:"-"`
}

func (m *StrategyMarketOrderParameters) Reset()                    { *m = StrategyMarketOrderParameters{} }
func (m *StrategyMarketOrderParameters) String() string            { return proto.CompactTextString(m) }
func (*StrategyMarketOrderParameters) ProtoMessage()               {}
func (*StrategyMarketOrderParameters) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{100} }

func (m *StrategyMarketOrderParameters) GetNodeIndex() uint32 {
	if m != nil && m.NodeIndex != nil {
		return *m.NodeIndex
	}
	return 0
}

func (m *StrategyMarketOrderParameters) GetReplenishOnPrimaryFill() bool {
	if m != nil && m.ReplenishOnPrimaryFill != nil {
		return *m.ReplenishOnPrimaryFill
	}
	return false
}

// Parameters of LMT orders on a leg which is currently working.
type PrimaryOrdersLimit struct {
	// Place an order only if the quantity available in the monitored leg is at least this much and
	// to modify a working order only if the quantity available in the monitored leg increases by at least this much.
	// Default is 1.
	MinQtyIncrement *uint32 `protobuf:"varint,1,opt,name=min_qty_increment,json=minQtyIncrement" json:"min_qty_increment,omitempty"`
	// Queue holders (stacked orders) are additional orders placed in the queue at specified price levels away from the initial working order.
	// Sets the minimum number of orders to include in the queue.
	// Allowed values: 1-10, default is 1.
	QueueHoldersMinSize *uint32 `protobuf:"varint,2,opt,name=queue_holders_min_size,json=queueHoldersMinSize" json:"queue_holders_min_size,omitempty"`
	// Sets the maximum number of orders to include in the queue.
	// Allowed values: 1-10 and not less than queue_holders_min_size, default is 1.
	QueueHoldersMaxSize *uint32 `protobuf:"varint,3,opt,name=queue_holders_max_size,json=queueHoldersMaxSize" json:"queue_holders_max_size,omitempty"`
	// Indicates how many price levels (ticks) to skip between orders in the queue.
	// Allowed range is 1-5, default is 1.
	QueueHoldersDistance *uint32 `protobuf:"varint,4,opt,name=queue_holders_distance,json=queueHoldersDistance" json:"queue_holders_distance,omitempty"`
	// Indicates how far the market should run before maximizing size of a recently placed order that is now part of the group of stacked orders.
	// Must be less than queue_holders_min_size, default is 0.
	OrderSizeRestoreThreshold *uint32 `protobuf:"varint,5,opt,name=order_size_restore_threshold,json=orderSizeRestoreThreshold" json:"order_size_restore_threshold,omitempty"`
	// Primary Iceberg order visible size in lots.
	VisibleQty *uint32 `protobuf:"varint,6,opt,name=visible_qty,json=visibleQty" json:"visible_qty,omitempty"`
	// Primary Iceberg order min visible size in lots.
	MinVisibleQty *uint32 `protobuf:"varint,7,opt,name=min_visible_qty,json=minVisibleQty" json:"min_visible_qty,omitempty"`
	// Maximal distance between the market price and the old/new limit price of working primary leg
	// orders, which allows modifications of these orders' prices(in ticks).
	// Zero value is acceptable and means that the orders are modified at any distance.
	// 0 is default.
	WorkingOrdersPriceRange *uint32 `protobuf:"varint,8,opt,name=working_orders_price_range,json=workingOrdersPriceRange" json:"working_orders_price_range,omitempty"`
	// Minimal difference between the old and the new limit prices of working
	// primary leg orders, which allows modifications of these orders' prices (in ticks).
	MinPriceChange *uint32 `protobuf:"varint,9,opt,name=min_price_change,json=minPriceChange" json:"min_price_change,omitempty"`
	// Maximum number of leg orders per price level
	PrimaryOrdersFifoQueueSize *uint32 `protobuf:"varint,10,opt,name=primary_orders_fifo_queue_size,json=primaryOrdersFifoQueueSize" json:"primary_orders_fifo_queue_size,omitempty"`
	// Period of updates to the working leg in milliseconds, such that every N ms,
	// the leg is put where it ought to be placed based upon current prices.
	// Default is to use the server settings.
	ForceUpdatePeriod *uint32 `protobuf:"varint,11,opt,name=force_update_period,json=forceUpdatePeriod" json:"force_update_period,omitempty"`
	// Flag that shows whether observed markets must be used for primary orders size calculation or not.
	IgnoreObservedMarkets *bool `protobuf:"varint,12,opt,name=ignore_observed_markets,json=ignoreObservedMarkets" json:"ignore_observed_markets,omitempty"`
	// Specifies (in ticks) maximum distance primary order price could be moved from target one while creating best bid/ask.
	MaxDimming *uint32 `protobuf:"varint,13,opt,name=max_dimming,json=maxDimming" json:"max_dimming,omitempty"`
	// Mode of handling primary leg orders with target price far from market. One of FarFromMarketMode enums.
	// Default is to use the server settings.
	FarFromMarketMode *uint32 `protobuf:"varint,14,opt,name=far_from_market_mode,json=farFromMarketMode" json:"far_from_market_mode,omitempty"`
	// Defines if and where server must work quantity that cannot lean onto current best bid/offer.
	// Allowed range 0-9, default is to use the server setting.
	TicksAwayToWork *int32 `protobuf:"varint,15,opt,name=ticks_away_to_work,json=ticksAwayToWork" json:"ticks_away_to_work,omitempty"`
	// How to work orders considering DOM data. One of DOMUsageMode enums. TOP_ONLY is default.
	DomUsage *uint32 `protobuf:"varint,16,opt,name=dom_usage,json=domUsage" json:"dom_usage,omitempty"`
	// Work up to this number of orders to get required volume if dom_usage is MULTILEVELS.
	// Allowed range 1-10, default is 1.
	DomMultilevelQty *uint32 `protobuf:"varint,17,opt,name=dom_multilevel_qty,json=domMultilevelQty" json:"dom_multilevel_qty,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PrimaryOrdersLimit) Reset()                    { *m = PrimaryOrdersLimit{} }
func (m *PrimaryOrdersLimit) String() string            { return proto.CompactTextString(m) }
func (*PrimaryOrdersLimit) ProtoMessage()               {}
func (*PrimaryOrdersLimit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{101} }

func (m *PrimaryOrdersLimit) GetMinQtyIncrement() uint32 {
	if m != nil && m.MinQtyIncrement != nil {
		return *m.MinQtyIncrement
	}
	return 0
}

func (m *PrimaryOrdersLimit) GetQueueHoldersMinSize() uint32 {
	if m != nil && m.QueueHoldersMinSize != nil {
		return *m.QueueHoldersMinSize
	}
	return 0
}

func (m *PrimaryOrdersLimit) GetQueueHoldersMaxSize() uint32 {
	if m != nil && m.QueueHoldersMaxSize != nil {
		return *m.QueueHoldersMaxSize
	}
	return 0
}

func (m *PrimaryOrdersLimit) GetQueueHoldersDistance() uint32 {
	if m != nil && m.QueueHoldersDistance != nil {
		return *m.QueueHoldersDistance
	}
	return 0
}

func (m *PrimaryOrdersLimit) GetOrderSizeRestoreThreshold() uint32 {
	if m != nil && m.OrderSizeRestoreThreshold != nil {
		return *m.OrderSizeRestoreThreshold
	}
	return 0
}

func (m *PrimaryOrdersLimit) GetVisibleQty() uint32 {
	if m != nil && m.VisibleQty != nil {
		return *m.VisibleQty
	}
	return 0
}

func (m *PrimaryOrdersLimit) GetMinVisibleQty() uint32 {
	if m != nil && m.MinVisibleQty != nil {
		return *m.MinVisibleQty
	}
	return 0
}

func (m *PrimaryOrdersLimit) GetWorkingOrdersPriceRange() uint32 {
	if m != nil && m.WorkingOrdersPriceRange != nil {
		return *m.WorkingOrdersPriceRange
	}
	return 0
}

func (m *PrimaryOrdersLimit) GetMinPriceChange() uint32 {
	if m != nil && m.MinPriceChange != nil {
		return *m.MinPriceChange
	}
	return 0
}

func (m *PrimaryOrdersLimit) GetPrimaryOrdersFifoQueueSize() uint32 {
	if m != nil && m.PrimaryOrdersFifoQueueSize != nil {
		return *m.PrimaryOrdersFifoQueueSize
	}
	return 0
}

func (m *PrimaryOrdersLimit) GetForceUpdatePeriod() uint32 {
	if m != nil && m.ForceUpdatePeriod != nil {
		return *m.ForceUpdatePeriod
	}
	return 0
}

func (m *PrimaryOrdersLimit) GetIgnoreObservedMarkets() bool {
	if m != nil && m.IgnoreObservedMarkets != nil {
		return *m.IgnoreObservedMarkets
	}
	return false
}

func (m *PrimaryOrdersLimit) GetMaxDimming() uint32 {
	if m != nil && m.MaxDimming != nil {
		return *m.MaxDimming
	}
	return 0
}

func (m *PrimaryOrdersLimit) GetFarFromMarketMode() uint32 {
	if m != nil && m.FarFromMarketMode != nil {
		return *m.FarFromMarketMode
	}
	return 0
}

func (m *PrimaryOrdersLimit) GetTicksAwayToWork() int32 {
	if m != nil && m.TicksAwayToWork != nil {
		return *m.TicksAwayToWork
	}
	return 0
}

func (m *PrimaryOrdersLimit) GetDomUsage() uint32 {
	if m != nil && m.DomUsage != nil {
		return *m.DomUsage
	}
	return 0
}

func (m *PrimaryOrdersLimit) GetDomMultilevelQty() uint32 {
	if m != nil && m.DomMultilevelQty != nil {
		return *m.DomMultilevelQty
	}
	return 0
}

// Sniper rule means don't place any primary order.
// It just watchs markets waiting for the moment when the strategy order's LMT price is available.
// Then secondary orders on all legs must be placed.
type PrimaryOrdersSniper struct {
	// One of LegDuration enums.
	LegDuration      *uint32 `protobuf:"varint,1,req,name=leg_duration,json=legDuration" json:"leg_duration,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PrimaryOrdersSniper) Reset()                    { *m = PrimaryOrdersSniper{} }
func (m *PrimaryOrdersSniper) String() string            { return proto.CompactTextString(m) }
func (*PrimaryOrdersSniper) ProtoMessage()               {}
func (*PrimaryOrdersSniper) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{102} }

func (m *PrimaryOrdersSniper) GetLegDuration() uint32 {
	if m != nil && m.LegDuration != nil {
		return *m.LegDuration
	}
	return 0
}

// LMT secondary orders parameters.
type SecondaryOrdersLimit struct {
	// Offset to adjust secondary order price at the moment of place. Default is 0.
	InitialOffset    *float64 `protobuf:"fixed64,1,opt,name=initial_offset,json=initialOffset" json:"initial_offset,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *SecondaryOrdersLimit) Reset()                    { *m = SecondaryOrdersLimit{} }
func (m *SecondaryOrdersLimit) String() string            { return proto.CompactTextString(m) }
func (*SecondaryOrdersLimit) ProtoMessage()               {}
func (*SecondaryOrdersLimit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{103} }

func (m *SecondaryOrdersLimit) GetInitialOffset() float64 {
	if m != nil && m.InitialOffset != nil {
		return *m.InitialOffset
	}
	return 0
}

// MKT secondary orders parameters.
type SecondaryOrdersMarket struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *SecondaryOrdersMarket) Reset()                    { *m = SecondaryOrdersMarket{} }
func (m *SecondaryOrdersMarket) String() string            { return proto.CompactTextString(m) }
func (*SecondaryOrdersMarket) ProtoMessage()               {}
func (*SecondaryOrdersMarket) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{104} }

// Pay up secondary orders parameters.
type SecondaryOrdersPayUp struct {
	// Offset to modify the price of a hung secondary order.
	Offset *float64 `protobuf:"fixed64,1,req,name=offset" json:"offset,omitempty"`
	// Offset to adjust the secondary order price at the moment of placement.
	InitialOffset *float64 `protobuf:"fixed64,2,opt,name=initial_offset,json=initialOffset" json:"initial_offset,omitempty"`
	// One of the conditions below must be set.
	// Condition to check that pointed time interval is passed.
	ConditionTimeout *uint32 `protobuf:"varint,3,opt,name=condition_timeout,json=conditionTimeout" json:"condition_timeout,omitempty"`
	// Condition to check the opposite market volume.
	ConditionAbsoluteVolume *uint32 `protobuf:"varint,4,opt,name=condition_absolute_volume,json=conditionAbsoluteVolume" json:"condition_absolute_volume,omitempty"`
	// Condition to check the ratio between the opposite side and secondary order sizes.
	ConditionOppositeVolumeRatio *float64 `protobuf:"fixed64,5,opt,name=condition_opposite_volume_ratio,json=conditionOppositeVolumeRatio" json:"condition_opposite_volume_ratio,omitempty"`
	// Condition to check the opposite side and the local side volumes ratio.
	ConditionBbaVolumeRatio *float64 `protobuf:"fixed64,6,opt,name=condition_bba_volume_ratio,json=conditionBbaVolumeRatio" json:"condition_bba_volume_ratio,omitempty"`
	XXX_unrecognized        []byte   `json:"-"`
}

func (m *SecondaryOrdersPayUp) Reset()                    { *m = SecondaryOrdersPayUp{} }
func (m *SecondaryOrdersPayUp) String() string            { return proto.CompactTextString(m) }
func (*SecondaryOrdersPayUp) ProtoMessage()               {}
func (*SecondaryOrdersPayUp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{105} }

func (m *SecondaryOrdersPayUp) GetOffset() float64 {
	if m != nil && m.Offset != nil {
		return *m.Offset
	}
	return 0
}

func (m *SecondaryOrdersPayUp) GetInitialOffset() float64 {
	if m != nil && m.InitialOffset != nil {
		return *m.InitialOffset
	}
	return 0
}

func (m *SecondaryOrdersPayUp) GetConditionTimeout() uint32 {
	if m != nil && m.ConditionTimeout != nil {
		return *m.ConditionTimeout
	}
	return 0
}

func (m *SecondaryOrdersPayUp) GetConditionAbsoluteVolume() uint32 {
	if m != nil && m.ConditionAbsoluteVolume != nil {
		return *m.ConditionAbsoluteVolume
	}
	return 0
}

func (m *SecondaryOrdersPayUp) GetConditionOppositeVolumeRatio() float64 {
	if m != nil && m.ConditionOppositeVolumeRatio != nil {
		return *m.ConditionOppositeVolumeRatio
	}
	return 0
}

func (m *SecondaryOrdersPayUp) GetConditionBbaVolumeRatio() float64 {
	if m != nil && m.ConditionBbaVolumeRatio != nil {
		return *m.ConditionBbaVolumeRatio
	}
	return 0
}

// Trailing secondary orders parameters.
type SecondaryOrdersTrailing struct {
	// Trailing offset.
	TrailingOffset *float64 `protobuf:"fixed64,1,req,name=trailing_offset,json=trailingOffset" json:"trailing_offset,omitempty"`
	// Peg that price must follow. One of Order.TrailingPeg enum.
	TrailingPeg *uint32 `protobuf:"varint,2,req,name=trailing_peg,json=trailingPeg" json:"trailing_peg,omitempty"`
	// Offset to adjust secondary order price at the moment of place.
	InitialOffset *float64 `protobuf:"fixed64,3,opt,name=initial_offset,json=initialOffset" json:"initial_offset,omitempty"`
	// Maximum distance to trail away from the initial price.
	MaxTrail *float64 `protobuf:"fixed64,4,opt,name=max_trail,json=maxTrail" json:"max_trail,omitempty"`
	// One of the conditions below must be set.
	// Condition that checks the opposite market volume.
	ConditionAbsoluteVolume *uint32 `protobuf:"varint,5,opt,name=condition_absolute_volume,json=conditionAbsoluteVolume" json:"condition_absolute_volume,omitempty"`
	// Condition that checks relation between opposite side and secondary order sizes.
	ConditionOppositeVolumeRatio *float64 `protobuf:"fixed64,6,opt,name=condition_opposite_volume_ratio,json=conditionOppositeVolumeRatio" json:"condition_opposite_volume_ratio,omitempty"`
	// Condition that checks the opposite side and the local side volumes ratio
	ConditionBbaVolumeRatio *float64 `protobuf:"fixed64,7,opt,name=condition_bba_volume_ratio,json=conditionBbaVolumeRatio" json:"condition_bba_volume_ratio,omitempty"`
	XXX_unrecognized        []byte   `json:"-"`
}

func (m *SecondaryOrdersTrailing) Reset()                    { *m = SecondaryOrdersTrailing{} }
func (m *SecondaryOrdersTrailing) String() string            { return proto.CompactTextString(m) }
func (*SecondaryOrdersTrailing) ProtoMessage()               {}
func (*SecondaryOrdersTrailing) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{106} }

func (m *SecondaryOrdersTrailing) GetTrailingOffset() float64 {
	if m != nil && m.TrailingOffset != nil {
		return *m.TrailingOffset
	}
	return 0
}

func (m *SecondaryOrdersTrailing) GetTrailingPeg() uint32 {
	if m != nil && m.TrailingPeg != nil {
		return *m.TrailingPeg
	}
	return 0
}

func (m *SecondaryOrdersTrailing) GetInitialOffset() float64 {
	if m != nil && m.InitialOffset != nil {
		return *m.InitialOffset
	}
	return 0
}

func (m *SecondaryOrdersTrailing) GetMaxTrail() float64 {
	if m != nil && m.MaxTrail != nil {
		return *m.MaxTrail
	}
	return 0
}

func (m *SecondaryOrdersTrailing) GetConditionAbsoluteVolume() uint32 {
	if m != nil && m.ConditionAbsoluteVolume != nil {
		return *m.ConditionAbsoluteVolume
	}
	return 0
}

func (m *SecondaryOrdersTrailing) GetConditionOppositeVolumeRatio() float64 {
	if m != nil && m.ConditionOppositeVolumeRatio != nil {
		return *m.ConditionOppositeVolumeRatio
	}
	return 0
}

func (m *SecondaryOrdersTrailing) GetConditionBbaVolumeRatio() float64 {
	if m != nil && m.ConditionBbaVolumeRatio != nil {
		return *m.ConditionBbaVolumeRatio
	}
	return 0
}

// LMT order parameters for a leg.
type LimitOrderLegDescription struct {
	// Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index or LegDefinition.node_index value).
	NodeIndex *uint32 `protobuf:"varint,1,req,name=node_index,json=nodeIndex" json:"node_index,omitempty"`
	// All the attributes below are mutually exclusive.
	// Sets the leg as working and place LMT orders.
	PrimaryOrderLimit *PrimaryOrdersLimit `protobuf:"bytes,2,opt,name=primary_order_limit,json=primaryOrderLimit" json:"primary_order_limit,omitempty"`
	// Sets the leg as working and place sniper orders.
	PrimaryOrderSniper *PrimaryOrdersSniper `protobuf:"bytes,3,opt,name=primary_order_sniper,json=primaryOrderSniper" json:"primary_order_sniper,omitempty"`
	// Sets the leg as not working and place LMT orders.
	SecondaryOrdersLimit *SecondaryOrdersLimit `protobuf:"bytes,4,opt,name=secondary_orders_limit,json=secondaryOrdersLimit" json:"secondary_orders_limit,omitempty"`
	// Sets the leg as not working and place MKT orders.
	SecondaryOrdersMarket *SecondaryOrdersMarket `protobuf:"bytes,5,opt,name=secondary_orders_market,json=secondaryOrdersMarket" json:"secondary_orders_market,omitempty"`
	// Sets the leg as not working and place payup orders.
	SecondaryOrdersPayup *SecondaryOrdersPayUp `protobuf:"bytes,6,opt,name=secondary_orders_payup,json=secondaryOrdersPayup" json:"secondary_orders_payup,omitempty"`
	// Sets the leg as not working and place trailing orders.
	SecondaryOrdersTrailing *SecondaryOrdersTrailing `protobuf:"bytes,7,opt,name=secondary_orders_trailing,json=secondaryOrdersTrailing" json:"secondary_orders_trailing,omitempty"`
	// Indicates how many lots (in fractions) should be filled before the second leg order is placed.
	// Allowed range 0-1.
	// Default is off, the secondary leg placed after all lots are filled on the primary leg.
	ProportionalExecutionRatio *float64 `protobuf:"fixed64,8,opt,name=proportional_execution_ratio,json=proportionalExecutionRatio" json:"proportional_execution_ratio,omitempty"`
	// Determines the size of working orders based on a percentage of the resting volume available in the queue of the monitored leg.
	// Allowed range 0-1000.
	// Default is 1.
	VolumeMultiplier *float64 `protobuf:"fixed64,9,opt,name=volume_multiplier,json=volumeMultiplier" json:"volume_multiplier,omitempty"`
	// Tells the system to work the order if and only if the available quantity in the monitored leg is and remains greater than this value.
	// Default is 0.
	WorkThreshold    *uint32 `protobuf:"varint,10,opt,name=work_threshold,json=workThreshold" json:"work_threshold,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *LimitOrderLegDescription) Reset()                    { *m = LimitOrderLegDescription{} }
func (m *LimitOrderLegDescription) String() string            { return proto.CompactTextString(m) }
func (*LimitOrderLegDescription) ProtoMessage()               {}
func (*LimitOrderLegDescription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{107} }

func (m *LimitOrderLegDescription) GetNodeIndex() uint32 {
	if m != nil && m.NodeIndex != nil {
		return *m.NodeIndex
	}
	return 0
}

func (m *LimitOrderLegDescription) GetPrimaryOrderLimit() *PrimaryOrdersLimit {
	if m != nil {
		return m.PrimaryOrderLimit
	}
	return nil
}

func (m *LimitOrderLegDescription) GetPrimaryOrderSniper() *PrimaryOrdersSniper {
	if m != nil {
		return m.PrimaryOrderSniper
	}
	return nil
}

func (m *LimitOrderLegDescription) GetSecondaryOrdersLimit() *SecondaryOrdersLimit {
	if m != nil {
		return m.SecondaryOrdersLimit
	}
	return nil
}

func (m *LimitOrderLegDescription) GetSecondaryOrdersMarket() *SecondaryOrdersMarket {
	if m != nil {
		return m.SecondaryOrdersMarket
	}
	return nil
}

func (m *LimitOrderLegDescription) GetSecondaryOrdersPayup() *SecondaryOrdersPayUp {
	if m != nil {
		return m.SecondaryOrdersPayup
	}
	return nil
}

func (m *LimitOrderLegDescription) GetSecondaryOrdersTrailing() *SecondaryOrdersTrailing {
	if m != nil {
		return m.SecondaryOrdersTrailing
	}
	return nil
}

func (m *LimitOrderLegDescription) GetProportionalExecutionRatio() float64 {
	if m != nil && m.ProportionalExecutionRatio != nil {
		return *m.ProportionalExecutionRatio
	}
	return 0
}

func (m *LimitOrderLegDescription) GetVolumeMultiplier() float64 {
	if m != nil && m.VolumeMultiplier != nil {
		return *m.VolumeMultiplier
	}
	return 0
}

func (m *LimitOrderLegDescription) GetWorkThreshold() uint32 {
	if m != nil && m.WorkThreshold != nil {
		return *m.WorkThreshold
	}
	return 0
}

// Parameters for strategy price change depending on filled strategy size.
type PriceShifting struct {
	// step (in ticks) of each price change.
	PriceStep *int32 `protobuf:"varint,1,req,name=price_step,json=priceStep" json:"price_step,omitempty"`
	// Size of strategy order that must be filled to perform next change of strategy order price.
	FilledQtyDelta   *uint32 `protobuf:"varint,2,req,name=filled_qty_delta,json=filledQtyDelta" json:"filled_qty_delta,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PriceShifting) Reset()                    { *m = PriceShifting{} }
func (m *PriceShifting) String() string            { return proto.CompactTextString(m) }
func (*PriceShifting) ProtoMessage()               {}
func (*PriceShifting) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{108} }

func (m *PriceShifting) GetPriceStep() int32 {
	if m != nil && m.PriceStep != nil {
		return *m.PriceStep
	}
	return 0
}

func (m *PriceShifting) GetFilledQtyDelta() uint32 {
	if m != nil && m.FilledQtyDelta != nil {
		return *m.FilledQtyDelta
	}
	return 0
}

// LMT order parameters of the root or a nested strategy.
type StrategyLimitOrderParameters struct {
	// Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index value).
	NodeIndex *uint32 `protobuf:"varint,1,req,name=node_index,json=nodeIndex" json:"node_index,omitempty"`
	// Defines whether replenish quantity on primary fill or not.
	// For Iceberg orders:
	//  'true' means replenish quantity on the filled leg immediately upon receiving primary fill;
	//  'false' means to 'freeze' the filled leg (don't add any more qty to it) until SS order
	//          is filled or its quantity changes for some other Reason, e.g. replace request.
	ReplenishOnPrimaryFill *bool `protobuf:"varint,2,opt,name=replenish_on_primary_fill,json=replenishOnPrimaryFill" json:"replenish_on_primary_fill,omitempty"`
	// Defines mode of overfill handling for this limit SS order. One of OverfillMode enums.
	// AUTOMATIC_HEDGING is default.
	OverfillMode *uint32 `protobuf:"varint,3,opt,name=overfill_mode,json=overfillMode" json:"overfill_mode,omitempty"`
	// Defines sizes of what leg orders must be aligned to strategy lots.One of AlignToStrategyLots enums.
	// NONE is default.
	AlignToStrategyLots *uint32 `protobuf:"varint,4,opt,name=align_to_strategy_lots,json=alignToStrategyLots" json:"align_to_strategy_lots,omitempty"`
	// The way prices for secondary leg orders are calculated. One of PricingMethod enums.
	// AVERAGE_ORDER_PRICE is default
	PricingMethod *uint32 `protobuf:"varint,5,opt,name=pricing_method,json=pricingMethod" json:"pricing_method,omitempty"`
	// Price shifting parameters.
	PriceShifting *PriceShifting `protobuf:"bytes,6,opt,name=price_shifting,json=priceShifting" json:"price_shifting,omitempty"`
	// Parameters for strategy legs.
	LegDescription   []*LimitOrderLegDescription `protobuf:"bytes,7,rep,name=leg_description,json=legDescription" json:"leg_description,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *StrategyLimitOrderParameters) Reset()                    { *m = StrategyLimitOrderParameters{} }
func (m *StrategyLimitOrderParameters) String() string            { return proto.CompactTextString(m) }
func (*StrategyLimitOrderParameters) ProtoMessage()               {}
func (*StrategyLimitOrderParameters) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{109} }

func (m *StrategyLimitOrderParameters) GetNodeIndex() uint32 {
	if m != nil && m.NodeIndex != nil {
		return *m.NodeIndex
	}
	return 0
}

func (m *StrategyLimitOrderParameters) GetReplenishOnPrimaryFill() bool {
	if m != nil && m.ReplenishOnPrimaryFill != nil {
		return *m.ReplenishOnPrimaryFill
	}
	return false
}

func (m *StrategyLimitOrderParameters) GetOverfillMode() uint32 {
	if m != nil && m.OverfillMode != nil {
		return *m.OverfillMode
	}
	return 0
}

func (m *StrategyLimitOrderParameters) GetAlignToStrategyLots() uint32 {
	if m != nil && m.AlignToStrategyLots != nil {
		return *m.AlignToStrategyLots
	}
	return 0
}

func (m *StrategyLimitOrderParameters) GetPricingMethod() uint32 {
	if m != nil && m.PricingMethod != nil {
		return *m.PricingMethod
	}
	return 0
}

func (m *StrategyLimitOrderParameters) GetPriceShifting() *PriceShifting {
	if m != nil {
		return m.PriceShifting
	}
	return nil
}

func (m *StrategyLimitOrderParameters) GetLegDescription() []*LimitOrderLegDescription {
	if m != nil {
		return m.LegDescription
	}
	return nil
}

// STP order parameters of the root or a nested strategy.
type StrategyStopOrderParameters struct {
	// Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index value).
	NodeIndex *uint32 `protobuf:"varint,1,req,name=node_index,json=nodeIndex" json:"node_index,omitempty"`
	// The side of strategy price that STP orders watch for. One of StopSide enums.
	StopSide *uint32 `protobuf:"varint,2,req,name=stop_side,json=stopSide" json:"stop_side,omitempty"`
	// For Iceberg orders:
	//  'true' means replenish qty on the filled leg immediately upon receiving primary fill;
	//  'false' means to 'freeze' the filled leg (don't add any more qty to it) until SS order
	//          is filled or its qty changes for some other Reason, e.g. replace request.
	ReplenishOnPrimaryFill *bool  `protobuf:"varint,3,opt,name=replenish_on_primary_fill,json=replenishOnPrimaryFill" json:"replenish_on_primary_fill,omitempty"`
	XXX_unrecognized       []byte `json:"-"`
}

func (m *StrategyStopOrderParameters) Reset()                    { *m = StrategyStopOrderParameters{} }
func (m *StrategyStopOrderParameters) String() string            { return proto.CompactTextString(m) }
func (*StrategyStopOrderParameters) ProtoMessage()               {}
func (*StrategyStopOrderParameters) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{110} }

func (m *StrategyStopOrderParameters) GetNodeIndex() uint32 {
	if m != nil && m.NodeIndex != nil {
		return *m.NodeIndex
	}
	return 0
}

func (m *StrategyStopOrderParameters) GetStopSide() uint32 {
	if m != nil && m.StopSide != nil {
		return *m.StopSide
	}
	return 0
}

func (m *StrategyStopOrderParameters) GetReplenishOnPrimaryFill() bool {
	if m != nil && m.ReplenishOnPrimaryFill != nil {
		return *m.ReplenishOnPrimaryFill
	}
	return false
}

// Aggregation market taking mode: the order is held on the server until the price becomes available in at least one market;
// at which time, the server sends an order to the exchange.
type MarketTakingParameters struct {
	// Allocation percent (in range 0...1) for the leg (must total 100% among all legs).
	AllocationPercent *float64 `protobuf:"fixed64,1,req,name=allocation_percent,json=allocationPercent" json:"allocation_percent,omitempty"`
	// Time period (in ms) that the order can work (after exchange ack)
	// before the server considers it timed out and cancels it (0 means 'never',
	// leaves order working until filled, cancelled, or expired).
	WorkingTimeout *uint32 `protobuf:"varint,2,req,name=working_timeout,json=workingTimeout" json:"working_timeout,omitempty"`
	// Type of order placed for the leg. One of MarketTakingLimitOrderType enums.
	OrderType        *uint32 `protobuf:"varint,3,req,name=order_type,json=orderType" json:"order_type,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *MarketTakingParameters) Reset()                    { *m = MarketTakingParameters{} }
func (m *MarketTakingParameters) String() string            { return proto.CompactTextString(m) }
func (*MarketTakingParameters) ProtoMessage()               {}
func (*MarketTakingParameters) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{111} }

func (m *MarketTakingParameters) GetAllocationPercent() float64 {
	if m != nil && m.AllocationPercent != nil {
		return *m.AllocationPercent
	}
	return 0
}

func (m *MarketTakingParameters) GetWorkingTimeout() uint32 {
	if m != nil && m.WorkingTimeout != nil {
		return *m.WorkingTimeout
	}
	return 0
}

func (m *MarketTakingParameters) GetOrderType() uint32 {
	if m != nil && m.OrderType != nil {
		return *m.OrderType
	}
	return 0
}

// Aggregation market making mode: the order is sent immediately to the exchanges based on the allocation percent.
// The server then manages the orders to get them filled as quickly as possible at the given price.
type MarketMakingParameters struct {
	// Allocation percent (in range 0...1) for the leg (doesn't have to total 100% allocation among all legs).
	// Default is 0, the market making mode is turned off for the leg.
	AllocationPercent *float64 `protobuf:"fixed64,1,opt,name=allocation_percent,json=allocationPercent" json:"allocation_percent,omitempty"`
	// Visible size in lots.
	VisibleQty *uint32 `protobuf:"varint,2,opt,name=visible_qty,json=visibleQty" json:"visible_qty,omitempty"`
	// Min visible size in lots.
	MinVisibleQty *uint32 `protobuf:"varint,3,opt,name=min_visible_qty,json=minVisibleQty" json:"min_visible_qty,omitempty"`
	// Visible size of native Iceberg.
	NativeVisibleQty *uint32 `protobuf:"varint,4,opt,name=native_visible_qty,json=nativeVisibleQty" json:"native_visible_qty,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *MarketMakingParameters) Reset()                    { *m = MarketMakingParameters{} }
func (m *MarketMakingParameters) String() string            { return proto.CompactTextString(m) }
func (*MarketMakingParameters) ProtoMessage()               {}
func (*MarketMakingParameters) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{112} }

func (m *MarketMakingParameters) GetAllocationPercent() float64 {
	if m != nil && m.AllocationPercent != nil {
		return *m.AllocationPercent
	}
	return 0
}

func (m *MarketMakingParameters) GetVisibleQty() uint32 {
	if m != nil && m.VisibleQty != nil {
		return *m.VisibleQty
	}
	return 0
}

func (m *MarketMakingParameters) GetMinVisibleQty() uint32 {
	if m != nil && m.MinVisibleQty != nil {
		return *m.MinVisibleQty
	}
	return 0
}

func (m *MarketMakingParameters) GetNativeVisibleQty() uint32 {
	if m != nil && m.NativeVisibleQty != nil {
		return *m.NativeVisibleQty
	}
	return 0
}

// Description of aggregation strategy legs.
type AggregationLegDescription struct {
	// Node index in the strategy definition the parameters are related to (LegDefinition.node_index value).
	NodeIndex *uint32 `protobuf:"varint,1,req,name=node_index,json=nodeIndex" json:"node_index,omitempty"`
	// Threshold value for available quotes quantity to be considered
	// (the quantities under this value are ignored).
	WorkingThreshold *uint32 `protobuf:"varint,2,opt,name=working_threshold,json=workingThreshold" json:"working_threshold,omitempty"`
	// The leg is executed in market taking mode.
	MarketTakingParameters *MarketTakingParameters `protobuf:"bytes,3,req,name=market_taking_parameters,json=marketTakingParameters" json:"market_taking_parameters,omitempty"`
	// The leg is executed in market making mode.
	MarketMakingParameters *MarketMakingParameters `protobuf:"bytes,4,req,name=market_making_parameters,json=marketMakingParameters" json:"market_making_parameters,omitempty"`
	XXX_unrecognized       []byte                  `json:"-"`
}

func (m *AggregationLegDescription) Reset()                    { *m = AggregationLegDescription{} }
func (m *AggregationLegDescription) String() string            { return proto.CompactTextString(m) }
func (*AggregationLegDescription) ProtoMessage()               {}
func (*AggregationLegDescription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{113} }

func (m *AggregationLegDescription) GetNodeIndex() uint32 {
	if m != nil && m.NodeIndex != nil {
		return *m.NodeIndex
	}
	return 0
}

func (m *AggregationLegDescription) GetWorkingThreshold() uint32 {
	if m != nil && m.WorkingThreshold != nil {
		return *m.WorkingThreshold
	}
	return 0
}

func (m *AggregationLegDescription) GetMarketTakingParameters() *MarketTakingParameters {
	if m != nil {
		return m.MarketTakingParameters
	}
	return nil
}

func (m *AggregationLegDescription) GetMarketMakingParameters() *MarketMakingParameters {
	if m != nil {
		return m.MarketMakingParameters
	}
	return nil
}

type StrategyAggregationParameters struct {
	// Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index).
	NodeIndex *uint32 `protobuf:"varint,1,req,name=node_index,json=nodeIndex" json:"node_index,omitempty"`
	// Mode of overfill handling. One of AggrOverfillMode enums
	OverfillMode *uint32 `protobuf:"varint,2,req,name=overfill_mode,json=overfillMode" json:"overfill_mode,omitempty"`
	// Price shifting parameters.
	PriceShifting *PriceShifting `protobuf:"bytes,3,opt,name=price_shifting,json=priceShifting" json:"price_shifting,omitempty"`
	// Aggregation legs parameters.
	PatternLegs      []*AggregationLegDescription `protobuf:"bytes,4,rep,name=pattern_legs,json=patternLegs" json:"pattern_legs,omitempty"`
	XXX_unrecognized []byte                       `json:"-"`
}

func (m *StrategyAggregationParameters) Reset()                    { *m = StrategyAggregationParameters{} }
func (m *StrategyAggregationParameters) String() string            { return proto.CompactTextString(m) }
func (*StrategyAggregationParameters) ProtoMessage()               {}
func (*StrategyAggregationParameters) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{114} }

func (m *StrategyAggregationParameters) GetNodeIndex() uint32 {
	if m != nil && m.NodeIndex != nil {
		return *m.NodeIndex
	}
	return 0
}

func (m *StrategyAggregationParameters) GetOverfillMode() uint32 {
	if m != nil && m.OverfillMode != nil {
		return *m.OverfillMode
	}
	return 0
}

func (m *StrategyAggregationParameters) GetPriceShifting() *PriceShifting {
	if m != nil {
		return m.PriceShifting
	}
	return nil
}

func (m *StrategyAggregationParameters) GetPatternLegs() []*AggregationLegDescription {
	if m != nil {
		return m.PatternLegs
	}
	return nil
}

// Defines how a placed synthetic strategy order will be executed.
type StrategyTradingParameters struct {
	// Parameters applied only to a MKT order.
	MarketOrderParameters []*StrategyMarketOrderParameters `protobuf:"bytes,1,rep,name=market_order_parameters,json=marketOrderParameters" json:"market_order_parameters,omitempty"`
	// Parameters applied only to a LMT order.
	LimitOrderParameters []*StrategyLimitOrderParameters `protobuf:"bytes,2,rep,name=limit_order_parameters,json=limitOrderParameters" json:"limit_order_parameters,omitempty"`
	// Parameters applied only to a STP order.
	StopOrderParameters []*StrategyStopOrderParameters `protobuf:"bytes,3,rep,name=stop_order_parameters,json=stopOrderParameters" json:"stop_order_parameters,omitempty"`
	// Parameters applied only to an aggregation strategy.
	AggregationParameters []*StrategyAggregationParameters `protobuf:"bytes,4,rep,name=aggregation_parameters,json=aggregationParameters" json:"aggregation_parameters,omitempty"`
	// Individual strategy leg parameters.
	LegParameters    []*StrategyOrderLegParameters `protobuf:"bytes,5,rep,name=leg_parameters,json=legParameters" json:"leg_parameters,omitempty"`
	XXX_unrecognized []byte                        `json:"-"`
}

func (m *StrategyTradingParameters) Reset()                    { *m = StrategyTradingParameters{} }
func (m *StrategyTradingParameters) String() string            { return proto.CompactTextString(m) }
func (*StrategyTradingParameters) ProtoMessage()               {}
func (*StrategyTradingParameters) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{115} }

func (m *StrategyTradingParameters) GetMarketOrderParameters() []*StrategyMarketOrderParameters {
	if m != nil {
		return m.MarketOrderParameters
	}
	return nil
}

func (m *StrategyTradingParameters) GetLimitOrderParameters() []*StrategyLimitOrderParameters {
	if m != nil {
		return m.LimitOrderParameters
	}
	return nil
}

func (m *StrategyTradingParameters) GetStopOrderParameters() []*StrategyStopOrderParameters {
	if m != nil {
		return m.StopOrderParameters
	}
	return nil
}

func (m *StrategyTradingParameters) GetAggregationParameters() []*StrategyAggregationParameters {
	if m != nil {
		return m.AggregationParameters
	}
	return nil
}

func (m *StrategyTradingParameters) GetLegParameters() []*StrategyOrderLegParameters {
	if m != nil {
		return m.LegParameters
	}
	return nil
}

// Status of a contract open positions and purchase and sales for a specific Username for the current day
// (contractId and accountId are used as a key for updates).
// Contract position is deleted when all open positions and purchase and sales groups are deleted.
type PositionStatus struct {
	// List of trade subscription IDs this Status is related to.
	SubscriptionId []uint32 `protobuf:"varint,1,rep,name=subscription_id,json=subscriptionId" json:"subscription_id,omitempty"`
	// True if this is a snapshot related message.
	// Since snapshot might be sent in several messages (including none), client should use TradeSnapshotCompletion message as
	// an indicator of complete snapshot delivery.
	IsSnapshot *bool `protobuf:"varint,2,opt,name=is_snapshot,json=isSnapshot" json:"is_snapshot,omitempty"`
	// Account this position belongs to.
	AccountId *int32 `protobuf:"zigzag32,3,req,name=account_id,json=accountId" json:"account_id,omitempty"`
	// Contract ID assigned by server.
	ContractId *uint32 `protobuf:"varint,4,req,name=contract_id,json=contractId" json:"contract_id,omitempty"`
	// True if open positions are short (result of sell operations), long otherwise.
	IsShortOpenPosition *bool `protobuf:"varint,5,req,name=is_short_open_position,json=isShortOpenPosition" json:"is_short_open_position,omitempty"`
	// List of new/ updated or deleted open positions.
	// NOTE: full list is sent only in a snapshot, updates include only added, changed and deleted records.
	OpenPosition []*OpenPosition `protobuf:"bytes,6,rep,name=open_position,json=openPosition" json:"open_position,omitempty"`
	// List of purchase and sales groups. This group represent offset trades (usually one sell and one buy)
	// NOTE: full list is sent only in a snapshot, updates include only added, changed and deleted records.
	PurchaseAndSalesGroup []*PurchaseAndSalesGroup `protobuf:"bytes,7,rep,name=purchase_and_sales_group,json=purchaseAndSalesGroup" json:"purchase_and_sales_group,omitempty"`
	// Multiple OrderStatus and PositionStatus messages in a single ServerMsg can reference the same contract.
	// If the contract is unknown to the client before this ServerMsg, contract meta-data will be added in at least one of them.
	// If in your code you process orders first and positions second then during processing orders you may
	// encounter order with yet unknown contract_id.
	// In this case you should look for matching contract metadata in positions.
	// The opposite is also true: contract metadata for positions can be in order Status messages.
	ContractMetadata *ContractMetadata `protobuf:"bytes,8,opt,name=contract_metadata,json=contractMetadata" json:"contract_metadata,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *PositionStatus) Reset()                    { *m = PositionStatus{} }
func (m *PositionStatus) String() string            { return proto.CompactTextString(m) }
func (*PositionStatus) ProtoMessage()               {}
func (*PositionStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{116} }

func (m *PositionStatus) GetSubscriptionId() []uint32 {
	if m != nil {
		return m.SubscriptionId
	}
	return nil
}

func (m *PositionStatus) GetIsSnapshot() bool {
	if m != nil && m.IsSnapshot != nil {
		return *m.IsSnapshot
	}
	return false
}

func (m *PositionStatus) GetAccountId() int32 {
	if m != nil && m.AccountId != nil {
		return *m.AccountId
	}
	return 0
}

func (m *PositionStatus) GetContractId() uint32 {
	if m != nil && m.ContractId != nil {
		return *m.ContractId
	}
	return 0
}

func (m *PositionStatus) GetIsShortOpenPosition() bool {
	if m != nil && m.IsShortOpenPosition != nil {
		return *m.IsShortOpenPosition
	}
	return false
}

func (m *PositionStatus) GetOpenPosition() []*OpenPosition {
	if m != nil {
		return m.OpenPosition
	}
	return nil
}

func (m *PositionStatus) GetPurchaseAndSalesGroup() []*PurchaseAndSalesGroup {
	if m != nil {
		return m.PurchaseAndSalesGroup
	}
	return nil
}

func (m *PositionStatus) GetContractMetadata() *ContractMetadata {
	if m != nil {
		return m.ContractMetadata
	}
	return nil
}

// Account and contract open position.
// There could be more than one position per Username and contract.
// (Id is used as a key for updates).
type OpenPosition struct {
	// Surrogate Id as a key for updates.
	Id *int32 `protobuf:"zigzag32,1,req,name=Id" json:"Id,omitempty"`
	// Position size, zero means that this position is deleted.
	Qty *uint32 `protobuf:"varint,2,req,name=qty" json:"qty,omitempty"`
	// Position average price.
	// NOTE: Since it could be an aggregated position price is sent in correct format directly.
	Price *float64 `protobuf:"fixed64,3,req,name=price" json:"price,omitempty"`
	// Exchange specific trade date when the position was open or last changed (date only value).
	TradeDate *int64 `protobuf:"zigzag64,4,req,name=trade_date,json=tradeDate" json:"trade_date,omitempty"`
	// Statement date (date value only).
	StatementDate *int64 `protobuf:"zigzag64,5,req,name=statement_date,json=statementDate" json:"statement_date,omitempty"`
	// UTC trade time (including date) if available, it might not be available e.g. for the previous day positions.
	TradeUtcTime *int64 `protobuf:"zigzag64,6,opt,name=trade_utc_time,json=tradeUtcTime" json:"trade_utc_time,omitempty"`
	// True if the price is an aggregated position price.
	IsAggregated     *bool  `protobuf:"varint,7,req,name=is_aggregated,json=isAggregated" json:"is_aggregated,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *OpenPosition) Reset()                    { *m = OpenPosition{} }
func (m *OpenPosition) String() string            { return proto.CompactTextString(m) }
func (*OpenPosition) ProtoMessage()               {}
func (*OpenPosition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{117} }

func (m *OpenPosition) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *OpenPosition) GetQty() uint32 {
	if m != nil && m.Qty != nil {
		return *m.Qty
	}
	return 0
}

func (m *OpenPosition) GetPrice() float64 {
	if m != nil && m.Price != nil {
		return *m.Price
	}
	return 0
}

func (m *OpenPosition) GetTradeDate() int64 {
	if m != nil && m.TradeDate != nil {
		return *m.TradeDate
	}
	return 0
}

func (m *OpenPosition) GetStatementDate() int64 {
	if m != nil && m.StatementDate != nil {
		return *m.StatementDate
	}
	return 0
}

func (m *OpenPosition) GetTradeUtcTime() int64 {
	if m != nil && m.TradeUtcTime != nil {
		return *m.TradeUtcTime
	}
	return 0
}

func (m *OpenPosition) GetIsAggregated() bool {
	if m != nil && m.IsAggregated != nil {
		return *m.IsAggregated
	}
	return false
}

// Purchase and sales group that represents offset trades (usually one sell and one buy trade)
type PurchaseAndSalesGroup struct {
	// Surrogate Id as a key for updates.
	Id *int32 `protobuf:"zigzag32,1,req,name=Id" json:"Id,omitempty"`
	// Profit/ loss (in contract Currency) of the group.
	RealizedProfitLoss *float64 `protobuf:"fixed64,2,req,name=realized_profit_loss,json=realizedProfitLoss" json:"realized_profit_loss,omitempty"`
	// list of matched trades in a group
	// in case of group updates the whole list is sent
	MatchedTrade     []*MatchedTrade `protobuf:"bytes,3,rep,name=matched_trade,json=matchedTrade" json:"matched_trade,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *PurchaseAndSalesGroup) Reset()                    { *m = PurchaseAndSalesGroup{} }
func (m *PurchaseAndSalesGroup) String() string            { return proto.CompactTextString(m) }
func (*PurchaseAndSalesGroup) ProtoMessage()               {}
func (*PurchaseAndSalesGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{118} }

func (m *PurchaseAndSalesGroup) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *PurchaseAndSalesGroup) GetRealizedProfitLoss() float64 {
	if m != nil && m.RealizedProfitLoss != nil {
		return *m.RealizedProfitLoss
	}
	return 0
}

func (m *PurchaseAndSalesGroup) GetMatchedTrade() []*MatchedTrade {
	if m != nil {
		return m.MatchedTrade
	}
	return nil
}

// Specific trade or position that is a part of a purchase and sales group.
// (Id is used as a key for updates).
type MatchedTrade struct {
	// Matched size.
	// Zero means matched trade is deleted.
	Qty *uint32 `protobuf:"varint,1,req,name=qty" json:"qty,omitempty"`
	// True if this is a short trade (e.g. result of sell operation), long otherwise.
	IsShort *bool `protobuf:"varint,2,opt,name=is_short,json=isShort" json:"is_short,omitempty"`
	// Trade or position average price.
	// NOTE: Since it could be an aggregated position price is sent in correct format directly.
	Price *float64 `protobuf:"fixed64,3,req,name=price" json:"price,omitempty"`
	// Trade date (date value only).
	TradeDate *int64 `protobuf:"zigzag64,4,req,name=trade_date,json=tradeDate" json:"trade_date,omitempty"`
	// Statement date (date value only).
	StatementDate *int64 `protobuf:"zigzag64,5,req,name=statement_date,json=statementDate" json:"statement_date,omitempty"`
	// UTC trade time (including date) if available, it might not be available e.g. for the previous day positions.
	TradeUtcTime *int64 `protobuf:"zigzag64,6,opt,name=trade_utc_time,json=tradeUtcTime" json:"trade_utc_time,omitempty"`
	// True if the price is an aggregated position price.
	IsAggregated     *bool  `protobuf:"varint,7,req,name=is_aggregated,json=isAggregated" json:"is_aggregated,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *MatchedTrade) Reset()                    { *m = MatchedTrade{} }
func (m *MatchedTrade) String() string            { return proto.CompactTextString(m) }
func (*MatchedTrade) ProtoMessage()               {}
func (*MatchedTrade) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{119} }

func (m *MatchedTrade) GetQty() uint32 {
	if m != nil && m.Qty != nil {
		return *m.Qty
	}
	return 0
}

func (m *MatchedTrade) GetIsShort() bool {
	if m != nil && m.IsShort != nil {
		return *m.IsShort
	}
	return false
}

func (m *MatchedTrade) GetPrice() float64 {
	if m != nil && m.Price != nil {
		return *m.Price
	}
	return 0
}

func (m *MatchedTrade) GetTradeDate() int64 {
	if m != nil && m.TradeDate != nil {
		return *m.TradeDate
	}
	return 0
}

func (m *MatchedTrade) GetStatementDate() int64 {
	if m != nil && m.StatementDate != nil {
		return *m.StatementDate
	}
	return 0
}

func (m *MatchedTrade) GetTradeUtcTime() int64 {
	if m != nil && m.TradeUtcTime != nil {
		return *m.TradeUtcTime
	}
	return 0
}

func (m *MatchedTrade) GetIsAggregated() bool {
	if m != nil && m.IsAggregated != nil {
		return *m.IsAggregated
	}
	return false
}

// Status of the collateral for a specific Username.
// An update is sent once it is changed, updates might be consolidated in case of frequent changes.
type CollateralStatus struct {
	// List of trade subscription IDs this Status is related to.
	SubscriptionId []uint32 `protobuf:"varint,1,rep,name=subscription_id,json=subscriptionId" json:"subscription_id,omitempty"`
	// True if this is a snapshot related message.
	// Since snapshot might be sent in several messages (including none), client should use TradeSnapshotCompletion message as
	// an indicator of complete snapshot delivery for a particular subscription.
	IsSnapshot *bool `protobuf:"varint,2,opt,name=is_snapshot,json=isSnapshot" json:"is_snapshot,omitempty"`
	// Account Id of this Status.
	AccountId *int32 `protobuf:"zigzag32,3,req,name=account_id,json=accountId" json:"account_id,omitempty"`
	// Currency code of margin and PP values (ISO 4217 based).
	Currency *string `protobuf:"bytes,4,req,name=Currency" json:"Currency,omitempty"`
	// Current total margin.
	TotalMargin *float64 `protobuf:"fixed64,5,req,name=total_margin,json=TotalMargin" json:"total_margin,omitempty"`
	// Available Username funds including balance, realized profit (or loss), collateral and credits.
	// OTE and MVO are included regarding the Username risk parameters.
	PurchasingPower *float64 `protobuf:"fixed64,6,req,name=purchasing_power,json=PurchasingPower" json:"purchasing_power,omitempty"`
	// Open trade equity, or potential profit (or loss) from futures and future-style options positions
	// based on opening price of the position and the current future trade/best bid/best ask
	// (regarding to the risk Username settings) or settlement price if trade is not available.
	// Included if purchasing power depends on it.
	Ote *float64 `protobuf:"fixed64,7,opt,name=ote" json:"ote,omitempty"`
	// Market value of options calculated as the current market trade/best bid/best ask of the option
	// (regarding to the risk Username settings) times the number of options
	// (positive for long options and negative for short options) in the portfolio.
	// Included if purchasing power depends on it.
	Mvo *float64 `protobuf:"fixed64,8,opt,name=Mvo" json:"Mvo,omitempty"`
	// Market value of futures calculated as the current market trade/best bid/best ask
	// (regarding to the risk Username settings) times the number of futures
	// (positive for long and negative for short) in the portfolio.
	// Included if applicable.
	Mvf *float64 `protobuf:"fixed64,10,opt,name=Mvf" json:"Mvf,omitempty"`
	// Allowable margin credit of the Username
	MarginCredit     *float64 `protobuf:"fixed64,9,opt,name=margin_credit,json=MarginCredit" json:"margin_credit,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *CollateralStatus) Reset()                    { *m = CollateralStatus{} }
func (m *CollateralStatus) String() string            { return proto.CompactTextString(m) }
func (*CollateralStatus) ProtoMessage()               {}
func (*CollateralStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{120} }

func (m *CollateralStatus) GetSubscriptionId() []uint32 {
	if m != nil {
		return m.SubscriptionId
	}
	return nil
}

func (m *CollateralStatus) GetIsSnapshot() bool {
	if m != nil && m.IsSnapshot != nil {
		return *m.IsSnapshot
	}
	return false
}

func (m *CollateralStatus) GetAccountId() int32 {
	if m != nil && m.AccountId != nil {
		return *m.AccountId
	}
	return 0
}

func (m *CollateralStatus) GetCurrency() string {
	if m != nil && m.Currency != nil {
		return *m.Currency
	}
	return ""
}

func (m *CollateralStatus) GetTotalMargin() float64 {
	if m != nil && m.TotalMargin != nil {
		return *m.TotalMargin
	}
	return 0
}

func (m *CollateralStatus) GetPurchasingPower() float64 {
	if m != nil && m.PurchasingPower != nil {
		return *m.PurchasingPower
	}
	return 0
}

func (m *CollateralStatus) GetOte() float64 {
	if m != nil && m.Ote != nil {
		return *m.Ote
	}
	return 0
}

func (m *CollateralStatus) GetMvo() float64 {
	if m != nil && m.Mvo != nil {
		return *m.Mvo
	}
	return 0
}

func (m *CollateralStatus) GetMvf() float64 {
	if m != nil && m.Mvf != nil {
		return *m.Mvf
	}
	return 0
}

func (m *CollateralStatus) GetMarginCredit() float64 {
	if m != nil && m.MarginCredit != nil {
		return *m.MarginCredit
	}
	return 0
}

// Request to resolve previously reported hung quantity on a synthetic strategy order by
// 1) placing orders to offset filled leg position(s) at current mkt price(s) and (simultaneously)
// 2) cancelling the hung quantity.
type SyntheticLiquidate struct {
	// Id of an Username that is used to place an order.
	AccountId *int32 `protobuf:"zigzag32,1,req,name=account_id,json=accountId" json:"account_id,omitempty"`
	// Order Id assigned by server after last modification.
	OrderId *string `protobuf:"bytes,2,req,name=order_id,json=orderId" json:"order_id,omitempty"`
	// Id of the hang from the SyntheticHang message.
	HangId *int32 `protobuf:"zigzag32,3,req,name=hang_id,json=hangId" json:"hang_id,omitempty"`
	// Client side time when a request was submitted (UTC).
	WhenUtcTime      *int64 `protobuf:"zigzag64,4,req,name=when_utc_time,json=whenUtcTime" json:"when_utc_time,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SyntheticLiquidate) Reset()                    { *m = SyntheticLiquidate{} }
func (m *SyntheticLiquidate) String() string            { return proto.CompactTextString(m) }
func (*SyntheticLiquidate) ProtoMessage()               {}
func (*SyntheticLiquidate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{121} }

func (m *SyntheticLiquidate) GetAccountId() int32 {
	if m != nil && m.AccountId != nil {
		return *m.AccountId
	}
	return 0
}

func (m *SyntheticLiquidate) GetOrderId() string {
	if m != nil && m.OrderId != nil {
		return *m.OrderId
	}
	return ""
}

func (m *SyntheticLiquidate) GetHangId() int32 {
	if m != nil && m.HangId != nil {
		return *m.HangId
	}
	return 0
}

func (m *SyntheticLiquidate) GetWhenUtcTime() int64 {
	if m != nil && m.WhenUtcTime != nil {
		return *m.WhenUtcTime
	}
	return 0
}

// Request to resolve previously reported hung quantity on a synthetic strategy order by
// 1) placing LMT orders to offset filled leg position(s) at their fill price(s) and (simultaneously)
// 2) cancelling the hung quantity.
type SyntheticScratch struct {
	// Id of an Username that is used to place an order.
	AccountId *int32 `protobuf:"zigzag32,1,req,name=account_id,json=accountId" json:"account_id,omitempty"`
	// Order Id assigned by server after last modification.
	OrderId *string `protobuf:"bytes,2,req,name=order_id,json=orderId" json:"order_id,omitempty"`
	// Id of the hang from the SyntheticHang message.
	HangId *int32 `protobuf:"zigzag32,3,req,name=hang_id,json=hangId" json:"hang_id,omitempty"`
	// Client side time when a request was submitted (UTC).
	WhenUtcTime      *int64 `protobuf:"zigzag64,4,req,name=when_utc_time,json=whenUtcTime" json:"when_utc_time,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SyntheticScratch) Reset()                    { *m = SyntheticScratch{} }
func (m *SyntheticScratch) String() string            { return proto.CompactTextString(m) }
func (*SyntheticScratch) ProtoMessage()               {}
func (*SyntheticScratch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{122} }

func (m *SyntheticScratch) GetAccountId() int32 {
	if m != nil && m.AccountId != nil {
		return *m.AccountId
	}
	return 0
}

func (m *SyntheticScratch) GetOrderId() string {
	if m != nil && m.OrderId != nil {
		return *m.OrderId
	}
	return ""
}

func (m *SyntheticScratch) GetHangId() int32 {
	if m != nil && m.HangId != nil {
		return *m.HangId
	}
	return 0
}

func (m *SyntheticScratch) GetWhenUtcTime() int64 {
	if m != nil && m.WhenUtcTime != nil {
		return *m.WhenUtcTime
	}
	return 0
}

// Modify an order to get an immediate fill
// (on either the entire order or previously reported hanging quantity on a synthetic strategy order).
type GoMarket struct {
	// Id of an Username that is used to place an order.
	AccountId *int32 `protobuf:"zigzag32,1,req,name=account_id,json=accountId" json:"account_id,omitempty"`
	// Order Id assigned by the server after the last modification.
	OrderId *string `protobuf:"bytes,2,req,name=order_id,json=orderId" json:"order_id,omitempty"`
	// Id of the hang from the SyntheticHang message, if this request applies to hung quantity on a synthetic strategy order;
	// Not set, if this request applies to the whole order.
	HangId *int32 `protobuf:"zigzag32,3,opt,name=hang_id,json=hangId" json:"hang_id,omitempty"`
	// Client side time when a request was submitted (UTC).
	WhenUtcTime      *int64 `protobuf:"zigzag64,4,req,name=when_utc_time,json=whenUtcTime" json:"when_utc_time,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *GoMarket) Reset()                    { *m = GoMarket{} }
func (m *GoMarket) String() string            { return proto.CompactTextString(m) }
func (*GoMarket) ProtoMessage()               {}
func (*GoMarket) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{123} }

func (m *GoMarket) GetAccountId() int32 {
	if m != nil && m.AccountId != nil {
		return *m.AccountId
	}
	return 0
}

func (m *GoMarket) GetOrderId() string {
	if m != nil && m.OrderId != nil {
		return *m.OrderId
	}
	return ""
}

func (m *GoMarket) GetHangId() int32 {
	if m != nil && m.HangId != nil {
		return *m.HangId
	}
	return 0
}

func (m *GoMarket) GetWhenUtcTime() int64 {
	if m != nil && m.WhenUtcTime != nil {
		return *m.WhenUtcTime
	}
	return 0
}

// Subscription to market data.
// If it is necessary to change subscription level client should send a new subscription request with the same ID
// but a new subscription level.
type MarketDataSubscription struct {
	// Contract ID to subscribe (see symbol resolution report).
	// This is client's responsibility to re-subscribe in case of symbol resolution update.
	ContractId *uint32 `protobuf:"varint,1,req,name=contract_id,json=contractId" json:"contract_id,omitempty"`
	// Subscription level.
	// This field is associated with Level enum type.
	Level *uint32 `protobuf:"varint,2,req,name=level" json:"level,omitempty"`
	// Defines market values array in real-time market data snapshot.
	// False or omitted means that snapshots will contain market values for current trading day only.
	// True means that snapshots will contain market values for several (up to 3) past trading days.
	IncludePastMarketValues *bool `protobuf:"varint,3,opt,name=include_past_market_values,json=includePastMarketValues" json:"include_past_market_values,omitempty"`
	// Optional Username cluster ID for Username specific data subscriptions.
	AccountClusterId *int64 `protobuf:"zigzag64,4,opt,name=account_cluster_id,json=accountClusterId" json:"account_cluster_id,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *MarketDataSubscription) Reset()                    { *m = MarketDataSubscription{} }
func (m *MarketDataSubscription) String() string            { return proto.CompactTextString(m) }
func (*MarketDataSubscription) ProtoMessage()               {}
func (*MarketDataSubscription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{124} }

func (m *MarketDataSubscription) GetContractId() uint32 {
	if m != nil && m.ContractId != nil {
		return *m.ContractId
	}
	return 0
}

func (m *MarketDataSubscription) GetLevel() uint32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *MarketDataSubscription) GetIncludePastMarketValues() bool {
	if m != nil && m.IncludePastMarketValues != nil {
		return *m.IncludePastMarketValues
	}
	return false
}

func (m *MarketDataSubscription) GetAccountClusterId() int64 {
	if m != nil && m.AccountClusterId != nil {
		return *m.AccountClusterId
	}
	return 0
}

// Subscription Status
type MarketDataSubscriptionStatus struct {
	// Subscription contract ID.
	ContractId *uint32 `protobuf:"varint,1,req,name=contract_id,json=contractId" json:"contract_id,omitempty"`
	// Subscription result.
	// This field is associated with StatusCode enum type.
	StatusCode *uint32 `protobuf:"varint,2,req,name=status_code,json=statusCode" json:"status_code,omitempty"`
	// Effective subscription level.
	// This field is associated with MarketDataSubscription.Level enum type.
	Level *uint32 `protobuf:"varint,3,req,name=level" json:"level,omitempty"`
	// Possible details of subscription failure.
	TextMessage *string `protobuf:"bytes,4,opt,name=text_message,json=textMessage" json:"text_message,omitempty"`
	// Account cluster ID for Username specific data subscriptions.
	AccountClusterId *int64 `protobuf:"zigzag64,5,opt,name=account_cluster_id,json=accountClusterId" json:"account_cluster_id,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *MarketDataSubscriptionStatus) Reset()                    { *m = MarketDataSubscriptionStatus{} }
func (m *MarketDataSubscriptionStatus) String() string            { return proto.CompactTextString(m) }
func (*MarketDataSubscriptionStatus) ProtoMessage()               {}
func (*MarketDataSubscriptionStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{125} }

func (m *MarketDataSubscriptionStatus) GetContractId() uint32 {
	if m != nil && m.ContractId != nil {
		return *m.ContractId
	}
	return 0
}

func (m *MarketDataSubscriptionStatus) GetStatusCode() uint32 {
	if m != nil && m.StatusCode != nil {
		return *m.StatusCode
	}
	return 0
}

func (m *MarketDataSubscriptionStatus) GetLevel() uint32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *MarketDataSubscriptionStatus) GetTextMessage() string {
	if m != nil && m.TextMessage != nil {
		return *m.TextMessage
	}
	return ""
}

func (m *MarketDataSubscriptionStatus) GetAccountClusterId() int64 {
	if m != nil && m.AccountClusterId != nil {
		return *m.AccountClusterId
	}
	return 0
}

// Real time data delivery.
// Snapshot is sent as the first message after subscription and may appear periodically when subscribed.
type RealTimeMarketData struct {
	// Contract ID assigned by server.
	ContractId *uint32 `protobuf:"varint,1,req,name=contract_id,json=contractId" json:"contract_id,omitempty"`
	// Contract quotes. DOM is updated by new volumes per price. zero volume is used to clean this price record from DOM
	Quote []*Quote `protobuf:"bytes,2,rep,name=quote" json:"quote,omitempty"`
	// True if this is a snapshot (all previously known quotes about this contract should be cleaned).
	IsSnapshot *bool `protobuf:"varint,3,opt,name=is_snapshot,json=isSnapshot" json:"is_snapshot,omitempty"`
	// Collapsing level that was applied by server.
	// NONE if the field is omitted.
	// This field is associated with RealTimeCollapsing.Level enum type.
	CollapsingLevel *uint32 `protobuf:"varint,4,opt,name=collapsing_level,json=collapsingLevel" json:"collapsing_level,omitempty"`
	// Market values of a contract (e.g. Open/High/Low/Close) for several past trading days.
	// Present in snapshots and in updates if some values are changed (only changed values are included in updates).
	MarketValues []*MarketValues `protobuf:"bytes,5,rep,name=market_values,json=marketValues" json:"market_values,omitempty"`
	// Account cluster ID for Username specific data subscriptions.
	AccountClusterId *int64 `protobuf:"zigzag64,6,opt,name=account_cluster_id,json=accountClusterId" json:"account_cluster_id,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RealTimeMarketData) Reset()                    { *m = RealTimeMarketData{} }
func (m *RealTimeMarketData) String() string            { return proto.CompactTextString(m) }
func (*RealTimeMarketData) ProtoMessage()               {}
func (*RealTimeMarketData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{126} }

func (m *RealTimeMarketData) GetContractId() uint32 {
	if m != nil && m.ContractId != nil {
		return *m.ContractId
	}
	return 0
}

func (m *RealTimeMarketData) GetQuote() []*Quote {
	if m != nil {
		return m.Quote
	}
	return nil
}

func (m *RealTimeMarketData) GetIsSnapshot() bool {
	if m != nil && m.IsSnapshot != nil {
		return *m.IsSnapshot
	}
	return false
}

func (m *RealTimeMarketData) GetCollapsingLevel() uint32 {
	if m != nil && m.CollapsingLevel != nil {
		return *m.CollapsingLevel
	}
	return 0
}

func (m *RealTimeMarketData) GetMarketValues() []*MarketValues {
	if m != nil {
		return m.MarketValues
	}
	return nil
}

func (m *RealTimeMarketData) GetAccountClusterId() int64 {
	if m != nil && m.AccountClusterId != nil {
		return *m.AccountClusterId
	}
	return 0
}

// Specific quote information
type Quote struct {
	// This field is associated with Type enum type.
	Type *uint32 `protobuf:"varint,1,req,name=type" json:"type,omitempty"`
	// Time of the quote (UTC).
	// It is set only if time of this quote is different from the previous one in the list of quotes.
	QuoteUtcTime *int64 `protobuf:"zigzag64,2,opt,name=quote_utc_time,json=quoteUtcTime" json:"quote_utc_time,omitempty"`
	// Quote price.
	Price *int32 `protobuf:"zigzag32,3,req,name=price" json:"price,omitempty"`
	// Quote volume (included for BBA only if volume is subscribed).
	// Zero volume for a bid or ask indicates it has been cleared.  It can be a best price and a part of DOM update.
	Volume *uint64 `protobuf:"varint,4,opt,name=volume" json:"volume,omitempty"`
	// This field is associated with Indicator enum type.
	Indicator        []uint32 `protobuf:"varint,5,rep,name=indicator" json:"indicator,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Quote) Reset()                    { *m = Quote{} }
func (m *Quote) String() string            { return proto.CompactTextString(m) }
func (*Quote) ProtoMessage()               {}
func (*Quote) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{127} }

func (m *Quote) GetType() uint32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *Quote) GetQuoteUtcTime() int64 {
	if m != nil && m.QuoteUtcTime != nil {
		return *m.QuoteUtcTime
	}
	return 0
}

func (m *Quote) GetPrice() int32 {
	if m != nil && m.Price != nil {
		return *m.Price
	}
	return 0
}

func (m *Quote) GetVolume() uint64 {
	if m != nil && m.Volume != nil {
		return *m.Volume
	}
	return 0
}

func (m *Quote) GetIndicator() []uint32 {
	if m != nil {
		return m.Indicator
	}
	return nil
}

// Market data values of a contract.
type MarketValues struct {
	// Open price.
	OpenPrice *int32 `protobuf:"zigzag32,1,opt,name=open_price,json=openPrice" json:"open_price,omitempty"`
	// High price.
	HighPrice *int32 `protobuf:"zigzag32,2,opt,name=high_price,json=highPrice" json:"high_price,omitempty"`
	// Low price.
	LowPrice *int32 `protobuf:"zigzag32,3,opt,name=low_price,json=lowPrice" json:"low_price,omitempty"`
	// Close price.
	ClosePrice *int32 `protobuf:"zigzag32,4,opt,name=close_price,json=closePrice" json:"close_price,omitempty"`
	// Yesterday settlement price.
	// NOTE: Available for current trading day only.
	YesterdaySettlement *int32 `protobuf:"zigzag32,5,opt,name=yesterday_settlement,json=yesterdaySettlement" json:"yesterday_settlement,omitempty"`
	// Contract total volume.
	TotalVolume *uint32 `protobuf:"varint,6,opt,name=total_volume,json=totalVolume" json:"total_volume,omitempty"`
	// Yesterday close price.
	// NOTE: Available for current trading day only.
	YesterdayClose *int32 `protobuf:"zigzag32,7,opt,name=yesterday_close,json=yesterdayClose" json:"yesterday_close,omitempty"`
	// Indicative open price.
	IndicativeOpen *int32 `protobuf:"zigzag32,8,opt,name=indicative_open,json=indicativeOpen" json:"indicative_open,omitempty"`
	// Day index the market values are related to.
	// 0 - current trading day, -1 - yesterday's trading day, etc.
	DayIndex *int32 `protobuf:"zigzag32,9,req,name=day_index,json=dayIndex" json:"day_index,omitempty"`
	// Open interest.
	OpenInterest *int32 `protobuf:"zigzag32,10,opt,name=open_interest,json=openInterest" json:"open_interest,omitempty"`
	// Contract tick volume.
	TickVolume *uint32 `protobuf:"varint,11,opt,name=tick_volume,json=tickVolume" json:"tick_volume,omitempty"`
	// Settlement price.
	Settlement       *int32 `protobuf:"zigzag32,12,opt,name=settlement" json:"settlement,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *MarketValues) Reset()                    { *m = MarketValues{} }
func (m *MarketValues) String() string            { return proto.CompactTextString(m) }
func (*MarketValues) ProtoMessage()               {}
func (*MarketValues) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{128} }

func (m *MarketValues) GetOpenPrice() int32 {
	if m != nil && m.OpenPrice != nil {
		return *m.OpenPrice
	}
	return 0
}

func (m *MarketValues) GetHighPrice() int32 {
	if m != nil && m.HighPrice != nil {
		return *m.HighPrice
	}
	return 0
}

func (m *MarketValues) GetLowPrice() int32 {
	if m != nil && m.LowPrice != nil {
		return *m.LowPrice
	}
	return 0
}

func (m *MarketValues) GetClosePrice() int32 {
	if m != nil && m.ClosePrice != nil {
		return *m.ClosePrice
	}
	return 0
}

func (m *MarketValues) GetYesterdaySettlement() int32 {
	if m != nil && m.YesterdaySettlement != nil {
		return *m.YesterdaySettlement
	}
	return 0
}

func (m *MarketValues) GetTotalVolume() uint32 {
	if m != nil && m.TotalVolume != nil {
		return *m.TotalVolume
	}
	return 0
}

func (m *MarketValues) GetYesterdayClose() int32 {
	if m != nil && m.YesterdayClose != nil {
		return *m.YesterdayClose
	}
	return 0
}

func (m *MarketValues) GetIndicativeOpen() int32 {
	if m != nil && m.IndicativeOpen != nil {
		return *m.IndicativeOpen
	}
	return 0
}

func (m *MarketValues) GetDayIndex() int32 {
	if m != nil && m.DayIndex != nil {
		return *m.DayIndex
	}
	return 0
}

func (m *MarketValues) GetOpenInterest() int32 {
	if m != nil && m.OpenInterest != nil {
		return *m.OpenInterest
	}
	return 0
}

func (m *MarketValues) GetTickVolume() uint32 {
	if m != nil && m.TickVolume != nil {
		return *m.TickVolume
	}
	return 0
}

func (m *MarketValues) GetSettlement() int32 {
	if m != nil && m.Settlement != nil {
		return *m.Settlement
	}
	return 0
}

// Read stored user attribute by name.
type ReadUserAttributeRequest struct {
	// ID of a request and optional subscription that should be unique enough to match responses and updates with corresponding requests.
	RequestId *uint32 `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	// List of names of requested attributes or expressions to match.
	// Empty list means requesting of all available user attributes
	AttributeName    []string `protobuf:"bytes,2,rep,name=attribute_name,json=attributeName" json:"attribute_name,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ReadUserAttributeRequest) Reset()                    { *m = ReadUserAttributeRequest{} }
func (m *ReadUserAttributeRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadUserAttributeRequest) ProtoMessage()               {}
func (*ReadUserAttributeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{129} }

func (m *ReadUserAttributeRequest) GetRequestId() uint32 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *ReadUserAttributeRequest) GetAttributeName() []string {
	if m != nil {
		return m.AttributeName
	}
	return nil
}

// Result with requested attributes.
type ReadUserAttributeResult struct {
	// Corresponding request ID
	RequestId *uint32 `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	// This field is associated with ResultCode enum type.
	ResultCode *uint32 `protobuf:"varint,2,req,name=result_code,json=resultCode" json:"result_code,omitempty"`
	// List of requested attributes.
	UserAttribute []*UserAttribute `protobuf:"bytes,3,rep,name=user_attribute,json=userAttribute" json:"user_attribute,omitempty"`
	// Optional failure details.
	TextMessage      *string `protobuf:"bytes,4,opt,name=text_message,json=textMessage" json:"text_message,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ReadUserAttributeResult) Reset()                    { *m = ReadUserAttributeResult{} }
func (m *ReadUserAttributeResult) String() string            { return proto.CompactTextString(m) }
func (*ReadUserAttributeResult) ProtoMessage()               {}
func (*ReadUserAttributeResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{130} }

func (m *ReadUserAttributeResult) GetRequestId() uint32 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *ReadUserAttributeResult) GetResultCode() uint32 {
	if m != nil && m.ResultCode != nil {
		return *m.ResultCode
	}
	return 0
}

func (m *ReadUserAttributeResult) GetUserAttribute() []*UserAttribute {
	if m != nil {
		return m.UserAttribute
	}
	return nil
}

func (m *ReadUserAttributeResult) GetTextMessage() string {
	if m != nil && m.TextMessage != nil {
		return *m.TextMessage
	}
	return ""
}

// Modify or delete user attributes.
type ModifyUserAttributeRequest struct {
	// ID of a request that should be unique enough to match responses with corresponding requests.
	RequestId *uint32 `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	// List of attributes to modify.
	UserAttribute    []*UserAttribute `protobuf:"bytes,2,rep,name=user_attribute,json=userAttribute" json:"user_attribute,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *ModifyUserAttributeRequest) Reset()                    { *m = ModifyUserAttributeRequest{} }
func (m *ModifyUserAttributeRequest) String() string            { return proto.CompactTextString(m) }
func (*ModifyUserAttributeRequest) ProtoMessage()               {}
func (*ModifyUserAttributeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{131} }

func (m *ModifyUserAttributeRequest) GetRequestId() uint32 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *ModifyUserAttributeRequest) GetUserAttribute() []*UserAttribute {
	if m != nil {
		return m.UserAttribute
	}
	return nil
}

// User attributes modification result.
type ModifyUserAttributeResult struct {
	// Corresponding request ID.
	RequestId *uint32 `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	// This field is associated with ResultCode enum type.
	ResultCode *uint32 `protobuf:"varint,2,req,name=result_code,json=resultCode" json:"result_code,omitempty"`
	// Optional failure details.
	TextMessage      *string `protobuf:"bytes,3,opt,name=text_message,json=textMessage" json:"text_message,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ModifyUserAttributeResult) Reset()                    { *m = ModifyUserAttributeResult{} }
func (m *ModifyUserAttributeResult) String() string            { return proto.CompactTextString(m) }
func (*ModifyUserAttributeResult) ProtoMessage()               {}
func (*ModifyUserAttributeResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{132} }

func (m *ModifyUserAttributeResult) GetRequestId() uint32 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *ModifyUserAttributeResult) GetResultCode() uint32 {
	if m != nil && m.ResultCode != nil {
		return *m.ResultCode
	}
	return 0
}

func (m *ModifyUserAttributeResult) GetTextMessage() string {
	if m != nil && m.TextMessage != nil {
		return *m.TextMessage
	}
	return ""
}

// Parameters for Time and Sales request.
type TimeAndSalesParameters struct {
	// contract Id for Time and Sales request.
	ContractId *uint32 `protobuf:"varint,1,req,name=contract_id,json=contractId" json:"contract_id,omitempty"`
	// This field is associated with Level enum type.
	Level *uint32 `protobuf:"varint,2,req,name=level" json:"level,omitempty"`
	// Time and Sales period time to start from.
	FromUtcTime *int64 `protobuf:"zigzag64,3,req,name=from_utc_time,json=fromUtcTime" json:"from_utc_time,omitempty"`
	// Optional Time and Sales period finish time.
	// Current server time is used if it is not specified.
	ToUtcTime        *int64 `protobuf:"zigzag64,4,opt,name=to_utc_time,json=toUtcTime" json:"to_utc_time,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TimeAndSalesParameters) Reset()                    { *m = TimeAndSalesParameters{} }
func (m *TimeAndSalesParameters) String() string            { return proto.CompactTextString(m) }
func (*TimeAndSalesParameters) ProtoMessage()               {}
func (*TimeAndSalesParameters) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{133} }

func (m *TimeAndSalesParameters) GetContractId() uint32 {
	if m != nil && m.ContractId != nil {
		return *m.ContractId
	}
	return 0
}

func (m *TimeAndSalesParameters) GetLevel() uint32 {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return 0
}

func (m *TimeAndSalesParameters) GetFromUtcTime() int64 {
	if m != nil && m.FromUtcTime != nil {
		return *m.FromUtcTime
	}
	return 0
}

func (m *TimeAndSalesParameters) GetToUtcTime() int64 {
	if m != nil && m.ToUtcTime != nil {
		return *m.ToUtcTime
	}
	return 0
}

// Time and sales request (30 days history limit).
type TimeAndSalesRequest struct {
	// Request ID, should be unique among currently processed requests.
	RequestId *uint32 `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	// parameters of a request, ignored for a DROP operation.
	TimeAndSalesParameters *TimeAndSalesParameters `protobuf:"bytes,2,opt,name=time_and_sales_parameters,json=timeAndSalesParameters" json:"time_and_sales_parameters,omitempty"`
	// This field is associated with RequestType enum type. GET operation is processed by default.
	RequestType      *uint32 `protobuf:"varint,3,opt,name=request_type,json=requestType" json:"request_type,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TimeAndSalesRequest) Reset()                    { *m = TimeAndSalesRequest{} }
func (m *TimeAndSalesRequest) String() string            { return proto.CompactTextString(m) }
func (*TimeAndSalesRequest) ProtoMessage()               {}
func (*TimeAndSalesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{134} }

func (m *TimeAndSalesRequest) GetRequestId() uint32 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *TimeAndSalesRequest) GetTimeAndSalesParameters() *TimeAndSalesParameters {
	if m != nil {
		return m.TimeAndSalesParameters
	}
	return nil
}

func (m *TimeAndSalesRequest) GetRequestType() uint32 {
	if m != nil && m.RequestType != nil {
		return *m.RequestType
	}
	return 0
}

type TimeAndSalesReport struct {
	// ID of a corresponding request.
	RequestId *uint32 `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	// This field is associated with ResultCode enum type.
	ResultCode *uint32 `protobuf:"varint,2,req,name=result_code,json=resultCode" json:"result_code,omitempty"`
	// List of the requested Time and Sales as quotes.
	// Note that in order to simplify linking of T&S with real time quotes by a client server will atomically include
	// all quotes with the same time-stamp into T&S without splitting the group.
	Quote []*Quote `protobuf:"bytes,3,rep,name=quote" json:"quote,omitempty"`
	// Time up to which the quotes were included into this report,
	// if there were several with the same time-stamp equal to this time then all are included into the report (UTC).
	// This time is set only for 'up-to-current' requests.
	UpToUtcTime *int64 `protobuf:"varint,4,opt,name=up_to_utc_time,json=upToUtcTime" json:"up_to_utc_time,omitempty"`
	// True means that requested data is complete at the moment, false means more report messages are expected for completeness.
	IsReportComplete *bool `protobuf:"varint,5,opt,name=is_report_complete,json=isReportComplete,def=1" json:"is_report_complete,omitempty"`
	// Optional failure details.
	TextMessage *string `protobuf:"bytes,6,opt,name=text_message,json=textMessage" json:"text_message,omitempty"`
	// Request contains dates partially outside of allowed historical data depth.
	Truncated        *bool  `protobuf:"varint,7,opt,name=truncated" json:"truncated,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TimeAndSalesReport) Reset()                    { *m = TimeAndSalesReport{} }
func (m *TimeAndSalesReport) String() string            { return proto.CompactTextString(m) }
func (*TimeAndSalesReport) ProtoMessage()               {}
func (*TimeAndSalesReport) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{135} }

const Default_TimeAndSalesReport_IsReportComplete bool = true

func (m *TimeAndSalesReport) GetRequestId() uint32 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *TimeAndSalesReport) GetResultCode() uint32 {
	if m != nil && m.ResultCode != nil {
		return *m.ResultCode
	}
	return 0
}

func (m *TimeAndSalesReport) GetQuote() []*Quote {
	if m != nil {
		return m.Quote
	}
	return nil
}

func (m *TimeAndSalesReport) GetUpToUtcTime() int64 {
	if m != nil && m.UpToUtcTime != nil {
		return *m.UpToUtcTime
	}
	return 0
}

func (m *TimeAndSalesReport) GetIsReportComplete() bool {
	if m != nil && m.IsReportComplete != nil {
		return *m.IsReportComplete
	}
	return Default_TimeAndSalesReport_IsReportComplete
}

func (m *TimeAndSalesReport) GetTextMessage() string {
	if m != nil && m.TextMessage != nil {
		return *m.TextMessage
	}
	return ""
}

func (m *TimeAndSalesReport) GetTruncated() bool {
	if m != nil && m.Truncated != nil {
		return *m.Truncated
	}
	return false
}

// Parameters of a time bar request.
type TimeBarParameters struct {
	// Contract Id for a bar request.
	ContractId *uint32 `protobuf:"varint,1,req,name=contract_id,json=contractId" json:"contract_id,omitempty"`
	// This field is associated with BarUnit enum type.
	BarUnit *uint32 `protobuf:"varint,2,req,name=bar_unit,json=barUnit" json:"bar_unit,omitempty"`
	// Number of units per a single bar for Intra-day bars (must be within 24 hours period).
	UnitsNumber *uint32 `protobuf:"varint,3,opt,name=units_number,json=unitsNumber" json:"units_number,omitempty"`
	// Bars period time to start from.
	FromUtcTime *int64 `protobuf:"zigzag64,4,req,name=from_utc_time,json=fromUtcTime" json:"from_utc_time,omitempty"`
	// Optional bars period finish time.
	// Current server time is used if it is not specified.
	ToUtcTime *int64 `protobuf:"zigzag64,5,opt,name=to_utc_time,json=toUtcTime" json:"to_utc_time,omitempty"`
	// Defines content of the close_price and settlement_price fields in TimeBar.
	// close_price is set to last price if the use_settlements is false or omitted, settlement_price is omitted.
	// settlement_price is set to trade date's settlement price (or omitted for today's bar, if contract did not yet settle) if the use_settlements is true, close_price is omitted.
	UseSettlements   *bool  `protobuf:"varint,6,opt,name=use_settlements,json=useSettlements" json:"use_settlements,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TimeBarParameters) Reset()                    { *m = TimeBarParameters{} }
func (m *TimeBarParameters) String() string            { return proto.CompactTextString(m) }
func (*TimeBarParameters) ProtoMessage()               {}
func (*TimeBarParameters) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{136} }

func (m *TimeBarParameters) GetContractId() uint32 {
	if m != nil && m.ContractId != nil {
		return *m.ContractId
	}
	return 0
}

func (m *TimeBarParameters) GetBarUnit() uint32 {
	if m != nil && m.BarUnit != nil {
		return *m.BarUnit
	}
	return 0
}

func (m *TimeBarParameters) GetUnitsNumber() uint32 {
	if m != nil && m.UnitsNumber != nil {
		return *m.UnitsNumber
	}
	return 0
}

func (m *TimeBarParameters) GetFromUtcTime() int64 {
	if m != nil && m.FromUtcTime != nil {
		return *m.FromUtcTime
	}
	return 0
}

func (m *TimeBarParameters) GetToUtcTime() int64 {
	if m != nil && m.ToUtcTime != nil {
		return *m.ToUtcTime
	}
	return 0
}

func (m *TimeBarParameters) GetUseSettlements() bool {
	if m != nil && m.UseSettlements != nil {
		return *m.UseSettlements
	}
	return false
}

// Request for time bars with optional subscription.
// Number of simultaneous bar update subscriptions is limited, 50 by default.
// In case of subscription updates are sent when a bar opens, closes or when it is corrected. Corrected bars are sent even
// if they are outside of requested time bounds. Range can be expanded with another request if needed.
// Bar also is updated upon expiration the update interval (1 second for Intra-day bars or 1 minute for Inter-day bars), if changed.
type TimeBarRequest struct {
	// request or subscription ID
	RequestId *uint32 `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	// parameters of a request, ignored for a DROP operation.
	TimeBarParameters *TimeBarParameters `protobuf:"bytes,2,opt,name=time_bar_parameters,json=timeBarParameters" json:"time_bar_parameters,omitempty"`
	// This field is associated with RequestType enum type. GET operation is processed by default.
	RequestType      *uint32 `protobuf:"varint,3,opt,name=request_type,json=requestType" json:"request_type,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TimeBarRequest) Reset()                    { *m = TimeBarRequest{} }
func (m *TimeBarRequest) String() string            { return proto.CompactTextString(m) }
func (*TimeBarRequest) ProtoMessage()               {}
func (*TimeBarRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{137} }

func (m *TimeBarRequest) GetRequestId() uint32 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *TimeBarRequest) GetTimeBarParameters() *TimeBarParameters {
	if m != nil {
		return m.TimeBarParameters
	}
	return nil
}

func (m *TimeBarRequest) GetRequestType() uint32 {
	if m != nil && m.RequestType != nil {
		return *m.RequestType
	}
	return 0
}

// Time bar.
type TimeBar struct {
	// Bar start time (UTC).
	BarUtcTime *int64 `protobuf:"zigzag64,1,req,name=bar_utc_time,json=barUtcTime" json:"bar_utc_time,omitempty"`
	// Open price.
	OpenPrice *int32 `protobuf:"zigzag32,2,opt,name=open_price,json=openPrice" json:"open_price,omitempty"`
	// High price.
	HighPrice *int32 `protobuf:"zigzag32,3,opt,name=high_price,json=highPrice" json:"high_price,omitempty"`
	// Low price.
	LowPrice *int32 `protobuf:"zigzag32,4,opt,name=low_price,json=lowPrice" json:"low_price,omitempty"`
	// Close or last price (if the bar is not closed yet).
	// It is omitted if the TimeBarParameters.use_settlements is true.
	ClosePrice *int32 `protobuf:"zigzag32,5,opt,name=close_price,json=closePrice" json:"close_price,omitempty"`
	// Bar volume.
	Volume *uint64 `protobuf:"varint,6,opt,name=volume" json:"volume,omitempty"`
	// Trade date (in time format), it is set only for the first bar in a requested period
	// and for each first bar of the following trade dates for intra-day bars. Trade date of the bar first day for multi-day bars.
	TradeDate *int64 `protobuf:"zigzag64,7,opt,name=trade_date,json=tradeDate" json:"trade_date,omitempty"`
	// Commodity volume where available, for multi-day bars only.
	CommodityVolume *uint64 `protobuf:"varint,8,opt,name=commodity_volume,json=commodityVolume" json:"commodity_volume,omitempty"`
	// Open interest, for multi-day bars only.
	OpenInterest *uint32 `protobuf:"varint,9,opt,name=open_interest,json=openInterest" json:"open_interest,omitempty"`
	// Commodity open interest, for multi-day bars only.
	CommodityOpenInterest *uint32 `protobuf:"varint,10,opt,name=commodity_open_interest,json=commodityOpenInterest" json:"commodity_open_interest,omitempty"`
	// Settlement price, for daily bars only.
	// It is omitted if the TimeBarParameters.use_settlements is false or omitted.
	SettlementPrice *int32 `protobuf:"zigzag32,11,opt,name=settlement_price,json=settlementPrice" json:"settlement_price,omitempty"`
	// Tick volume.
	TickVolume *uint64 `protobuf:"varint,12,opt,name=tick_volume,json=tickVolume" json:"tick_volume,omitempty"`
	// Commodity tick volume where available, for multi-day bars only.
	CommodityTickVolume *uint64 `protobuf:"varint,13,opt,name=commodity_tick_volume,json=commodityTickVolume" json:"commodity_tick_volume,omitempty"`
	XXX_unrecognized    []byte  `json:"-"`
}

func (m *TimeBar) Reset()                    { *m = TimeBar{} }
func (m *TimeBar) String() string            { return proto.CompactTextString(m) }
func (*TimeBar) ProtoMessage()               {}
func (*TimeBar) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{138} }

func (m *TimeBar) GetBarUtcTime() int64 {
	if m != nil && m.BarUtcTime != nil {
		return *m.BarUtcTime
	}
	return 0
}

func (m *TimeBar) GetOpenPrice() int32 {
	if m != nil && m.OpenPrice != nil {
		return *m.OpenPrice
	}
	return 0
}

func (m *TimeBar) GetHighPrice() int32 {
	if m != nil && m.HighPrice != nil {
		return *m.HighPrice
	}
	return 0
}

func (m *TimeBar) GetLowPrice() int32 {
	if m != nil && m.LowPrice != nil {
		return *m.LowPrice
	}
	return 0
}

func (m *TimeBar) GetClosePrice() int32 {
	if m != nil && m.ClosePrice != nil {
		return *m.ClosePrice
	}
	return 0
}

func (m *TimeBar) GetVolume() uint64 {
	if m != nil && m.Volume != nil {
		return *m.Volume
	}
	return 0
}

func (m *TimeBar) GetTradeDate() int64 {
	if m != nil && m.TradeDate != nil {
		return *m.TradeDate
	}
	return 0
}

func (m *TimeBar) GetCommodityVolume() uint64 {
	if m != nil && m.CommodityVolume != nil {
		return *m.CommodityVolume
	}
	return 0
}

func (m *TimeBar) GetOpenInterest() uint32 {
	if m != nil && m.OpenInterest != nil {
		return *m.OpenInterest
	}
	return 0
}

func (m *TimeBar) GetCommodityOpenInterest() uint32 {
	if m != nil && m.CommodityOpenInterest != nil {
		return *m.CommodityOpenInterest
	}
	return 0
}

func (m *TimeBar) GetSettlementPrice() int32 {
	if m != nil && m.SettlementPrice != nil {
		return *m.SettlementPrice
	}
	return 0
}

func (m *TimeBar) GetTickVolume() uint64 {
	if m != nil && m.TickVolume != nil {
		return *m.TickVolume
	}
	return 0
}

func (m *TimeBar) GetCommodityTickVolume() uint64 {
	if m != nil && m.CommodityTickVolume != nil {
		return *m.CommodityTickVolume
	}
	return 0
}

// Time bar data response or update.
// Each report contains set of bars. Reports related to a specific request ordered chronologically from the most recent one to the past.
// In case of subscription each report contains 'up_to_utc_time' field.
// Warning: bar updates are not synchronized with real time data so a real time quote that is included into
// a bar might be received either before or after the bar update, use time of a quote for possible real-time bar updates.
type TimeBarReport struct {
	// ID of a corresponding request or subscription.
	RequestId *uint32 `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	// This field is associated with StatusCode enum type.
	StatusCode *uint32 `protobuf:"varint,2,req,name=status_code,json=statusCode" json:"status_code,omitempty"`
	// List of time bars.
	TimeBar []*TimeBar `protobuf:"bytes,3,rep,name=time_bar,json=timeBar" json:"time_bar,omitempty"`
	// Time up to which the quotes were included into bars,
	// if there were several with the same time-stamp equal to this time then all are included into the last bar (UTC).
	// This time is set for 'up-to-current' bar requests and bar updates.
	UpToUtcTime *int64 `protobuf:"varint,4,opt,name=up_to_utc_time,json=upToUtcTime" json:"up_to_utc_time,omitempty"`
	// True means that requested data is complete at the moment, false means more report messages are expected for completeness.
	IsReportComplete *bool `protobuf:"varint,5,opt,name=is_report_complete,json=isReportComplete,def=1" json:"is_report_complete,omitempty"`
	// Optional failure details.
	TextMessage *string `protobuf:"bytes,6,opt,name=text_message,json=textMessage" json:"text_message,omitempty"`
	// Request contains dates partially outside of allowed historical data depth.
	Truncated        *bool  `protobuf:"varint,7,opt,name=truncated" json:"truncated,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TimeBarReport) Reset()                    { *m = TimeBarReport{} }
func (m *TimeBarReport) String() string            { return proto.CompactTextString(m) }
func (*TimeBarReport) ProtoMessage()               {}
func (*TimeBarReport) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{139} }

const Default_TimeBarReport_IsReportComplete bool = true

func (m *TimeBarReport) GetRequestId() uint32 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *TimeBarReport) GetStatusCode() uint32 {
	if m != nil && m.StatusCode != nil {
		return *m.StatusCode
	}
	return 0
}

func (m *TimeBarReport) GetTimeBar() []*TimeBar {
	if m != nil {
		return m.TimeBar
	}
	return nil
}

func (m *TimeBarReport) GetUpToUtcTime() int64 {
	if m != nil && m.UpToUtcTime != nil {
		return *m.UpToUtcTime
	}
	return 0
}

func (m *TimeBarReport) GetIsReportComplete() bool {
	if m != nil && m.IsReportComplete != nil {
		return *m.IsReportComplete
	}
	return Default_TimeBarReport_IsReportComplete
}

func (m *TimeBarReport) GetTextMessage() string {
	if m != nil && m.TextMessage != nil {
		return *m.TextMessage
	}
	return ""
}

func (m *TimeBarReport) GetTruncated() bool {
	if m != nil && m.Truncated != nil {
		return *m.Truncated
	}
	return false
}

// VolumeProfile request, 3 month history limit.
type VolumeProfileRequest struct {
	// request ID.
	RequestId *uint32 `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	// Request parameters.
	VolumeProfileParameters *VolumeProfileParameters `protobuf:"bytes,2,opt,name=volume_profile_parameters,json=volumeProfileParameters" json:"volume_profile_parameters,omitempty"`
	// This field is associated with RequestType enum type.
	// GET operation is processed by default.
	RequestType      *uint32 `protobuf:"varint,3,opt,name=request_type,json=requestType" json:"request_type,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *VolumeProfileRequest) Reset()                    { *m = VolumeProfileRequest{} }
func (m *VolumeProfileRequest) String() string            { return proto.CompactTextString(m) }
func (*VolumeProfileRequest) ProtoMessage()               {}
func (*VolumeProfileRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{140} }

func (m *VolumeProfileRequest) GetRequestId() uint32 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *VolumeProfileRequest) GetVolumeProfileParameters() *VolumeProfileParameters {
	if m != nil {
		return m.VolumeProfileParameters
	}
	return nil
}

func (m *VolumeProfileRequest) GetRequestType() uint32 {
	if m != nil && m.RequestType != nil {
		return *m.RequestType
	}
	return 0
}

// Parameters of a Volume Profile request.
type VolumeProfileParameters struct {
	// Contract Id for the volume profile request.
	ContractId *uint32 `protobuf:"varint,1,req,name=contract_id,json=contractId" json:"contract_id,omitempty"`
	// Both of the next two fields have to be set, otherwise the request will return a failure
	// Start of the time range for volume profile to be calculated for.
	StartUtcTime *int64 `protobuf:"zigzag64,2,opt,name=start_utc_time,json=startUtcTime" json:"start_utc_time,omitempty"`
	// Exclusive end of the time range for volume profile to be calculated for.
	EndUtcTime       *int64 `protobuf:"zigzag64,3,opt,name=end_utc_time,json=endUtcTime" json:"end_utc_time,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *VolumeProfileParameters) Reset()                    { *m = VolumeProfileParameters{} }
func (m *VolumeProfileParameters) String() string            { return proto.CompactTextString(m) }
func (*VolumeProfileParameters) ProtoMessage()               {}
func (*VolumeProfileParameters) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{141} }

func (m *VolumeProfileParameters) GetContractId() uint32 {
	if m != nil && m.ContractId != nil {
		return *m.ContractId
	}
	return 0
}

func (m *VolumeProfileParameters) GetStartUtcTime() int64 {
	if m != nil && m.StartUtcTime != nil {
		return *m.StartUtcTime
	}
	return 0
}

func (m *VolumeProfileParameters) GetEndUtcTime() int64 {
	if m != nil && m.EndUtcTime != nil {
		return *m.EndUtcTime
	}
	return 0
}

// VolumeProfile snapshot response.
type VolumeProfileReport struct {
	// ID of the volume profile request.
	RequestId *uint32 `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	// This field is associated with ResultCode enum type.
	ResultCode *uint32 `protobuf:"varint,2,req,name=result_code,json=resultCode" json:"result_code,omitempty"`
	// Volume profile snapshot items.
	VolumeProfileItems []*VolumeProfileItem `protobuf:"bytes,3,rep,name=volume_profile_items,json=volumeProfileItems" json:"volume_profile_items,omitempty"`
	// Time up to which the quotes were included into this report,
	// if there were several with the same time-stamp equal to this time
	// then all are included into the report (UTC).
	// This time is set only for requests with time range
	// that includes the current time.
	UpToUtcTime *int64 `protobuf:"varint,4,opt,name=up_to_utc_time,json=upToUtcTime" json:"up_to_utc_time,omitempty"`
	// Optional failure details.
	TextMessage *string `protobuf:"bytes,5,opt,name=text_message,json=textMessage" json:"text_message,omitempty"`
	// Request contains dates partially outside of allowed historical data depth.
	Truncated        *bool  `protobuf:"varint,6,opt,name=truncated" json:"truncated,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *VolumeProfileReport) Reset()                    { *m = VolumeProfileReport{} }
func (m *VolumeProfileReport) String() string            { return proto.CompactTextString(m) }
func (*VolumeProfileReport) ProtoMessage()               {}
func (*VolumeProfileReport) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{142} }

func (m *VolumeProfileReport) GetRequestId() uint32 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *VolumeProfileReport) GetResultCode() uint32 {
	if m != nil && m.ResultCode != nil {
		return *m.ResultCode
	}
	return 0
}

func (m *VolumeProfileReport) GetVolumeProfileItems() []*VolumeProfileItem {
	if m != nil {
		return m.VolumeProfileItems
	}
	return nil
}

func (m *VolumeProfileReport) GetUpToUtcTime() int64 {
	if m != nil && m.UpToUtcTime != nil {
		return *m.UpToUtcTime
	}
	return 0
}

func (m *VolumeProfileReport) GetTextMessage() string {
	if m != nil && m.TextMessage != nil {
		return *m.TextMessage
	}
	return ""
}

func (m *VolumeProfileReport) GetTruncated() bool {
	if m != nil && m.Truncated != nil {
		return *m.Truncated
	}
	return false
}

// Volume profile snapshot item.
type VolumeProfileItem struct {
	// Price (unique for each volume profile snapshot reported).
	Price *int32 `protobuf:"zigzag32,1,req,name=price" json:"price,omitempty"`
	// Total volume of all trades with this price for the time range asked.
	Volume           *uint64 `protobuf:"varint,2,req,name=volume" json:"volume,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *VolumeProfileItem) Reset()                    { *m = VolumeProfileItem{} }
func (m *VolumeProfileItem) String() string            { return proto.CompactTextString(m) }
func (*VolumeProfileItem) ProtoMessage()               {}
func (*VolumeProfileItem) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{143} }

func (m *VolumeProfileItem) GetPrice() int32 {
	if m != nil && m.Price != nil {
		return *m.Price
	}
	return 0
}

func (m *VolumeProfileItem) GetVolume() uint64 {
	if m != nil && m.Volume != nil {
		return *m.Volume
	}
	return 0
}

// Historical orders request.
type HistoricalOrdersRequest struct {
	// Only orders from specified business date (inclusively) is to be returned (date only value in time format).
	FromDate *int64 `protobuf:"zigzag64,1,req,name=from_date,json=fromDate" json:"from_date,omitempty"`
	// Only orders till specified business date (inclusively) is to be returned (date only value in time format).
	// Current business day if the field is omitted.
	ToDate *int64 `protobuf:"zigzag64,2,opt,name=to_date,json=toDate" json:"to_date,omitempty"`
	// Filter orders by Username. Not specifying any Username means all accounts of the user.
	AccountId        []int32 `protobuf:"zigzag32,3,rep,name=account_id,json=accountId" json:"account_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *HistoricalOrdersRequest) Reset()                    { *m = HistoricalOrdersRequest{} }
func (m *HistoricalOrdersRequest) String() string            { return proto.CompactTextString(m) }
func (*HistoricalOrdersRequest) ProtoMessage()               {}
func (*HistoricalOrdersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{144} }

func (m *HistoricalOrdersRequest) GetFromDate() int64 {
	if m != nil && m.FromDate != nil {
		return *m.FromDate
	}
	return 0
}

func (m *HistoricalOrdersRequest) GetToDate() int64 {
	if m != nil && m.ToDate != nil {
		return *m.ToDate
	}
	return 0
}

func (m *HistoricalOrdersRequest) GetAccountId() []int32 {
	if m != nil {
		return m.AccountId
	}
	return nil
}

// Response for historical orders request.
type HistoricalOrdersReport struct {
	// List of order statuses matching historical order filter.
	OrderStatus      []*OrderStatus `protobuf:"bytes,1,rep,name=order_status,json=orderStatus" json:"order_status,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *HistoricalOrdersReport) Reset()                    { *m = HistoricalOrdersReport{} }
func (m *HistoricalOrdersReport) String() string            { return proto.CompactTextString(m) }
func (*HistoricalOrdersReport) ProtoMessage()               {}
func (*HistoricalOrdersReport) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{145} }

func (m *HistoricalOrdersReport) GetOrderStatus() []*OrderStatus {
	if m != nil {
		return m.OrderStatus
	}
	return nil
}

func init() {
	proto.RegisterType((*ClientMsg)(nil), "main.ClientMsg")
	proto.RegisterType((*ServerMsg)(nil), "main.ServerMsg")
	proto.RegisterType((*RealTimeCollapsing)(nil), "main.RealTimeCollapsing")
	proto.RegisterType((*Logon)(nil), "main.Logon")
	proto.RegisterType((*LogonResult)(nil), "main.LogonResult")
	proto.RegisterType((*LogonRoutineClient)(nil), "main.LogonRoutineClient")
	proto.RegisterType((*LogonRoutineServer)(nil), "main.LogonRoutineServer")
	proto.RegisterType((*PasswordChangeRoutineClient)(nil), "main.PasswordChangeRoutineClient")
	proto.RegisterType((*PasswordChangeRoutineServer)(nil), "main.PasswordChangeRoutineServer")
	proto.RegisterType((*AbortRoutine)(nil), "main.AbortRoutine")
	proto.RegisterType((*LogonInit)(nil), "main.LogonInit")
	proto.RegisterType((*PasswordRequest)(nil), "main.PasswordRequest")
	proto.RegisterType((*PasswordResponse)(nil), "main.PasswordResponse")
	proto.RegisterType((*Encoding)(nil), "main.Encoding")
	proto.RegisterType((*EncodingParameter)(nil), "main.EncodingParameter")
	proto.RegisterType((*RestoreOrJoinSession)(nil), "main.RestoreOrJoinSession")
	proto.RegisterType((*RestoreOrJoinSessionResult)(nil), "main.RestoreOrJoinSessionResult")
	proto.RegisterType((*ConcurrentConnectionJoin)(nil), "main.ConcurrentConnectionJoin")
	proto.RegisterType((*Logoff)(nil), "main.Logoff")
	proto.RegisterType((*LoggedOff)(nil), "main.LoggedOff")
	proto.RegisterType((*PasswordChange)(nil), "main.PasswordChange")
	proto.RegisterType((*PasswordChangeResult)(nil), "main.PasswordChangeResult")
	proto.RegisterType((*ObtainDemoCredentials)(nil), "main.ObtainDemoCredentials")
	proto.RegisterType((*ObtainDemoCredentialsResult)(nil), "main.ObtainDemoCredentialsResult")
	proto.RegisterType((*UserMessage)(nil), "main.UserMessage")
	proto.RegisterType((*UserSessionStateRequest)(nil), "main.UserSessionStateRequest")
	proto.RegisterType((*UserSessionStateResult)(nil), "main.UserSessionStateResult")
	proto.RegisterType((*Ping)(nil), "main.Ping")
	proto.RegisterType((*Pong)(nil), "main.Pong")
	proto.RegisterType((*StrategyDefinition)(nil), "main.StrategyDefinition")
	proto.RegisterType((*ExchangeStrategy)(nil), "main.ExchangeStrategy")
	proto.RegisterType((*LegDefinition)(nil), "main.LegDefinition")
	proto.RegisterType((*NestedStrategy)(nil), "main.NestedStrategy")
	proto.RegisterType((*StrategyNodeDefinition)(nil), "main.StrategyNodeDefinition")
	proto.RegisterType((*TickSizeByPrice)(nil), "main.TickSizeByPrice")
	proto.RegisterType((*TickSizeByDateTillExpiration)(nil), "main.TickSizeByDateTillExpiration")
	proto.RegisterType((*ContractMetadata)(nil), "main.ContractMetadata")
	proto.RegisterType((*InformationRequest)(nil), "main.InformationRequest")
	proto.RegisterType((*InformationReport)(nil), "main.InformationReport")
	proto.RegisterType((*AccountsRequest)(nil), "main.AccountsRequest")
	proto.RegisterType((*AccountsReport)(nil), "main.AccountsReport")
	proto.RegisterType((*Brokerage)(nil), "main.Brokerage")
	proto.RegisterType((*SalesSeries)(nil), "main.SalesSeries")
	proto.RegisterType((*Account)(nil), "main.Account")
	proto.RegisterType((*SymbolResolutionRequest)(nil), "main.SymbolResolutionRequest")
	proto.RegisterType((*SymbolResolutionReport)(nil), "main.SymbolResolutionReport")
	proto.RegisterType((*LastStatementBalancesRequest)(nil), "main.LastStatementBalancesRequest")
	proto.RegisterType((*LastStatementBalancesReport)(nil), "main.LastStatementBalancesReport")
	proto.RegisterType((*Balance)(nil), "main.Balance")
	proto.RegisterType((*CurrencyRatesRequest)(nil), "main.CurrencyRatesRequest")
	proto.RegisterType((*CurrencyRatesReport)(nil), "main.CurrencyRatesReport")
	proto.RegisterType((*BrokerageCurrencyRates)(nil), "main.BrokerageCurrencyRates")
	proto.RegisterType((*CurrencyRate)(nil), "main.CurrencyRate")
	proto.RegisterType((*SessionInformationRequest)(nil), "main.SessionInformationRequest")
	proto.RegisterType((*SessionInformationReport)(nil), "main.SessionInformationReport")
	proto.RegisterType((*SessionSegment)(nil), "main.SessionSegment")
	proto.RegisterType((*SessionSchedule)(nil), "main.SessionSchedule")
	proto.RegisterType((*TradingDay)(nil), "main.TradingDay")
	proto.RegisterType((*SessionDay)(nil), "main.SessionDay")
	proto.RegisterType((*SessionHoliday)(nil), "main.SessionHoliday")
	proto.RegisterType((*SymbolsByUnderlyingRequest)(nil), "main.SymbolsByUnderlyingRequest")
	proto.RegisterType((*SymbolsByUnderlyingReport)(nil), "main.SymbolsByUnderlyingReport")
	proto.RegisterType((*ChildSymbolsRequest)(nil), "main.ChildSymbolsRequest")
	proto.RegisterType((*ChildSymbolsReport)(nil), "main.ChildSymbolsReport")
	proto.RegisterType((*AtTheMoneyStrikeRequest)(nil), "main.AtTheMoneyStrikeRequest")
	proto.RegisterType((*AtTheMoneyStrikeReport)(nil), "main.AtTheMoneyStrikeReport")
	proto.RegisterType((*SessionTimeRangeRequest)(nil), "main.SessionTimeRangeRequest")
	proto.RegisterType((*SessionTimeRangeReport)(nil), "main.SessionTimeRangeReport")
	proto.RegisterType((*SessionTimeRange)(nil), "main.SessionTimeRange")
	proto.RegisterType((*TradingDayTimeRangeRequest)(nil), "main.TradingDayTimeRangeRequest")
	proto.RegisterType((*TradingDayTimeRangeReport)(nil), "main.TradingDayTimeRangeReport")
	proto.RegisterType((*TradingDayTimeRange)(nil), "main.TradingDayTimeRange")
	proto.RegisterType((*Symbol)(nil), "main.Symbol")
	proto.RegisterType((*StrategyDefinitionRequest)(nil), "main.StrategyDefinitionRequest")
	proto.RegisterType((*StrategyDefinitionReport)(nil), "main.StrategyDefinitionReport")
	proto.RegisterType((*TradeSubscription)(nil), "main.TradeSubscription")
	proto.RegisterType((*TradeSubscriptionStatus)(nil), "main.TradeSubscriptionStatus")
	proto.RegisterType((*TradeSnapshotCompletion)(nil), "main.TradeSnapshotCompletion")
	proto.RegisterType((*OrderRequest)(nil), "main.OrderRequest")
	proto.RegisterType((*OrderRequestReject)(nil), "main.OrderRequestReject")
	proto.RegisterType((*NewOrder)(nil), "main.NewOrder")
	proto.RegisterType((*Order)(nil), "main.Order")
	proto.RegisterType((*UserAttribute)(nil), "main.UserAttribute")
	proto.RegisterType((*SyntheticStrategyProperties)(nil), "main.SyntheticStrategyProperties")
	proto.RegisterType((*ModifyOrder)(nil), "main.ModifyOrder")
	proto.RegisterType((*CancelOrder)(nil), "main.CancelOrder")
	proto.RegisterType((*ActivateOrder)(nil), "main.ActivateOrder")
	proto.RegisterType((*ModifyUserAttributes)(nil), "main.ModifyUserAttributes")
	proto.RegisterType((*NewCompoundOrder)(nil), "main.NewCompoundOrder")
	proto.RegisterType((*CompoundOrder)(nil), "main.CompoundOrder")
	proto.RegisterType((*CompoundOrderEntry)(nil), "main.CompoundOrderEntry")
	proto.RegisterType((*SuspendOrder)(nil), "main.SuspendOrder")
	proto.RegisterType((*OrderStatus)(nil), "main.OrderStatus")
	proto.RegisterType((*TransactionStatus)(nil), "main.TransactionStatus")
	proto.RegisterType((*Trade)(nil), "main.Trade")
	proto.RegisterType((*StrategyLegFill)(nil), "main.StrategyLegFill")
	proto.RegisterType((*SyntheticHang)(nil), "main.SyntheticHang")
	proto.RegisterType((*CompoundOrderStructure)(nil), "main.CompoundOrderStructure")
	proto.RegisterType((*CompoundOrderStructureEntry)(nil), "main.CompoundOrderStructureEntry")
	proto.RegisterType((*StrategyOrderLegParameters)(nil), "main.StrategyOrderLegParameters")
	proto.RegisterType((*StrategyMarketOrderParameters)(nil), "main.StrategyMarketOrderParameters")
	proto.RegisterType((*PrimaryOrdersLimit)(nil), "main.PrimaryOrdersLimit")
	proto.RegisterType((*PrimaryOrdersSniper)(nil), "main.PrimaryOrdersSniper")
	proto.RegisterType((*SecondaryOrdersLimit)(nil), "main.SecondaryOrdersLimit")
	proto.RegisterType((*SecondaryOrdersMarket)(nil), "main.SecondaryOrdersMarket")
	proto.RegisterType((*SecondaryOrdersPayUp)(nil), "main.SecondaryOrdersPayUp")
	proto.RegisterType((*SecondaryOrdersTrailing)(nil), "main.SecondaryOrdersTrailing")
	proto.RegisterType((*LimitOrderLegDescription)(nil), "main.LimitOrderLegDescription")
	proto.RegisterType((*PriceShifting)(nil), "main.PriceShifting")
	proto.RegisterType((*StrategyLimitOrderParameters)(nil), "main.StrategyLimitOrderParameters")
	proto.RegisterType((*StrategyStopOrderParameters)(nil), "main.StrategyStopOrderParameters")
	proto.RegisterType((*MarketTakingParameters)(nil), "main.MarketTakingParameters")
	proto.RegisterType((*MarketMakingParameters)(nil), "main.MarketMakingParameters")
	proto.RegisterType((*AggregationLegDescription)(nil), "main.AggregationLegDescription")
	proto.RegisterType((*StrategyAggregationParameters)(nil), "main.StrategyAggregationParameters")
	proto.RegisterType((*StrategyTradingParameters)(nil), "main.StrategyTradingParameters")
	proto.RegisterType((*PositionStatus)(nil), "main.PositionStatus")
	proto.RegisterType((*OpenPosition)(nil), "main.OpenPosition")
	proto.RegisterType((*PurchaseAndSalesGroup)(nil), "main.PurchaseAndSalesGroup")
	proto.RegisterType((*MatchedTrade)(nil), "main.MatchedTrade")
	proto.RegisterType((*CollateralStatus)(nil), "main.CollateralStatus")
	proto.RegisterType((*SyntheticLiquidate)(nil), "main.SyntheticLiquidate")
	proto.RegisterType((*SyntheticScratch)(nil), "main.SyntheticScratch")
	proto.RegisterType((*GoMarket)(nil), "main.GoMarket")
	proto.RegisterType((*MarketDataSubscription)(nil), "main.MarketDataSubscription")
	proto.RegisterType((*MarketDataSubscriptionStatus)(nil), "main.MarketDataSubscriptionStatus")
	proto.RegisterType((*RealTimeMarketData)(nil), "main.RealTimeMarketData")
	proto.RegisterType((*Quote)(nil), "main.Quote")
	proto.RegisterType((*MarketValues)(nil), "main.MarketValues")
	proto.RegisterType((*ReadUserAttributeRequest)(nil), "main.ReadUserAttributeRequest")
	proto.RegisterType((*ReadUserAttributeResult)(nil), "main.ReadUserAttributeResult")
	proto.RegisterType((*ModifyUserAttributeRequest)(nil), "main.ModifyUserAttributeRequest")
	proto.RegisterType((*ModifyUserAttributeResult)(nil), "main.ModifyUserAttributeResult")
	proto.RegisterType((*TimeAndSalesParameters)(nil), "main.TimeAndSalesParameters")
	proto.RegisterType((*TimeAndSalesRequest)(nil), "main.TimeAndSalesRequest")
	proto.RegisterType((*TimeAndSalesReport)(nil), "main.TimeAndSalesReport")
	proto.RegisterType((*TimeBarParameters)(nil), "main.TimeBarParameters")
	proto.RegisterType((*TimeBarRequest)(nil), "main.TimeBarRequest")
	proto.RegisterType((*TimeBar)(nil), "main.TimeBar")
	proto.RegisterType((*TimeBarReport)(nil), "main.TimeBarReport")
	proto.RegisterType((*VolumeProfileRequest)(nil), "main.VolumeProfileRequest")
	proto.RegisterType((*VolumeProfileParameters)(nil), "main.VolumeProfileParameters")
	proto.RegisterType((*VolumeProfileReport)(nil), "main.VolumeProfileReport")
	proto.RegisterType((*VolumeProfileItem)(nil), "main.VolumeProfileItem")
	proto.RegisterType((*HistoricalOrdersRequest)(nil), "main.HistoricalOrdersRequest")
	proto.RegisterType((*HistoricalOrdersReport)(nil), "main.HistoricalOrdersReport")
	proto.RegisterEnum("main.ProtocolVersionMajor", ProtocolVersionMajor_name, ProtocolVersionMajor_value)
	proto.RegisterEnum("main.ProtocolVersionMinor", ProtocolVersionMinor_name, ProtocolVersionMinor_value)
	proto.RegisterEnum("main.DayOfWeek", DayOfWeek_name, DayOfWeek_value)
	proto.RegisterEnum("main.RealTimeCollapsing_Level", RealTimeCollapsing_Level_name, RealTimeCollapsing_Level_value)
	proto.RegisterEnum("main.Logon_SessionSetting", Logon_SessionSetting_name, Logon_SessionSetting_value)
	proto.RegisterEnum("main.LogonResult_ResultCode", LogonResult_ResultCode_name, LogonResult_ResultCode_value)
	proto.RegisterEnum("main.PasswordRequest_PasswordType", PasswordRequest_PasswordType_name, PasswordRequest_PasswordType_value)
	proto.RegisterEnum("main.RestoreOrJoinSessionResult_ResultCode", RestoreOrJoinSessionResult_ResultCode_name, RestoreOrJoinSessionResult_ResultCode_value)
	proto.RegisterEnum("main.LoggedOff_LogoffReason", LoggedOff_LogoffReason_name, LoggedOff_LogoffReason_value)
	proto.RegisterEnum("main.PasswordChangeResult_ResultCode", PasswordChangeResult_ResultCode_name, PasswordChangeResult_ResultCode_value)
	proto.RegisterEnum("main.ObtainDemoCredentialsResult_ResultCode", ObtainDemoCredentialsResult_ResultCode_name, ObtainDemoCredentialsResult_ResultCode_value)
	proto.RegisterEnum("main.UserMessage_MessageType", UserMessage_MessageType_name, UserMessage_MessageType_value)
	proto.RegisterEnum("main.UserSessionStateResult_ResultCode", UserSessionStateResult_ResultCode_name, UserSessionStateResult_ResultCode_value)
	proto.RegisterEnum("main.StrategyDefinition_RoundLegMode", StrategyDefinition_RoundLegMode_name, StrategyDefinition_RoundLegMode_value)
	proto.RegisterEnum("main.StrategyNodeDefinition_NodeOperation", StrategyNodeDefinition_NodeOperation_name, StrategyNodeDefinition_NodeOperation_value)
	proto.RegisterEnum("main.ContractMetadata_MarginStyle", ContractMetadata_MarginStyle_name, ContractMetadata_MarginStyle_value)
	proto.RegisterEnum("main.InformationReport_StatusCode", InformationReport_StatusCode_name, InformationReport_StatusCode_value)
	proto.RegisterEnum("main.TradeSubscription_SubscriptionScope", TradeSubscription_SubscriptionScope_name, TradeSubscription_SubscriptionScope_value)
	proto.RegisterEnum("main.TradeSubscription_PublicationType", TradeSubscription_PublicationType_name, TradeSubscription_PublicationType_value)
	proto.RegisterEnum("main.TradeSubscription_MatchingAlgorithm", TradeSubscription_MatchingAlgorithm_name, TradeSubscription_MatchingAlgorithm_value)
	proto.RegisterEnum("main.TradeSubscriptionStatus_StatusCode", TradeSubscriptionStatus_StatusCode_name, TradeSubscriptionStatus_StatusCode_value)
	proto.RegisterEnum("main.Order_Side", Order_Side_name, Order_Side_value)
	proto.RegisterEnum("main.Order_OrderType", Order_OrderType_name, Order_OrderType_value)
	proto.RegisterEnum("main.Order_ExecInstruction", Order_ExecInstruction_name, Order_ExecInstruction_value)
	proto.RegisterEnum("main.Order_Duration", Order_Duration_name, Order_Duration_value)
	proto.RegisterEnum("main.Order_TrailingPeg", Order_TrailingPeg_name, Order_TrailingPeg_value)
	proto.RegisterEnum("main.CompoundOrder_Type", CompoundOrder_Type_name, CompoundOrder_Type_value)
	proto.RegisterEnum("main.OrderStatus_Status", OrderStatus_Status_name, OrderStatus_Status_value)
	proto.RegisterEnum("main.TransactionStatus_Status", TransactionStatus_Status_name, TransactionStatus_Status_value)
	proto.RegisterEnum("main.PrimaryOrdersLimit_FarFromMarketMode", PrimaryOrdersLimit_FarFromMarketMode_name, PrimaryOrdersLimit_FarFromMarketMode_value)
	proto.RegisterEnum("main.PrimaryOrdersLimit_DOMUsageMode", PrimaryOrdersLimit_DOMUsageMode_name, PrimaryOrdersLimit_DOMUsageMode_value)
	proto.RegisterEnum("main.PrimaryOrdersSniper_LegDuration", PrimaryOrdersSniper_LegDuration_name, PrimaryOrdersSniper_LegDuration_value)
	proto.RegisterEnum("main.StrategyLimitOrderParameters_OverfillMode", StrategyLimitOrderParameters_OverfillMode_name, StrategyLimitOrderParameters_OverfillMode_value)
	proto.RegisterEnum("main.StrategyLimitOrderParameters_AlignToStrategyLots", StrategyLimitOrderParameters_AlignToStrategyLots_name, StrategyLimitOrderParameters_AlignToStrategyLots_value)
	proto.RegisterEnum("main.StrategyLimitOrderParameters_PricingMethod", StrategyLimitOrderParameters_PricingMethod_name, StrategyLimitOrderParameters_PricingMethod_value)
	proto.RegisterEnum("main.StrategyStopOrderParameters_StopSide", StrategyStopOrderParameters_StopSide_name, StrategyStopOrderParameters_StopSide_value)
	proto.RegisterEnum("main.MarketTakingParameters_MarketTakingLimitOrderType", MarketTakingParameters_MarketTakingLimitOrderType_name, MarketTakingParameters_MarketTakingLimitOrderType_value)
	proto.RegisterEnum("main.StrategyAggregationParameters_AggrOverfillMode", StrategyAggregationParameters_AggrOverfillMode_name, StrategyAggregationParameters_AggrOverfillMode_value)
	proto.RegisterEnum("main.MarketDataSubscription_Level", MarketDataSubscription_Level_name, MarketDataSubscription_Level_value)
	proto.RegisterEnum("main.MarketDataSubscriptionStatus_StatusCode", MarketDataSubscriptionStatus_StatusCode_name, MarketDataSubscriptionStatus_StatusCode_value)
	proto.RegisterEnum("main.Quote_Type", Quote_Type_name, Quote_Type_value)
	proto.RegisterEnum("main.Quote_Indicator", Quote_Indicator_name, Quote_Indicator_value)
	proto.RegisterEnum("main.ReadUserAttributeResult_ResultCode", ReadUserAttributeResult_ResultCode_name, ReadUserAttributeResult_ResultCode_value)
	proto.RegisterEnum("main.ModifyUserAttributeResult_ResultCode", ModifyUserAttributeResult_ResultCode_name, ModifyUserAttributeResult_ResultCode_value)
	proto.RegisterEnum("main.TimeAndSalesParameters_Level", TimeAndSalesParameters_Level_name, TimeAndSalesParameters_Level_value)
	proto.RegisterEnum("main.TimeAndSalesRequest_RequestType", TimeAndSalesRequest_RequestType_name, TimeAndSalesRequest_RequestType_value)
	proto.RegisterEnum("main.TimeAndSalesReport_ResultCode", TimeAndSalesReport_ResultCode_name, TimeAndSalesReport_ResultCode_value)
	proto.RegisterEnum("main.TimeBarParameters_BarUnit", TimeBarParameters_BarUnit_name, TimeBarParameters_BarUnit_value)
	proto.RegisterEnum("main.TimeBarRequest_RequestType", TimeBarRequest_RequestType_name, TimeBarRequest_RequestType_value)
	proto.RegisterEnum("main.TimeBarReport_StatusCode", TimeBarReport_StatusCode_name, TimeBarReport_StatusCode_value)
	proto.RegisterEnum("main.VolumeProfileRequest_RequestType", VolumeProfileRequest_RequestType_name, VolumeProfileRequest_RequestType_value)
	proto.RegisterEnum("main.VolumeProfileReport_ResultCode", VolumeProfileReport_ResultCode_name, VolumeProfileReport_ResultCode_value)
}

func init() { proto.RegisterFile("webapi_1.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 12512 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0xbd, 0x6b, 0x8c, 0x24, 0x59,
	0x76, 0x10, 0xec, 0x7c, 0x55, 0x66, 0x9e, 0x7c, 0x54, 0xd4, 0xad, 0x57, 0x56, 0xf5, 0x63, 0xba,
	0x63, 0x66, 0x77, 0x7a, 0x67, 0x3c, 0xb3, 0xbb, 0xb3, 0xa3, 0x5d, 0xef, 0xac, 0x67, 0x77, 0xb3,
	0x33, 0xb3, 0xba, 0x73, 0x3a, 0x1f, 0x35, 0x91, 0x59, 0xdd, 0xdb, 0x6b, 0x7f, 0x5f, 0x6c, 0x54,
	0x66, 0x54, 0x56, 0x4c, 0x67, 0x46, 0xe4, 0x44, 0x44, 0x76, 0x4f, 0xad, 0x10, 0xb2, 0x2d, 0x24,
	0xc0, 0x16, 0x12, 0x46, 0xb2, 0xfc, 0xc3, 0x08, 0x04, 0xfc, 0xb0, 0xf9, 0xc5, 0xdb, 0x08, 0x84,
	0x8c, 0x65, 0xfb, 0x8f, 0x85, 0x85, 0x05, 0xc2, 0x02, 0x04, 0xbf, 0x40, 0x46, 0xda, 0x5f, 0x08,
	0x09, 0x24, 0x84, 0x84, 0x84, 0xee, 0xb9, 0xf7, 0x46, 0xdc, 0x78, 0x64, 0x55, 0xf5, 0xcc, 0x68,
	0x61, 0xff, 0xc5, 0x3d, 0xe7, 0xc6, 0x89, 0xfb, 0x38, 0xf7, 0xbc, 0xee, 0xb9, 0x37, 0xa0, 0xfe,
	0xc2, 0x3c, 0x35, 0x96, 0x96, 0xfe, 0xd5, 0xb7, 0x97, 0xae, 0xe3, 0x3b, 0x24, 0xbf, 0x30, 0x2c,
	0x5b, 0xfd, 0x0f, 0x00, 0xe5, 0xd6, 0xdc, 0x32, 0x6d, 0xbf, 0xef, 0xcd, 0xc8, 0x5d, 0x28, 0xcc,
	0x9d, 0x99, 0x63, 0x37, 0xa6, 0x77, 0x32, 0xf7, 0x2a, 0xef, 0x54, 0xde, 0xa6, 0x75, 0xde, 0xee,
	0x51, 0x90, 0xc6, 0x30, 0xe4, 0x43, 0xd8, 0x77, 0x4d, 0xcf, 0x77, 0x5c, 0x53, 0x77, 0x5c, 0xfd,
	0x23, 0xc7, 0xb2, 0x75, 0xcf, 0xf4, 0x3c, 0xcb, 0xb1, 0x1b, 0x26, 0xbe, 0x74, 0xc8, 0x5e, 0xd2,
	0x58, 0xa5, 0xa1, 0xfb, 0x81, 0x63, 0xd9, 0x23, 0x56, 0x43, 0xdb, 0x71, 0x53, 0xa0, 0xe4, 0x35,
	0xd8, 0xa0, 0xb4, 0xcf, 0xce, 0x1a, 0x67, 0x48, 0xa1, 0x1a, 0x7e, 0xf6, 0xec, 0x4c, 0xe3, 0x38,
	0xf2, 0x3e, 0x6c, 0x2e, 0x0d, 0xcf, 0x7b, 0xe1, 0xb8, 0x53, 0x7d, 0x72, 0x6e, 0xd8, 0x33, 0xb3,
	0x31, 0xc3, 0xea, 0x3b, 0xac, 0xfa, 0x31, 0x47, 0xb6, 0x10, 0xa7, 0xd5, 0x97, 0x91, 0x32, 0x19,
	0xc1, 0xbe, 0x73, 0xea, 0x1b, 0x96, 0xad, 0x4f, 0xcd, 0x85, 0xa3, 0x4f, 0x5c, 0x73, 0x6a, 0xda,
	0xbe, 0x65, 0xcc, 0xbd, 0xc6, 0x39, 0x92, 0xb9, 0xc1, 0xc8, 0x0c, 0xb1, 0x52, 0xdb, 0x5c, 0x38,
	0xad, 0xb0, 0x8a, 0xb6, 0xeb, 0xa4, 0x81, 0xc9, 0xf7, 0xe1, 0x70, 0xe5, 0x99, 0xae, 0x18, 0x01,
	0xdd, 0xf3, 0x0d, 0xdf, 0xd4, 0x5d, 0xf3, 0xe3, 0x95, 0xe9, 0xf9, 0x0d, 0x0b, 0xe9, 0xde, 0x62,
	0x74, 0x4f, 0x3c, 0xd3, 0xe5, 0x1d, 0x1e, 0xd1, 0x5a, 0x1a, 0xab, 0xa4, 0xed, 0xaf, 0xd2, 0x11,
	0xe4, 0x36, 0xe4, 0x97, 0x96, 0x3d, 0x6b, 0x3c, 0x43, 0x2a, 0xc0, 0x3b, 0x69, 0xd9, 0x33, 0x0d,
	0xe1, 0x88, 0x77, 0xec, 0x59, 0x63, 0x1e, 0xc1, 0x3b, 0x88, 0x77, 0xec, 0x19, 0xf9, 0x00, 0x76,
	0x70, 0xc6, 0x74, 0xd7, 0x59, 0xf9, 0x96, 0x6d, 0xea, 0x13, 0x9c, 0xe6, 0xc6, 0x02, 0xeb, 0x37,
	0xe4, 0xa9, 0x65, 0x15, 0x18, 0x1b, 0x68, 0x64, 0x9e, 0x80, 0x91, 0x33, 0xb8, 0x1d, 0x1b, 0xfb,
	0x38, 0x55, 0x1b, 0xa9, 0xde, 0x4d, 0x9d, 0x8a, 0x08, 0xf9, 0x1b, 0xcb, 0xf5, 0x48, 0xd2, 0x85,
	0x6d, 0xcb, 0x3e, 0x73, 0xdc, 0x85, 0xe1, 0xd3, 0xe1, 0x14, 0x03, 0x99, 0xb9, 0x93, 0x0b, 0x9b,
	0xdc, 0x0d, 0x2b, 0x88, 0x31, 0x24, 0x56, 0x02, 0x46, 0x8e, 0x80, 0xf8, 0xae, 0x31, 0x35, 0x75,
	0x6f, 0x75, 0xea, 0x4d, 0x5c, 0x6b, 0x49, 0x91, 0x8d, 0x2c, 0x52, 0xda, 0x67, 0x94, 0xc6, 0x14,
	0x3f, 0x92, 0xd0, 0xda, 0x96, 0x1f, 0x07, 0x91, 0x6f, 0x40, 0xcd, 0x71, 0xa7, 0xa6, 0x1b, 0x34,
	0x26, 0x87, 0x24, 0x08, 0xe7, 0x16, 0x8a, 0x12, 0xcd, 0xa8, 0x3a, 0x52, 0x89, 0x3c, 0x86, 0xc6,
	0xc2, 0x70, 0x9f, 0x99, 0xbe, 0x3e, 0x35, 0x7c, 0x23, 0xda, 0x8c, 0x3c, 0xd2, 0xb8, 0xc9, 0x68,
	0xf4, 0xb1, 0x56, 0xdb, 0xf0, 0x8d, 0x48, 0x5b, 0xf6, 0x16, 0xa9, 0x70, 0xf2, 0xff, 0xc1, 0x0d,
	0xd7, 0x34, 0xa6, 0x3a, 0x32, 0x9e, 0xe1, 0xfb, 0xae, 0x75, 0xba, 0x92, 0x98, 0xae, 0x80, 0xa4,
	0x6f, 0x8b, 0x45, 0x68, 0x4c, 0x29, 0xe3, 0x35, 0x45, 0x35, 0xd1, 0xd4, 0x86, 0xbb, 0x06, 0x43,
	0x26, 0x70, 0x6b, 0xe1, 0x4c, 0xad, 0xb3, 0x8b, 0x75, 0x1f, 0xd8, 0xc0, 0x0f, 0xdc, 0xe1, 0x6d,
	0xc7, 0xaa, 0xa9, 0x9f, 0x38, 0x5c, 0xac, 0xc5, 0x91, 0x01, 0xec, 0xf9, 0xd6, 0xc2, 0xd4, 0x0d,
	0x7b, 0xaa, 0x7b, 0xc6, 0xdc, 0xf4, 0x02, 0xea, 0x45, 0xa4, 0x7e, 0xc0, 0x27, 0xc8, 0x5a, 0x98,
	0x4d, 0x7b, 0x3a, 0xa2, 0x35, 0x04, 0xd9, 0x6d, 0x3f, 0x09, 0x24, 0xdf, 0x06, 0x05, 0xe9, 0x9d,
	0x1a, 0xe1, 0x3c, 0x95, 0x90, 0xd2, 0x4e, 0x48, 0xe9, 0xbe, 0x11, 0xcc, 0x54, 0xdd, 0x8f, 0x94,
	0xc9, 0x31, 0xec, 0x3d, 0x77, 0xe6, 0xab, 0x85, 0xa9, 0x2f, 0x5d, 0xe7, 0xcc, 0x9a, 0x87, 0xbd,
	0x2d, 0x23, 0x15, 0x2e, 0xd3, 0x1e, 0x63, 0x9d, 0x63, 0x56, 0x45, 0xd0, 0xda, 0x79, 0x9e, 0x02,
	0x7d, 0x23, 0x5f, 0x7a, 0x47, 0x99, 0xaa, 0xff, 0x62, 0x13, 0xca, 0x23, 0xd3, 0x7d, 0x6e, 0xba,
	0x54, 0xba, 0xbe, 0x0b, 0x55, 0xbe, 0x22, 0x4d, 0x6f, 0x35, 0xf7, 0xb9, 0x90, 0xdd, 0x92, 0x57,
	0x22, 0x22, 0xb4, 0xca, 0x3c, 0x2c, 0x90, 0x29, 0xdc, 0x5e, 0x23, 0x70, 0x05, 0x1d, 0x26, 0x77,
	0xef, 0x5c, 0x22, 0x77, 0x19, 0xd9, 0x43, 0x77, 0x2d, 0x8e, 0xfc, 0x3c, 0x1c, 0x4e, 0x1c, 0x7b,
	0xb2, 0x72, 0x5d, 0xd3, 0xf6, 0xf5, 0x89, 0x63, 0xdb, 0xe6, 0x04, 0xd7, 0x20, 0xfd, 0x60, 0xc3,
	0x91, 0x99, 0xaa, 0x15, 0xd4, 0x6b, 0x05, 0xd5, 0x28, 0x41, 0xad, 0x31, 0x59, 0x83, 0x21, 0x6f,
	0x03, 0xcc, 0x9d, 0xd9, 0xcc, 0x9c, 0xea, 0xa1, 0x94, 0xdf, 0x0c, 0xfa, 0x3d, 0x33, 0xa7, 0xc3,
	0xb3, 0x33, 0xad, 0x3c, 0x17, 0x8f, 0x74, 0x3e, 0x12, 0xf2, 0x86, 0xf5, 0x75, 0x26, 0xeb, 0x98,
	0x98, 0x9c, 0x61, 0xbd, 0xdc, 0x59, 0xa6, 0x40, 0xe9, 0xd8, 0x23, 0x3f, 0x2f, 0x4c, 0xcf, 0x33,
	0x66, 0x66, 0xe3, 0x1c, 0x7b, 0xb4, 0x15, 0xca, 0xe6, 0x3e, 0x43, 0x68, 0x95, 0x55, 0x58, 0xa0,
	0x72, 0x6f, 0x8d, 0xd2, 0x10, 0xed, 0xb1, 0x90, 0xce, 0xdd, 0xcb, 0x74, 0x07, 0x6b, 0xd6, 0x0d,
	0x67, 0x3d, 0x92, 0x3c, 0x81, 0x83, 0x54, 0x3d, 0x82, 0x9f, 0xf8, 0x48, 0x16, 0x16, 0x49, 0x35,
	0x82, 0xd4, 0xf7, 0x56, 0xa9, 0xf0, 0xcf, 0x5f, 0x89, 0x78, 0xc8, 0xcd, 0xeb, 0x95, 0x08, 0xe3,
	0xf6, 0xa8, 0x12, 0x61, 0xb0, 0xcb, 0x94, 0x08, 0xa7, 0x7a, 0xb5, 0x12, 0xe1, 0xe4, 0xd3, 0x95,
	0x08, 0xff, 0xce, 0x11, 0x90, 0xa8, 0x12, 0x59, 0x3a, 0xae, 0xd0, 0x21, 0xfb, 0x29, 0x3a, 0x84,
	0xa2, 0xb5, 0x2d, 0x2b, 0x0e, 0xa2, 0x7d, 0x8f, 0x48, 0x7e, 0xdd, 0x35, 0x3f, 0x32, 0x27, 0x3e,
	0xd7, 0x21, 0x8d, 0x14, 0x05, 0x80, 0x78, 0x8d, 0x38, 0x09, 0x18, 0x79, 0x0a, 0x07, 0x49, 0x6d,
	0x84, 0xd3, 0xbc, 0xf2, 0xb8, 0x46, 0xb9, 0xb5, 0x46, 0x29, 0x8d, 0xb0, 0x92, 0xb6, 0xef, 0xa7,
	0x23, 0x24, 0xd2, 0xb6, 0xb1, 0xf4, 0xce, 0x1d, 0xba, 0x7a, 0x17, 0xcb, 0xb9, 0x29, 0x29, 0x9a,
	0x08, 0x69, 0x5e, 0xab, 0x15, 0x54, 0x12, 0xa4, 0x13, 0x08, 0xba, 0x68, 0xd8, 0x08, 0xf0, 0x86,
	0x16, 0xe4, 0x45, 0x83, 0x3d, 0xe7, 0x8d, 0xab, 0x38, 0x61, 0x01, 0x0d, 0x35, 0xc7, 0xb3, 0xe4,
	0x1e, 0x6e, 0xc8, 0xb2, 0xf8, 0x98, 0x23, 0xf9, 0xbb, 0xf5, 0x65, 0xa4, 0x4c, 0x5a, 0xb0, 0x35,
	0x71, 0xe6, 0x73, 0xc3, 0x37, 0x5d, 0x63, 0x2e, 0x08, 0x30, 0xb5, 0xb0, 0x27, 0x04, 0x90, 0x40,
	0x73, 0x12, 0xca, 0x24, 0x06, 0x21, 0x16, 0xbc, 0xb2, 0x4e, 0xf9, 0x0a, 0x92, 0x4c, 0x3f, 0xa8,
	0x97, 0xe9, 0x60, 0x4e, 0xfe, 0xe6, 0xe2, 0x12, 0x2c, 0x79, 0x04, 0xbb, 0xae, 0x69, 0xcc, 0x75,
	0x54, 0x40, 0xd2, 0x47, 0xb9, 0xea, 0x68, 0x04, 0x9a, 0x78, 0x4e, 0x95, 0x50, 0xf8, 0x21, 0x8d,
	0xb8, 0x09, 0x18, 0x35, 0x28, 0xd3, 0x95, 0x3b, 0x4a, 0x02, 0x90, 0x67, 0x33, 0x45, 0xb7, 0xa3,
	0x28, 0xd8, 0x77, 0xd3, 0x11, 0xe4, 0x07, 0x70, 0x73, 0x9d, 0x66, 0x47, 0xea, 0x15, 0xa4, 0xfe,
	0xca, 0x25, 0x8a, 0x1d, 0xe9, 0x1f, 0x2c, 0xd6, 0xa1, 0xe8, 0x50, 0x24, 0xd4, 0x3a, 0x2e, 0xbe,
	0xaa, 0x3c, 0x14, 0x51, 0xad, 0x8e, 0xab, 0x8f, 0xf8, 0x09, 0x18, 0xf9, 0x16, 0x6c, 0x4a, 0x3a,
	0x1d, 0xc9, 0xd4, 0x90, 0xcc, 0x76, 0x4c, 0xa5, 0x23, 0x85, 0x9a, 0x2f, 0x17, 0x49, 0x1f, 0x76,
	0x13, 0x0a, 0x1d, 0x49, 0xd4, 0x65, 0xfb, 0x22, 0xa6, 0xcf, 0x91, 0xd0, 0xf6, 0xf3, 0x24, 0x90,
	0x6b, 0xf3, 0x0f, 0x81, 0x88, 0x69, 0x44, 0x16, 0x5c, 0x7a, 0x96, 0x3d, 0x53, 0xbf, 0x05, 0x85,
	0x9e, 0xf9, 0xdc, 0x9c, 0x93, 0x12, 0xe4, 0x07, 0xc3, 0x41, 0x47, 0xf9, 0x29, 0x52, 0x84, 0x5c,
	0x7b, 0xd8, 0x57, 0x32, 0xa4, 0x02, 0xc5, 0xf6, 0xb0, 0xaf, 0xdf, 0xbf, 0xdf, 0x54, 0xb2, 0x84,
	0x40, 0x9d, 0x17, 0xf4, 0xb1, 0xd6, 0x6c, 0x77, 0x46, 0x4a, 0x4e, 0xfd, 0x77, 0x79, 0x28, 0xa0,
	0xf8, 0x24, 0x37, 0xa0, 0x8c, 0xd3, 0x62, 0x1b, 0x0b, 0xb3, 0x91, 0xb9, 0x93, 0xbd, 0x57, 0xd6,
	0x4a, 0x14, 0x30, 0x30, 0x16, 0x26, 0x39, 0x84, 0x92, 0x90, 0x78, 0x8d, 0x2c, 0xc3, 0x89, 0x32,
	0x79, 0x03, 0xb6, 0x1c, 0xdb, 0x64, 0xec, 0x17, 0x54, 0xca, 0xdd, 0xc9, 0xdc, 0x2b, 0x6b, 0x9b,
	0x8e, 0x6d, 0xd2, 0xd6, 0x0a, 0x51, 0x4a, 0x5e, 0x85, 0xda, 0xd2, 0xb5, 0x9e, 0x53, 0xe5, 0x32,
	0x37, 0x4e, 0xcd, 0x79, 0x23, 0x8f, 0xf5, 0xaa, 0x1c, 0xd8, 0xa3, 0x30, 0xa2, 0x42, 0x8d, 0x19,
	0xf5, 0xba, 0xb1, 0x5c, 0xea, 0xd6, 0xb4, 0x51, 0xc0, 0x2f, 0x56, 0x18, 0xb0, 0xb9, 0x5c, 0x76,
	0xa7, 0xe4, 0x0b, 0x50, 0xe7, 0x75, 0x9e, 0x9b, 0x2e, 0x3a, 0x7f, 0x1b, 0x58, 0x89, 0xbf, 0xf9,
	0x98, 0x01, 0xc9, 0xd7, 0x61, 0x7f, 0xea, 0x3a, 0x4b, 0x5d, 0x32, 0x2d, 0x84, 0xb3, 0x58, 0xbc,
	0x93, 0xb9, 0x57, 0xd2, 0x76, 0x29, 0x3a, 0x34, 0x28, 0x84, 0x47, 0xf8, 0x25, 0x60, 0x4b, 0x1a,
	0x47, 0x58, 0x9f, 0xd3, 0xe1, 0x6d, 0x94, 0xee, 0x64, 0xee, 0xd5, 0xb4, 0xcd, 0x10, 0xce, 0x46,
	0xfd, 0x5d, 0xd8, 0x43, 0x7f, 0x76, 0xe2, 0xcc, 0x45, 0x5b, 0xf4, 0x85, 0x65, 0x3b, 0x6e, 0xa3,
	0x8c, 0x2f, 0xec, 0x08, 0x2c, 0x6f, 0x53, 0x9f, 0xe2, 0xd2, 0xdf, 0x32, 0x3e, 0x72, 0xdc, 0x06,
	0xa4, 0xbf, 0x45, 0x71, 0xb4, 0x59, 0x81, 0x86, 0x36, 0x7d, 0xdf, 0xb2, 0x67, 0x1e, 0xae, 0x9a,
	0x9a, 0xb6, 0xc9, 0xe1, 0x23, 0x0e, 0x26, 0x37, 0xa1, 0x7c, 0x6a, 0xd8, 0xd3, 0x17, 0xd6, 0xd4,
	0x3f, 0x6f, 0x54, 0x91, 0x66, 0x08, 0x20, 0xb7, 0x00, 0xa6, 0x96, 0x31, 0x37, 0x27, 0x3e, 0x1d,
	0xdf, 0x1a, 0x4e, 0x42, 0x99, 0x43, 0xba, 0x53, 0xb5, 0x05, 0xf5, 0x51, 0x84, 0x1e, 0x39, 0x80,
	0xdd, 0x66, 0xaf, 0x37, 0x7c, 0xa2, 0x8f, 0x3a, 0xa3, 0x51, 0x77, 0x38, 0xd0, 0xb5, 0xce, 0x68,
	0x3c, 0xd4, 0x3a, 0x4a, 0x86, 0xec, 0x01, 0x89, 0xa2, 0x3e, 0x18, 0x76, 0x07, 0x4a, 0x56, 0xfd,
	0xaf, 0x39, 0xa8, 0x48, 0x46, 0x25, 0x79, 0x05, 0x2a, 0x6c, 0xa1, 0xeb, 0x13, 0x67, 0xca, 0x58,
	0xac, 0xa6, 0x01, 0x03, 0xb5, 0x9c, 0xa9, 0x49, 0x39, 0xf0, 0xd4, 0xf0, 0x18, 0x27, 0x09, 0x2e,
	0xa3, 0x00, 0xca, 0x41, 0x94, 0x73, 0x44, 0xd7, 0x7d, 0xe7, 0x99, 0x69, 0x73, 0x0e, 0xab, 0x72,
	0xe0, 0x98, 0xc2, 0xc8, 0x5d, 0xa8, 0xfa, 0xe6, 0x27, 0x7e, 0x60, 0x64, 0x31, 0xee, 0xaa, 0x50,
	0x98, 0xb0, 0xa8, 0xee, 0x42, 0xd5, 0x35, 0xa7, 0x96, 0x4b, 0xbb, 0xbe, 0x72, 0xe7, 0x8d, 0x02,
	0xab, 0x22, 0x60, 0x27, 0xee, 0x65, 0x33, 0xba, 0x81, 0x6d, 0x7e, 0xd9, 0x19, 0x2d, 0xa6, 0xbf,
	0x85, 0x33, 0xba, 0x0f, 0x45, 0x5c, 0x75, 0xd6, 0x14, 0xf9, 0x6b, 0x4b, 0xdb, 0xa0, 0xc5, 0xee,
	0x94, 0x8e, 0x16, 0x33, 0x4a, 0xd8, 0x70, 0x94, 0xef, 0x64, 0xef, 0x11, 0x0d, 0x18, 0x88, 0x0e,
	0x88, 0xfa, 0x97, 0x33, 0x00, 0x5a, 0x38, 0x78, 0x15, 0x28, 0x8e, 0x4e, 0x5a, 0xad, 0xce, 0x68,
	0xa4, 0xfc, 0x14, 0x2d, 0x1c, 0x35, 0xbb, 0xbd, 0x13, 0xad, 0xa3, 0x98, 0x64, 0x1f, 0xb6, 0x07,
	0x43, 0x7d, 0x38, 0xe8, 0x8c, 0xbb, 0xfd, 0x8e, 0x7e, 0xdc, 0x1c, 0x8d, 0x9e, 0x0c, 0xb5, 0xb6,
	0x32, 0x23, 0x3b, 0xa0, 0x88, 0x92, 0xde, 0xf9, 0xde, 0x71, 0x57, 0xeb, 0xb4, 0x95, 0x73, 0x3a,
	0x9d, 0xad, 0xe1, 0xa0, 0x75, 0xa2, 0x69, 0x9d, 0xc1, 0x58, 0xcc, 0xa9, 0x62, 0x91, 0x3a, 0x80,
	0xd6, 0x69, 0x77, 0xb5, 0x4e, 0x6b, 0xdc, 0x69, 0x2b, 0x1f, 0x91, 0x2d, 0xa8, 0x69, 0xc3, 0x93,
	0x71, 0x77, 0xd0, 0xd1, 0x3b, 0x9a, 0x36, 0xd4, 0x94, 0x67, 0xea, 0xff, 0xca, 0x00, 0x49, 0x3a,
	0xf4, 0xdc, 0xf8, 0x76, 0x6c, 0xdd, 0xb2, 0x2d, 0x6a, 0x07, 0x45, 0x8d, 0x6f, 0xc7, 0xee, 0xda,
	0x96, 0x8f, 0xc6, 0x37, 0x7b, 0xa4, 0x0a, 0x38, 0xb0, 0xd3, 0x5c, 0xd3, 0x5b, 0x3a, 0xb6, 0x67,
	0x72, 0xa3, 0x67, 0x2f, 0x6a, 0x9a, 0x69, 0x1c, 0xab, 0x29, 0xcb, 0x18, 0x84, 0xbc, 0xc7, 0xad,
	0x12, 0x57, 0x37, 0x66, 0xae, 0x69, 0x2e, 0x50, 0x9c, 0x4c, 0x26, 0xe6, 0xd2, 0x37, 0x99, 0x74,
	0x2a, 0x71, 0xb3, 0xc3, 0x6d, 0x0a, 0x7c, 0x93, 0xa3, 0xc9, 0xd7, 0xa0, 0x62, 0x9c, 0x3a, 0xae,
	0xaf, 0xb3, 0x58, 0x54, 0x1e, 0x5b, 0xcc, 0x1d, 0xee, 0x26, 0x45, 0xf0, 0xfe, 0x69, 0x80, 0xd5,
	0xb0, 0x13, 0xea, 0xef, 0xc4, 0x3a, 0xcf, 0x8d, 0xc1, 0xb8, 0xcf, 0x95, 0xb9, 0x96, 0xcf, 0xf5,
	0x5d, 0x50, 0xa4, 0x21, 0x60, 0x9e, 0x20, 0x1b, 0x81, 0xdd, 0xf8, 0x08, 0x30, 0x2b, 0x6f, 0x73,
	0x19, 0x05, 0x90, 0xaf, 0xc0, 0x4e, 0xa2, 0xff, 0x94, 0xdf, 0xd9, 0xb2, 0x21, 0xb1, 0xae, 0x9f,
	0xb8, 0x73, 0xf5, 0x3f, 0x66, 0xe0, 0xc6, 0x25, 0x81, 0x13, 0x4a, 0x91, 0x4e, 0xa0, 0x1e, 0x0f,
	0x82, 0x65, 0x70, 0x30, 0x09, 0xc5, 0x45, 0x5f, 0xff, 0x7c, 0x26, 0xf2, 0x08, 0x76, 0xd9, 0x64,
	0xc4, 0xbf, 0x9b, 0x5b, 0x3b, 0x2d, 0xdb, 0xf8, 0x42, 0xb4, 0x31, 0xea, 0xdf, 0x5b, 0xd7, 0x3d,
	0x3e, 0x51, 0x69, 0x43, 0x9e, 0x79, 0xa9, 0x21, 0x5f, 0xef, 0x34, 0x66, 0x3f, 0x9d, 0xd3, 0xa8,
	0xde, 0x83, 0xaa, 0xdc, 0x31, 0xd2, 0x80, 0xe2, 0xc4, 0x59, 0xd0, 0x09, 0xc3, 0x51, 0x2f, 0x6b,
	0xa2, 0xa8, 0xfe, 0x71, 0x0e, 0xca, 0xc1, 0x62, 0xba, 0x5c, 0x97, 0x27, 0x74, 0x70, 0xf6, 0x3a,
	0x3a, 0x38, 0x77, 0x1d, 0x1d, 0x9c, 0x7f, 0x49, 0x1d, 0x5c, 0x78, 0x59, 0x1d, 0xbc, 0xf1, 0xb2,
	0x3a, 0xb8, 0xf8, 0xa9, 0x74, 0x70, 0xe9, 0x25, 0x75, 0x70, 0xf9, 0x1a, 0x3a, 0x18, 0x2e, 0xd7,
	0xc1, 0x95, 0xb8, 0x0e, 0xfe, 0xf7, 0x59, 0xd8, 0x8c, 0xb1, 0x1c, 0x7d, 0x45, 0xf8, 0x82, 0xd6,
	0x94, 0x6b, 0xd0, 0x32, 0x87, 0x74, 0x99, 0x75, 0x25, 0x18, 0xd0, 0xbf, 0x58, 0x32, 0x25, 0x5a,
	0xd3, 0xaa, 0x02, 0x38, 0xbe, 0x58, 0x9a, 0xe4, 0x1e, 0x28, 0xc8, 0x1b, 0x4b, 0xd7, 0x59, 0x2c,
	0x7d, 0x56, 0x8f, 0x09, 0x85, 0x3a, 0x85, 0x1f, 0x23, 0x18, 0x6b, 0x7e, 0x19, 0x76, 0xe2, 0x35,
	0x75, 0x63, 0xee, 0x73, 0xad, 0xba, 0x15, 0xad, 0xdd, 0x64, 0x1a, 0x5e, 0x7a, 0x81, 0xab, 0x56,
	0x08, 0xeb, 0x91, 0x37, 0xa0, 0x64, 0xda, 0x13, 0x67, 0x6a, 0xd9, 0x33, 0xee, 0x92, 0xd5, 0xd9,
	0x9a, 0xe8, 0x70, 0xa8, 0x16, 0xe0, 0xd5, 0xef, 0x43, 0xf5, 0x58, 0x6e, 0x37, 0xc0, 0xc6, 0x68,
	0xdc, 0x1c, 0x77, 0x5b, 0x4a, 0x86, 0x54, 0xa1, 0x34, 0x1c, 0x74, 0x74, 0xaa, 0xd0, 0x94, 0x2c,
	0xd5, 0x4c, 0x83, 0xce, 0x13, 0x9d, 0x63, 0x73, 0xa8, 0xc1, 0x4e, 0x34, 0xbd, 0x39, 0x68, 0xeb,
	0x12, 0x3c, 0x4f, 0xed, 0xe3, 0x71, 0xe7, 0x7b, 0x63, 0xa5, 0xa0, 0xba, 0xa0, 0xc4, 0x25, 0xcf,
	0x35, 0xc6, 0x56, 0x34, 0x2d, 0x1c, 0xdb, 0xb2, 0x56, 0x15, 0x40, 0x6c, 0xa3, 0x6c, 0x26, 0xe7,
	0xa2, 0x66, 0xb2, 0xfa, 0x57, 0x33, 0x50, 0x12, 0xdd, 0x4c, 0x52, 0xcb, 0xa4, 0x50, 0x63, 0x0b,
	0xd5, 0x71, 0x2d, 0xff, 0x42, 0x77, 0x0d, 0xfb, 0x59, 0x30, 0x9d, 0x1c, 0xa8, 0x19, 0xf6, 0x33,
	0x72, 0x04, 0x24, 0xa0, 0xb4, 0x34, 0x5c, 0x63, 0x61, 0xfa, 0xa6, 0xcb, 0x3d, 0xfa, 0xfd, 0xe8,
	0xe0, 0x1e, 0x0b, 0xb4, 0xb6, 0x65, 0xc6, 0x41, 0xea, 0xfb, 0xb0, 0x95, 0xa8, 0x47, 0x08, 0xe4,
	0x25, 0x11, 0x82, 0xcf, 0x64, 0x07, 0x0a, 0xcf, 0x8d, 0xf9, 0x4a, 0x0c, 0x00, 0x2b, 0xa8, 0xff,
	0x24, 0x0b, 0x3b, 0x69, 0x91, 0xbf, 0xa4, 0xdd, 0xc6, 0x7b, 0x1a, 0xb1, 0xdb, 0x3e, 0xad, 0x48,
	0xca, 0xc4, 0x45, 0x52, 0x9a, 0xcc, 0xc8, 0xbf, 0xac, 0xcc, 0x28, 0x7c, 0x2a, 0x99, 0xb1, 0x71,
	0x89, 0xcc, 0x88, 0x08, 0x82, 0x62, 0x4c, 0x10, 0xa8, 0x7f, 0x23, 0x0b, 0x87, 0xeb, 0xa3, 0xa6,
	0x9f, 0xd1, 0x6e, 0x8e, 0x9b, 0xc4, 0xb9, 0xa4, 0x49, 0x1c, 0x33, 0x35, 0xf3, 0x71, 0x53, 0x33,
	0x26, 0xa9, 0x0a, 0x71, 0x49, 0x75, 0x7a, 0x2d, 0x43, 0xf4, 0x9c, 0x6c, 0xc3, 0xe6, 0xc9, 0xe0,
	0xd1, 0x60, 0xf8, 0x64, 0x10, 0x98, 0x95, 0x26, 0x35, 0x23, 0x9b, 0x58, 0x5b, 0x6f, 0x77, 0x06,
	0xdd, 0x4e, 0x5b, 0x39, 0xa3, 0x7e, 0x6a, 0x77, 0xf0, 0xb8, 0xd9, 0xeb, 0xb6, 0xf5, 0xe3, 0xa6,
	0xd6, 0xec, 0x8f, 0x94, 0x99, 0xda, 0x82, 0xc6, 0xba, 0xb0, 0x2f, 0x79, 0x1d, 0x14, 0xcb, 0xd3,
	0x3d, 0x83, 0x3a, 0xfe, 0xcb, 0x65, 0xb8, 0x9e, 0x4a, 0x5a, 0xcd, 0xf2, 0x46, 0xc6, 0xc2, 0x6c,
	0x2e, 0x97, 0x74, 0x41, 0xa9, 0x6f, 0xc2, 0x06, 0xdb, 0xd3, 0x4b, 0x8c, 0x4a, 0x26, 0x31, 0x2a,
	0xea, 0xef, 0x65, 0x50, 0xa3, 0xf2, 0x80, 0xf0, 0xab, 0x50, 0x63, 0xdb, 0x80, 0xba, 0x6b, 0x1a,
	0x9e, 0x63, 0xf3, 0x69, 0xa8, 0x32, 0xa0, 0x86, 0xb0, 0x04, 0xd5, 0xec, 0xd5, 0xee, 0x47, 0x2e,
	0xe1, 0x7e, 0xa8, 0x1f, 0x40, 0xb5, 0x27, 0x53, 0xad, 0x03, 0xdc, 0x7f, 0xaa, 0x6b, 0x9d, 0x0f,
	0x4f, 0x3a, 0xa3, 0xb1, 0x92, 0x89, 0x19, 0xe2, 0x59, 0x2a, 0x18, 0x8f, 0x86, 0x5a, 0xab, 0xd3,
	0x56, 0x72, 0x0c, 0xd7, 0x1c, 0x8d, 0xba, 0x0f, 0x06, 0x9d, 0xb6, 0x92, 0x57, 0x1f, 0x43, 0x3d,
	0x66, 0x93, 0xdd, 0x85, 0xaa, 0x33, 0x9f, 0x86, 0x8e, 0x3a, 0x5b, 0x8e, 0x15, 0x67, 0x3e, 0x0d,
	0x9c, 0xf4, 0xbb, 0x50, 0xb5, 0xcd, 0x17, 0x7a, 0xcc, 0xe1, 0xaf, 0xd8, 0xe6, 0x0b, 0x51, 0x45,
	0xfd, 0xb5, 0x0c, 0xec, 0xa4, 0xd9, 0x31, 0x57, 0x33, 0xeb, 0xd5, 0x63, 0xa4, 0x7e, 0xf3, 0x9a,
	0x8e, 0x4d, 0xc2, 0x03, 0x39, 0x53, 0xff, 0x71, 0x06, 0x76, 0x53, 0x83, 0xe0, 0x49, 0xe9, 0x91,
	0x49, 0x1a, 0x34, 0xb7, 0x00, 0xce, 0x2c, 0xd7, 0xf3, 0x99, 0xdd, 0xc4, 0xba, 0x5d, 0x46, 0x08,
	0x1a, 0x4e, 0xb8, 0x4e, 0x26, 0x8e, 0x3d, 0x65, 0x78, 0x26, 0xe0, 0x81, 0x81, 0xb0, 0xc2, 0x2e,
	0x6c, 0x98, 0xfa, 0xc2, 0xb0, 0xe6, 0xdc, 0x10, 0x2a, 0x98, 0x7d, 0xc3, 0x9a, 0x27, 0xa5, 0x5b,
	0x21, 0x29, 0xdd, 0xd4, 0x5f, 0xca, 0xc2, 0x8d, 0x4b, 0xc2, 0xf7, 0xd7, 0x92, 0x02, 0xa1, 0xcd,
	0xc7, 0x46, 0x35, 0x3d, 0x7e, 0xc3, 0x58, 0x2e, 0x8c, 0xdf, 0x5c, 0xc3, 0x69, 0x96, 0xbc, 0xd4,
	0x42, 0xc4, 0x4b, 0xfd, 0x02, 0xd4, 0xcd, 0x4f, 0x96, 0x96, 0xcb, 0x22, 0xdd, 0x2b, 0x7f, 0x82,
	0x62, 0xb0, 0xac, 0xd5, 0x42, 0xe8, 0x89, 0x3f, 0x51, 0xbf, 0x78, 0xbd, 0x19, 0x55, 0x7f, 0x94,
	0x81, 0x8a, 0xb4, 0x17, 0x42, 0x9b, 0xc6, 0x5b, 0x15, 0xae, 0xea, 0x9a, 0x56, 0xe1, 0x30, 0x54,
	0x92, 0x7b, 0xb0, 0xe1, 0x39, 0x2b, 0x77, 0x22, 0xe6, 0x8b, 0x97, 0xa8, 0xa9, 0xec, 0xad, 0x4e,
	0x31, 0x5e, 0xce, 0x3a, 0x2c, 0x8a, 0x54, 0xa9, 0xd1, 0xbe, 0xf1, 0x39, 0xc2, 0x67, 0xf2, 0x36,
	0x6c, 0x47, 0xfb, 0xc1, 0x44, 0x21, 0xed, 0x2c, 0xd1, 0xb6, 0x22, 0x9d, 0x41, 0xe7, 0xbb, 0x09,
	0x95, 0xbe, 0xd4, 0x08, 0x02, 0xf5, 0x96, 0xd6, 0x1d, 0x77, 0x5b, 0xcd, 0x1e, 0x67, 0x45, 0x0c,
	0xbd, 0x3d, 0x69, 0x6a, 0x83, 0xee, 0xe0, 0x81, 0x92, 0xa5, 0xa6, 0x47, 0x77, 0x70, 0x34, 0x54,
	0x72, 0xa4, 0x08, 0xb9, 0xde, 0xf0, 0x81, 0x92, 0x57, 0xbf, 0x0d, 0xfb, 0x6b, 0xb6, 0xe4, 0xaf,
	0xa5, 0x33, 0xd5, 0xff, 0x9c, 0x81, 0xbd, 0xf4, 0xcd, 0x98, 0xeb, 0xe9, 0xdc, 0x18, 0x43, 0x65,
	0x13, 0x0c, 0x25, 0x4d, 0x7a, 0x2e, 0x32, 0xe9, 0x87, 0x80, 0x8c, 0x85, 0x8c, 0x96, 0x0f, 0x19,
	0x8d, 0x96, 0xd5, 0xc1, 0x35, 0xd7, 0x6e, 0x8a, 0x2e, 0x38, 0x4b, 0xea, 0x82, 0x99, 0xfa, 0x5d,
	0xc8, 0x1f, 0x53, 0x83, 0x69, 0x07, 0x0a, 0xa2, 0x2b, 0xf4, 0x83, 0xac, 0x40, 0x17, 0xf5, 0x92,
	0x2a, 0xfa, 0x60, 0xc2, 0xb2, 0xa8, 0xbb, 0x2a, 0x14, 0x28, 0xa6, 0x6a, 0x0a, 0xf9, 0x63, 0xe7,
	0xb3, 0x50, 0xc0, 0x3a, 0x8e, 0x5c, 0x27, 0xc7, 0xeb, 0x38, 0xe1, 0x57, 0xfe, 0x5a, 0x0e, 0xc8,
	0xc8, 0x77, 0x0d, 0xdf, 0x9c, 0x5d, 0xb4, 0xcd, 0x33, 0xea, 0x0c, 0x53, 0xeb, 0xe7, 0x0e, 0x54,
	0x8c, 0xd9, 0xcc, 0x35, 0x67, 0xc8, 0x3d, 0xdc, 0x55, 0x96, 0x41, 0xd4, 0x47, 0x36, 0x3f, 0xe1,
	0xde, 0xa2, 0xc7, 0x09, 0x70, 0x7f, 0x91, 0xfb, 0xc8, 0x1d, 0x8e, 0x16, 0xe4, 0x35, 0xc5, 0x8c,
	0x41, 0xe8, 0xda, 0xf7, 0xad, 0xc9, 0x33, 0xdd, 0xb3, 0x7e, 0xc8, 0x34, 0x7c, 0x46, 0x2b, 0x51,
	0xc0, 0xc8, 0xfa, 0x21, 0x2e, 0xa2, 0xa5, 0x6b, 0x4d, 0x4c, 0xdd, 0x39, 0x3b, 0xf3, 0x4c, 0x66,
	0xbe, 0x67, 0xb4, 0x0a, 0xc2, 0x86, 0x08, 0x22, 0xaf, 0x41, 0xdd, 0x75, 0x56, 0xf6, 0x54, 0x9f,
	0x9b, 0x33, 0x7d, 0x41, 0xd9, 0x81, 0xd9, 0x40, 0x55, 0x84, 0xf6, 0xcc, 0x59, 0x9f, 0xce, 0xe6,
	0x2d, 0x00, 0xdb, 0x99, 0x9a, 0xba, 0x65, 0x4f, 0xcd, 0x4f, 0x78, 0x2c, 0xac, 0x4c, 0x21, 0x5d,
	0x0a, 0x20, 0x1d, 0xd8, 0x44, 0xf4, 0x34, 0xe8, 0x3e, 0xdf, 0x35, 0xe1, 0x3b, 0x87, 0xa2, 0xb5,
	0x03, 0x67, 0x6a, 0x86, 0x43, 0xa4, 0xd5, 0xed, 0x48, 0x99, 0x9a, 0x70, 0xc8, 0x76, 0x53, 0x33,
	0x4c, 0x57, 0x28, 0xb1, 0x68, 0x32, 0x85, 0xb7, 0x43, 0xb0, 0xfa, 0x06, 0x54, 0x35, 0xb9, 0x81,
	0x25, 0xc8, 0xb7, 0x87, 0x4f, 0x06, 0x4a, 0x86, 0x6c, 0x40, 0xf6, 0xe4, 0x98, 0xad, 0xbb, 0x7e,
	0x73, 0xfc, 0x50, 0xc9, 0xa9, 0x0f, 0x41, 0x89, 0x0f, 0x24, 0x35, 0xe6, 0x12, 0x63, 0x2f, 0x04,
	0x0d, 0xfd, 0xe0, 0x4e, 0x7c, 0xa0, 0xd1, 0x8a, 0xf8, 0xbb, 0x19, 0xa8, 0xf5, 0xcc, 0x99, 0xd4,
	0xe4, 0x57, 0xa0, 0x32, 0x71, 0x6c, 0xdf, 0x35, 0x26, 0x92, 0xef, 0x00, 0x02, 0xc4, 0x14, 0x8b,
	0x34, 0x72, 0xd9, 0xf8, 0xc8, 0xdd, 0x80, 0xf2, 0xc7, 0x68, 0xe3, 0xfb, 0x96, 0x83, 0xcc, 0x95,
	0xd1, 0x4a, 0x1f, 0x53, 0xfb, 0xde, 0xb7, 0x1c, 0x4a, 0x9c, 0x4d, 0x1f, 0x43, 0xb3, 0xd9, 0x03,
	0x04, 0xb1, 0x0a, 0xf1, 0xf9, 0x2d, 0x24, 0xe6, 0x57, 0xfd, 0x0b, 0x19, 0xa8, 0x0f, 0x4c, 0xcf,
	0x37, 0xa7, 0x41, 0xdf, 0x7f, 0x06, 0x40, 0x9a, 0x28, 0xda, 0xe4, 0x60, 0x7f, 0x24, 0xc9, 0xc7,
	0x9a, 0x54, 0x37, 0xda, 0xda, 0x2c, 0x63, 0xb6, 0x75, 0xad, 0xcd, 0xc5, 0x5b, 0xab, 0xfe, 0xab,
	0x0c, 0xec, 0xa5, 0x73, 0x02, 0x55, 0x26, 0x38, 0x4a, 0xce, 0xd2, 0x64, 0xd2, 0x16, 0xa9, 0xd7,
	0xb4, 0x1a, 0x85, 0x0e, 0x05, 0x90, 0x7c, 0x01, 0x72, 0x73, 0x73, 0xc6, 0xc3, 0x3f, 0x7c, 0x2f,
	0x26, 0x32, 0x1f, 0x1a, 0xc5, 0x93, 0xf7, 0x61, 0xd3, 0xc6, 0x2e, 0x87, 0xcb, 0x2a, 0x2f, 0xa7,
	0x6b, 0x45, 0xc7, 0x43, 0xab, 0xdb, 0x91, 0xb2, 0xfa, 0x06, 0xd4, 0x06, 0x91, 0xcf, 0x16, 0x21,
	0x37, 0x3a, 0xe9, 0x2b, 0x19, 0xfa, 0xd0, 0x3f, 0xe9, 0x29, 0x59, 0xdc, 0x65, 0xe9, 0x3e, 0x56,
	0x72, 0xaa, 0x0b, 0x9b, 0x63, 0xbe, 0xda, 0xee, 0x5f, 0x1c, 0xd3, 0xbe, 0x46, 0x57, 0x64, 0x86,
	0x4d, 0x69, 0xb0, 0x22, 0x6f, 0x01, 0x20, 0x32, 0xf4, 0xa3, 0x32, 0x1a, 0x56, 0x7f, 0x4c, 0x01,
	0x54, 0x7c, 0x2f, 0x2c, 0xdb, 0x5a, 0xac, 0x16, 0x3a, 0x0e, 0x1c, 0x67, 0x89, 0x2a, 0x07, 0xe2,
	0x07, 0xd4, 0x8f, 0xe0, 0x66, 0xf8, 0xcd, 0xb6, 0xe1, 0x9b, 0x63, 0x6b, 0x3e, 0xef, 0x04, 0x8a,
	0x8a, 0xd4, 0x21, 0x1b, 0xb0, 0x62, 0xd6, 0x9a, 0x46, 0x1b, 0x94, 0xbd, 0xb4, 0x41, 0xb9, 0x58,
	0x83, 0xd4, 0x5f, 0x00, 0x50, 0x5a, 0x9c, 0x9b, 0xfb, 0xa6, 0x6f, 0x4c, 0x0d, 0xdf, 0xb8, 0x9a,
	0xe9, 0x5f, 0x87, 0xcd, 0xa0, 0x82, 0x77, 0xb1, 0x38, 0x75, 0xe6, 0x5c, 0x45, 0xd7, 0x05, 0x78,
	0x84, 0x50, 0xaa, 0x7c, 0x27, 0x8e, 0x8b, 0x26, 0x31, 0xe3, 0x1d, 0x6f, 0x62, 0xcc, 0x45, 0x33,
	0xb6, 0x38, 0x0a, 0x7b, 0x3d, 0xa2, 0x08, 0x5a, 0x7f, 0x6a, 0x79, 0xcb, 0xb9, 0x71, 0x11, 0xa9,
	0x9f, 0xc7, 0x16, 0x6c, 0x71, 0x94, 0x54, 0xff, 0x0e, 0x54, 0x64, 0x61, 0xc2, 0x77, 0x93, 0x24,
	0x10, 0xea, 0x06, 0xcb, 0x9f, 0x9b, 0x7c, 0x13, 0x89, 0x15, 0xa2, 0x43, 0x56, 0x8c, 0x0d, 0xd9,
	0x21, 0x94, 0x98, 0x37, 0x32, 0xb9, 0x68, 0x94, 0x98, 0xcf, 0x25, 0xca, 0xb1, 0xe1, 0x2c, 0xc7,
	0xe7, 0xf7, 0x00, 0x4a, 0x93, 0x33, 0x8b, 0xa9, 0x5d, 0xc0, 0x57, 0x8b, 0x93, 0x33, 0x0b, 0x15,
	0xe6, 0x6b, 0x50, 0xb7, 0x3c, 0x7d, 0xe1, 0x78, 0xbe, 0x6e, 0x4c, 0x7c, 0xeb, 0xb9, 0x89, 0x71,
	0xa1, 0x92, 0x56, 0xb5, 0xbc, 0xbe, 0xe3, 0xf9, 0x4d, 0x84, 0x91, 0x37, 0x60, 0x6b, 0x6e, 0x78,
	0xbe, 0xee, 0xbb, 0x06, 0xfa, 0xfd, 0x53, 0xc3, 0x37, 0x71, 0x8f, 0x87, 0x68, 0x9b, 0x14, 0x31,
	0x66, 0x70, 0xca, 0x15, 0xb4, 0x2e, 0xb7, 0x69, 0x1d, 0x9f, 0x8e, 0x15, 0xd6, 0xad, 0xb1, 0xba,
	0xcc, 0xb4, 0x45, 0x38, 0xd6, 0xfd, 0x59, 0x38, 0x5c, 0xd9, 0x53, 0xd3, 0x9d, 0x5f, 0x50, 0xaa,
	0xf1, 0xc9, 0xab, 0xa3, 0x4c, 0x6c, 0x84, 0x35, 0x5a, 0xd1, 0x69, 0xa4, 0xc6, 0x9a, 0xe1, 0xce,
	0x2c, 0x5b, 0xf7, 0xfc, 0x8b, 0xb9, 0xd9, 0xd8, 0xc4, 0xc5, 0x5b, 0x61, 0xb0, 0x11, 0x05, 0x91,
	0x77, 0x60, 0xd7, 0xb2, 0x3d, 0xdf, 0x5d, 0x61, 0x38, 0x7a, 0xe6, 0x3a, 0xab, 0x25, 0xb3, 0x57,
	0x15, 0x1c, 0x86, 0xed, 0x10, 0xf9, 0x80, 0xe2, 0xd0, 0x74, 0xfd, 0x22, 0x88, 0xb8, 0x9a, 0x6e,
	0xd9, 0x67, 0x0e, 0xe5, 0xb5, 0xad, 0x3b, 0xd9, 0x7b, 0x5b, 0x9a, 0xb0, 0x71, 0xba, 0xf6, 0x99,
	0xd3, 0x9d, 0x12, 0x05, 0x72, 0x0b, 0x6b, 0xd2, 0x20, 0xd8, 0x4a, 0xfa, 0x48, 0x67, 0x75, 0x6a,
	0xce, 0x8d, 0x8b, 0xc6, 0x0e, 0x76, 0x97, 0x15, 0xc8, 0xfb, 0x70, 0xc3, 0x3b, 0x77, 0x5c, 0x5f,
	0x4f, 0x6f, 0xc9, 0x2e, 0xb6, 0xa4, 0x81, 0x55, 0xba, 0x29, 0xcd, 0xf9, 0x2e, 0xdc, 0x4c, 0xbc,
	0x28, 0x73, 0xd7, 0x1e, 0xbe, 0x7f, 0x18, 0xeb, 0x89, 0xa4, 0xb5, 0x48, 0x1b, 0xb6, 0x03, 0xb6,
	0xf2, 0xf4, 0x53, 0xce, 0xc4, 0x8d, 0x7d, 0x39, 0xd6, 0x1c, 0x13, 0x27, 0x9a, 0x22, 0xf8, 0xce,
	0x13, 0x02, 0xa6, 0x0f, 0x5b, 0x51, 0x2a, 0x53, 0xdf, 0x6c, 0x34, 0xe4, 0x94, 0x82, 0xcb, 0xc4,
	0x83, 0x56, 0x97, 0x08, 0xb6, 0x7d, 0xba, 0xa6, 0x76, 0x12, 0xe4, 0xe8, 0x50, 0x1f, 0xe0, 0x24,
	0x2a, 0xd1, 0xda, 0xdd, 0x29, 0x9a, 0xdd, 0xbe, 0x6b, 0x3d, 0x33, 0x1b, 0x87, 0xcc, 0x36, 0x64,
	0x25, 0xca, 0x04, 0xec, 0x89, 0xf7, 0xea, 0x06, 0x53, 0x46, 0x0c, 0xc6, 0x5a, 0x1e, 0x8d, 0x26,
	0xdc, 0x8c, 0x45, 0x13, 0x28, 0x85, 0x89, 0xb3, 0xb2, 0x7d, 0xf7, 0x82, 0xad, 0x90, 0x5b, 0xdc,
	0x4f, 0x63, 0x30, 0x5c, 0x25, 0x5d, 0xd8, 0x0e, 0xd4, 0xb5, 0xa4, 0xc4, 0x6e, 0xcb, 0x39, 0x41,
	0x29, 0x4a, 0x8c, 0x78, 0x09, 0x98, 0xfa, 0x45, 0xa8, 0xf4, 0x25, 0x06, 0xa5, 0xbe, 0xf4, 0xc9,
	0xf8, 0x04, 0xf7, 0x35, 0x2b, 0x50, 0x3c, 0xd6, 0x3a, 0xfd, 0xee, 0x49, 0x5f, 0xc9, 0xaa, 0xbf,
	0x5c, 0x06, 0x92, 0x4c, 0xfc, 0x4c, 0x48, 0xd9, 0x9b, 0x50, 0xe6, 0xa9, 0x1e, 0xa7, 0xcc, 0x09,
	0x2b, 0x69, 0x21, 0x80, 0x7c, 0x17, 0x14, 0x63, 0x82, 0x1d, 0xf1, 0xa4, 0x6c, 0xce, 0x4c, 0x38,
	0xed, 0x4d, 0x8e, 0x0d, 0xb6, 0x18, 0x8c, 0x28, 0x80, 0x3c, 0x85, 0x03, 0xb6, 0x1a, 0x75, 0xd7,
	0xf4, 0x9c, 0xf9, 0x2a, 0x92, 0xa5, 0x9a, 0x97, 0xd3, 0x7d, 0xd9, 0xa2, 0xd4, 0x82, 0x5a, 0x41,
	0xba, 0xaf, 0x97, 0x8e, 0x20, 0x16, 0xbc, 0x82, 0x42, 0x05, 0x53, 0xbf, 0x90, 0xb9, 0x4f, 0x8d,
	0xb9, 0x61, 0x4f, 0xa4, 0xdc, 0xc8, 0x02, 0x7e, 0x80, 0xb3, 0x57, 0xcf, 0xf0, 0xfc, 0x91, 0xa8,
	0x7b, 0x9f, 0x57, 0x15, 0x5f, 0xb9, 0x39, 0xbf, 0x04, 0x4b, 0x8e, 0x61, 0x4f, 0xc8, 0x4a, 0x6a,
	0x27, 0x48, 0x5f, 0xd8, 0x90, 0x37, 0x4a, 0x5a, 0xbc, 0x8e, 0x46, 0xab, 0x04, 0xd9, 0x8e, 0x93,
	0x14, 0x28, 0xd1, 0xe1, 0x86, 0x2c, 0x24, 0xe2, 0xf9, 0xbb, 0x45, 0x24, 0xcb, 0x33, 0x4b, 0x46,
	0xa1, 0xd8, 0x88, 0xa5, 0xf1, 0x1e, 0x78, 0xeb, 0x50, 0x74, 0xe0, 0xcf, 0x2d, 0xcf, 0x77, 0x5c,
	0x6b, 0x62, 0xcc, 0x75, 0xcc, 0x36, 0x0a, 0x5b, 0x5d, 0x93, 0x07, 0xfe, 0x61, 0x50, 0x0d, 0x13,
	0x94, 0x82, 0x86, 0xef, 0x9f, 0xa7, 0x23, 0xc8, 0x04, 0x6e, 0xb1, 0x39, 0xc1, 0x75, 0x27, 0x09,
	0x60, 0x41, 0xbe, 0x2e, 0xa7, 0x57, 0xb2, 0x79, 0xf5, 0xee, 0x5f, 0x9c, 0x04, 0x15, 0x83, 0x84,
	0x57, 0x6f, 0x2d, 0x8e, 0xf4, 0x61, 0x77, 0x72, 0x6e, 0xcd, 0xa7, 0xba, 0xf8, 0x94, 0x20, 0xbe,
	0x89, 0xc4, 0x79, 0x3e, 0x4a, 0x8b, 0x56, 0xe1, 0x5f, 0x08, 0xf2, 0x5d, 0x27, 0x49, 0x20, 0xf9,
	0x39, 0xb8, 0x61, 0xf8, 0xba, 0x7f, 0x6e, 0xea, 0x0b, 0xc7, 0x36, 0x2f, 0x74, 0xbe, 0xe6, 0x05,
	0x51, 0x45, 0x1e, 0x90, 0xa6, 0x3f, 0x3e, 0x37, 0xfb, 0xb4, 0xda, 0x08, 0x6b, 0x05, 0x03, 0x62,
	0xa4, 0x23, 0x70, 0x32, 0x93, 0xcb, 0x3b, 0x20, 0xbe, 0x15, 0x99, 0xcc, 0xe4, 0x32, 0x0f, 0x26,
	0x73, 0x1d, 0x0a, 0x57, 0x91, 0xf0, 0x8f, 0xad, 0x85, 0xe9, 0xf2, 0xad, 0x3a, 0x46, 0x9e, 0x44,
	0x56, 0x11, 0xf7, 0x98, 0xad, 0x85, 0xa9, 0xb1, 0x28, 0x97, 0x58, 0x45, 0x21, 0xc2, 0x95, 0x10,
	0x74, 0x32, 0x43, 0xad, 0x7c, 0x91, 0x42, 0x7e, 0x5b, 0x9e, 0xcc, 0x40, 0x51, 0x5f, 0x24, 0xbe,
	0x70, 0xe8, 0x47, 0x70, 0xf2, 0x47, 0xd4, 0x3f, 0x06, 0xd8, 0x4a, 0x64, 0x10, 0x26, 0x64, 0xd1,
	0x3b, 0x40, 0x2c, 0x91, 0x00, 0x25, 0x52, 0xf2, 0xb8, 0x50, 0x7a, 0x2f, 0xef, 0xbb, 0x2b, 0x53,
	0x53, 0x2c, 0x9e, 0xeb, 0xc4, 0x53, 0xee, 0x58, 0x88, 0x0b, 0xb3, 0xca, 0x98, 0xec, 0xcd, 0x31,
	0xa3, 0x8e, 0x81, 0x52, 0xc3, 0x77, 0x29, 0xc1, 0xa2, 0xf7, 0x61, 0x53, 0x92, 0x72, 0x98, 0xf4,
	0x54, 0x90, 0x0d, 0xef, 0x50, 0xc8, 0x61, 0xbe, 0x53, 0xdd, 0x88, 0x94, 0xc9, 0x63, 0x68, 0xa4,
	0x89, 0x38, 0xa4, 0xc3, 0xc4, 0xc3, 0xcd, 0x75, 0x12, 0x0e, 0xe9, 0xed, 0x79, 0xa9, 0x70, 0x72,
	0x06, 0xb7, 0xd7, 0xcb, 0x37, 0xa4, 0x5e, 0x94, 0xb3, 0x3f, 0xd7, 0x88, 0x37, 0xfc, 0xc4, 0x8d,
	0xf9, 0x7a, 0x24, 0xae, 0xb4, 0xb8, 0x70, 0x43, 0xf2, 0xa5, 0xc8, 0x4a, 0x8b, 0x4a, 0x31, 0x96,
	0xf9, 0x35, 0x49, 0x02, 0xc9, 0xcf, 0xc3, 0x61, 0xba, 0x64, 0x43, 0x9a, 0x65, 0xa4, 0x79, 0x7b,
	0xbd, 0x60, 0x43, 0xc2, 0x0d, 0x6f, 0x0d, 0x86, 0x0e, 0x76, 0x9a, 0x58, 0x43, 0xda, 0x9b, 0xf2,
	0x60, 0x27, 0xa5, 0x1a, 0x1b, 0xec, 0xf3, 0x54, 0x38, 0xf9, 0x01, 0xdc, 0x5c, 0x27, 0xd3, 0x90,
	0xb6, 0x12, 0x59, 0xc3, 0x69, 0x62, 0x0b, 0xc9, 0x1f, 0x78, 0xeb, 0x50, 0xe4, 0x03, 0xd8, 0x89,
	0x0b, 0x34, 0xa4, 0xbc, 0x25, 0x1b, 0x01, 0x51, 0x79, 0xc6, 0x32, 0xfd, 0x26, 0x09, 0x18, 0xf9,
	0x1e, 0x1c, 0xa6, 0x4b, 0x33, 0xa4, 0x48, 0xe4, 0x71, 0x48, 0x0a, 0x33, 0x36, 0x0e, 0x46, 0x2a,
	0x1c, 0x67, 0x2f, 0x55, 0x94, 0x21, 0xe5, 0xed, 0xc8, 0xec, 0xa5, 0x88, 0x2b, 0x3e, 0x7b, 0x6b,
	0x30, 0xb8, 0x54, 0x52, 0xe4, 0x18, 0xd2, 0xde, 0x89, 0x2c, 0x95, 0x84, 0x18, 0xe3, 0x4b, 0x25,
	0x21, 0xc5, 0xc4, 0xec, 0xad, 0x13, 0x62, 0x48, 0x7b, 0x57, 0x9e, 0xbd, 0x54, 0x19, 0xc6, 0x66,
	0x2f, 0x55, 0x84, 0x51, 0x94, 0xfa, 0x97, 0x32, 0x00, 0xa3, 0x50, 0xaa, 0x44, 0xe2, 0x84, 0x75,
	0x80, 0xd1, 0xc9, 0xfd, 0x51, 0x4b, 0xeb, 0xde, 0xef, 0xb4, 0x79, 0x0e, 0xa3, 0x36, 0x3c, 0x3e,
	0x16, 0x9b, 0x1d, 0x27, 0xc7, 0xed, 0xe6, 0xb8, 0xa3, 0xe4, 0x88, 0x02, 0xd5, 0x76, 0x77, 0xd4,
	0x1a, 0x0e, 0x06, 0x6c, 0x2b, 0x24, 0x1f, 0x0d, 0x31, 0xd6, 0xa0, 0x3c, 0x18, 0x8e, 0xf5, 0xa3,
	0xe1, 0xc9, 0xa0, 0xad, 0x9c, 0x93, 0x1b, 0xb0, 0xcf, 0xf7, 0x50, 0xf4, 0x5e, 0xb7, 0xdf, 0x1d,
	0xeb, 0x8f, 0xbb, 0xc3, 0x5e, 0x73, 0x8c, 0xc9, 0x4d, 0xea, 0x16, 0x6c, 0xc6, 0x6c, 0x2f, 0xf5,
	0x3b, 0x50, 0x8f, 0x4a, 0x2a, 0xf2, 0x16, 0x94, 0x4f, 0x5d, 0xe7, 0x99, 0xe9, 0xb2, 0x1d, 0xa3,
	0x5c, 0x98, 0xc6, 0x74, 0x5f, 0x80, 0xb5, 0xb0, 0x86, 0x6a, 0x42, 0x39, 0x80, 0x27, 0x84, 0xb3,
	0xd8, 0x59, 0xcd, 0x4a, 0x3b, 0xab, 0xef, 0x42, 0x95, 0x25, 0xad, 0x7a, 0xa6, 0x6b, 0x99, 0x22,
	0x2d, 0x9b, 0xa7, 0x0a, 0x61, 0x66, 0xea, 0x08, 0x11, 0x5a, 0xc5, 0x0b, 0x0b, 0xea, 0x29, 0x54,
	0x24, 0x1c, 0x35, 0xcc, 0xed, 0xd5, 0xe2, 0xd4, 0x74, 0x79, 0xd0, 0x97, 0x97, 0x52, 0x3f, 0xf8,
	0x3a, 0x14, 0xb9, 0xf0, 0xe5, 0xdf, 0xaa, 0x45, 0x24, 0xb4, 0x26, 0xb0, 0xea, 0xaf, 0x67, 0xa1,
	0xc8, 0x81, 0xd4, 0x7c, 0xe7, 0x60, 0xe1, 0xf6, 0x6f, 0x69, 0x65, 0x0e, 0xe9, 0x4e, 0xc9, 0x57,
	0x60, 0x27, 0x18, 0x02, 0x5d, 0xaa, 0xc8, 0xbe, 0x4b, 0x02, 0x5c, 0x33, 0x78, 0x43, 0xb4, 0x2c,
	0x27, 0xb5, 0xec, 0x6d, 0xd8, 0x8e, 0x09, 0x6b, 0xf4, 0x5b, 0xd9, 0xd6, 0xe4, 0x56, 0x44, 0xfc,
	0xa2, 0xe7, 0x7a, 0x07, 0xaa, 0x96, 0xa7, 0x3f, 0xb7, 0xcc, 0x17, 0xba, 0x63, 0xcf, 0x2f, 0x78,
	0x62, 0x09, 0x58, 0xde, 0x63, 0xcb, 0x7c, 0x31, 0xb4, 0xe7, 0x17, 0xe4, 0x75, 0xd8, 0xb4, 0x3c,
	0x7d, 0x65, 0x1b, 0x2b, 0xff, 0xdc, 0x71, 0xad, 0x1f, 0x9a, 0x53, 0xd4, 0x26, 0x25, 0xad, 0x6e,
	0x79, 0x27, 0x12, 0x94, 0xfc, 0x34, 0x10, 0xd1, 0xec, 0xc9, 0x7c, 0xe5, 0xf9, 0x2c, 0x02, 0x5e,
	0x44, 0x17, 0x52, 0x98, 0xef, 0x2d, 0x86, 0xe8, 0x4e, 0xd5, 0xaf, 0xc2, 0xfe, 0x1a, 0x4b, 0x1b,
	0x5d, 0x24, 0xe6, 0x39, 0xf3, 0x99, 0x60, 0x25, 0xf5, 0x05, 0xec, 0xa5, 0xab, 0x2e, 0x96, 0x79,
	0xce, 0x9d, 0xee, 0x05, 0x8f, 0xb3, 0xf0, 0xd0, 0x5c, 0x90, 0x79, 0x1e, 0x8d, 0xc2, 0x68, 0xca,
	0x24, 0x1e, 0x97, 0x69, 0x40, 0x71, 0x6a, 0x52, 0x65, 0x3e, 0xe5, 0x0e, 0x88, 0x28, 0xaa, 0xb7,
	0xe1, 0xe6, 0x65, 0x46, 0xbb, 0x7a, 0x04, 0x37, 0x2e, 0xd1, 0x7a, 0x94, 0x5b, 0xb8, 0xc6, 0xe4,
	0xcc, 0xcf, 0xb9, 0x85, 0x57, 0xd3, 0x04, 0x56, 0xfd, 0x37, 0x59, 0x28, 0x72, 0xa0, 0xc4, 0xf7,
	0x5b, 0xc8, 0xf7, 0x51, 0xee, 0xc9, 0xc6, 0xb9, 0xe7, 0x0b, 0x50, 0x8f, 0x4d, 0x39, 0x8b, 0xb5,
	0xd7, 0xbc, 0xc8, 0x74, 0xcb, 0xc1, 0x97, 0x7c, 0x2c, 0xf8, 0xd2, 0x08, 0x9b, 0x59, 0xc0, 0xc8,
	0x8b, 0x28, 0x52, 0xe3, 0xc6, 0x77, 0x7c, 0x63, 0xce, 0xe3, 0x32, 0x1b, 0x88, 0x05, 0x04, 0xb1,
	0xc0, 0x8c, 0x02, 0x39, 0xc7, 0x17, 0xa1, 0x1e, 0xfa, 0x48, 0x21, 0xab, 0xe5, 0x1c, 0x03, 0x3c,
	0x19, 0x8d, 0x3e, 0x62, 0x98, 0xe1, 0xb9, 0xc3, 0x83, 0x3a, 0xf4, 0x11, 0x03, 0x61, 0x86, 0x77,
	0xae, 0x9b, 0x9f, 0x4c, 0x4c, 0xcf, 0xc3, 0x88, 0x4e, 0x46, 0x03, 0x0a, 0xea, 0x20, 0x84, 0xdc,
	0x06, 0x08, 0xcf, 0x07, 0x34, 0x2a, 0x1c, 0x1f, 0x40, 0x68, 0xa7, 0x51, 0xae, 0x1b, 0x73, 0x9d,
	0x05, 0x4b, 0x1a, 0x55, 0xac, 0x53, 0xe3, 0x50, 0xe6, 0xa0, 0xaa, 0x7b, 0xb0, 0x93, 0xe6, 0x11,
	0xa9, 0x0b, 0xd8, 0x4e, 0xb1, 0x26, 0xa8, 0x72, 0x08, 0x17, 0x62, 0xd4, 0x22, 0xe1, 0xf3, 0x77,
	0x33, 0x26, 0xbc, 0xa2, 0x54, 0xf6, 0x4e, 0x53, 0xe1, 0xea, 0x1f, 0x64, 0x60, 0x2f, 0xfd, 0x15,
	0x6a, 0x1c, 0x86, 0x9f, 0x0c, 0xc4, 0x5d, 0x25, 0x80, 0xb1, 0xa0, 0xe0, 0xc2, 0xc0, 0x45, 0x15,
	0x4c, 0x20, 0x0f, 0x0a, 0x32, 0xb0, 0x20, 0x78, 0x5d, 0x4e, 0xf8, 0x06, 0xd4, 0x22, 0x7d, 0xe3,
	0x07, 0x4e, 0x48, 0xd2, 0xca, 0xd2, 0xaa, 0xb2, 0x79, 0xa5, 0x7e, 0x1b, 0xaa, 0x32, 0x36, 0xc2,
	0x52, 0xd9, 0x18, 0x4b, 0x11, 0xc8, 0xbb, 0xa2, 0x05, 0x19, 0x0d, 0x9f, 0xd5, 0x3f, 0x9f, 0x81,
	0x83, 0xb5, 0x9e, 0x64, 0x5a, 0xd0, 0x2a, 0x93, 0x16, 0xb4, 0x52, 0xa1, 0x76, 0xe6, 0x3a, 0x0b,
	0x79, 0xfb, 0x89, 0xca, 0x99, 0x0a, 0x05, 0x8a, 0xed, 0xa7, 0xdb, 0x94, 0x6d, 0xe5, 0xcd, 0x27,
	0x5a, 0xa3, 0xec, 0x3b, 0x62, 0xeb, 0xe9, 0x17, 0x33, 0xd0, 0x58, 0x67, 0xfa, 0x5d, 0xbb, 0x21,
	0xef, 0x87, 0xf5, 0x3c, 0x73, 0x86, 0x19, 0x86, 0x59, 0xf9, 0xcc, 0x4c, 0x90, 0x0e, 0x8e, 0x38,
	0xad, 0xee, 0x45, 0xca, 0xea, 0x1f, 0x65, 0xa5, 0x8c, 0x71, 0x04, 0x51, 0x39, 0x1a, 0xa3, 0x18,
	0x7e, 0x5c, 0x89, 0xbe, 0xde, 0x9d, 0xae, 0x97, 0x5a, 0xc9, 0x21, 0xca, 0x5d, 0x39, 0x44, 0xf9,
	0xd8, 0x10, 0x91, 0xef, 0x4a, 0x39, 0x7b, 0x93, 0x73, 0x73, 0xba, 0x9a, 0x9b, 0xfc, 0x2c, 0xd1,
	0x6e, 0xb4, 0x7b, 0x1c, 0x19, 0xa6, 0xf2, 0x71, 0x00, 0xf9, 0x2a, 0x54, 0x24, 0x93, 0x88, 0x27,
	0xaf, 0x29, 0x71, 0x0b, 0x48, 0x83, 0xd0, 0xe4, 0x21, 0xdf, 0x84, 0xda, 0xd4, 0xb0, 0xe6, 0x17,
	0xfa, 0xb9, 0x33, 0xb7, 0xe8, 0x4b, 0xc5, 0x94, 0x01, 0x7d, 0xc8, 0x70, 0x5a, 0x15, 0xab, 0xf2,
	0x92, 0xfa, 0xdb, 0x19, 0xd8, 0x8c, 0x35, 0x29, 0x35, 0x17, 0xeb, 0xab, 0x50, 0x11, 0xfd, 0xa2,
	0x1f, 0xc8, 0xca, 0xad, 0xe2, 0xef, 0x63, 0xab, 0xbc, 0xe0, 0x59, 0x9e, 0x68, 0xd1, 0xae, 0xdc,
	0x25, 0xed, 0x12, 0x13, 0xcd, 0xcb, 0x54, 0x7e, 0x5b, 0x9e, 0xbe, 0x74, 0xad, 0x85, 0xe1, 0xb2,
	0x0d, 0x95, 0x92, 0x56, 0xb6, 0xbc, 0x63, 0x06, 0x50, 0x7f, 0x00, 0x10, 0x8e, 0x06, 0xf9, 0x32,
	0x54, 0xa8, 0xfd, 0xe8, 0x9c, 0xe9, 0x2f, 0x4c, 0xf3, 0x19, 0x4a, 0x9d, 0xba, 0x30, 0x99, 0xda,
	0xc6, 0xc5, 0xf0, 0xec, 0x89, 0x69, 0x3e, 0xd3, 0xca, 0x53, 0xf1, 0xc8, 0xa2, 0x87, 0x86, 0xeb,
	0x8b, 0xad, 0x2c, 0xbe, 0x1a, 0x10, 0xc6, 0xb7, 0xb2, 0xfe, 0x84, 0x5a, 0x8e, 0x61, 0x77, 0x5e,
	0xfa, 0x13, 0x5f, 0x84, 0xcd, 0xa5, 0x8b, 0x7b, 0x4c, 0x76, 0xf4, 0x2b, 0xb5, 0xa5, 0x6b, 0x0e,
	0x97, 0xa6, 0xcd, 0xb7, 0x44, 0x5f, 0x81, 0x8a, 0x5c, 0x87, 0x31, 0x1d, 0x38, 0x61, 0x85, 0xbb,
	0x50, 0x9d, 0xcc, 0x1d, 0x2f, 0xb2, 0xad, 0x4a, 0xb4, 0x0a, 0xc2, 0x78, 0x95, 0x37, 0x60, 0x6b,
	0xe9, 0x78, 0xd4, 0x8e, 0x90, 0xea, 0xb1, 0x9c, 0x82, 0x4d, 0x8a, 0x68, 0x85, 0x75, 0xd5, 0xc7,
	0xc1, 0x02, 0x12, 0x43, 0x7d, 0x17, 0xaa, 0x7c, 0x86, 0x98, 0xfc, 0xcb, 0xb0, 0x5d, 0x67, 0x0e,
	0x43, 0xe9, 0x27, 0x55, 0x91, 0x8c, 0x3b, 0x51, 0x65, 0x60, 0x2c, 0x4c, 0x55, 0x83, 0xc3, 0xf5,
	0x21, 0x23, 0xf2, 0x2e, 0xec, 0xa5, 0x45, 0xfc, 0x03, 0xd9, 0xbd, 0x93, 0x8c, 0xf6, 0x77, 0xa7,
	0x6a, 0x13, 0x0e, 0xd6, 0xfa, 0x6c, 0xe4, 0x35, 0xc9, 0xec, 0xc9, 0x85, 0x97, 0x29, 0x70, 0x93,
	0x47, 0x18, 0x41, 0xdf, 0x81, 0xed, 0x94, 0x60, 0x13, 0xb9, 0x07, 0xca, 0xd2, 0x60, 0x29, 0xc2,
	0x2c, 0x06, 0x10, 0x24, 0xea, 0xd4, 0x19, 0x9c, 0xd5, 0xef, 0x4e, 0xd5, 0xf7, 0x80, 0x24, 0xbd,
	0xbb, 0x6b, 0x7e, 0x7c, 0x0c, 0xfb, 0x6b, 0x82, 0x52, 0xe4, 0x9b, 0x70, 0xe0, 0xb0, 0x53, 0x7a,
	0x0b, 0xc3, 0x5f, 0x61, 0xea, 0x65, 0xbc, 0x25, 0x7b, 0xac, 0x42, 0x9f, 0xe3, 0x83, 0x16, 0x7d,
	0x05, 0xf6, 0xd2, 0xbd, 0x43, 0x29, 0x58, 0x9e, 0x91, 0x83, 0xe5, 0xea, 0x6f, 0x64, 0x60, 0x7f,
	0x4d, 0x84, 0xe9, 0xc7, 0xa9, 0x41, 0xc8, 0x0e, 0x14, 0x98, 0x17, 0xc0, 0x52, 0x25, 0x59, 0x41,
	0xfd, 0xb3, 0xb0, 0x97, 0xee, 0x37, 0x92, 0x23, 0xd8, 0x96, 0xfd, 0x4e, 0x1d, 0x3d, 0x3b, 0x61,
	0x55, 0xec, 0xad, 0x71, 0x39, 0xb7, 0xbc, 0x18, 0x04, 0xf3, 0xa3, 0x7d, 0x77, 0x65, 0x4f, 0x8c,
	0x50, 0xec, 0x87, 0x00, 0xf5, 0x7f, 0x66, 0x40, 0x89, 0x53, 0x21, 0x5f, 0x82, 0xad, 0x60, 0xf9,
	0x06, 0x1d, 0x62, 0x2b, 0xa3, 0xce, 0x17, 0xb0, 0x94, 0xb6, 0x11, 0xad, 0xc6, 0x53, 0x3b, 0x1c,
	0xa9, 0xce, 0x6b, 0x50, 0x67, 0x8b, 0x33, 0x96, 0xdb, 0xc1, 0x96, 0xb6, 0xa8, 0xf5, 0x16, 0x6c,
	0x4b, 0xeb, 0x58, 0x52, 0x33, 0xb4, 0xaa, 0x12, 0xac, 0x64, 0x51, 0xfd, 0x16, 0x00, 0x3b, 0x10,
	0x8b, 0xcb, 0xb6, 0x80, 0xb5, 0xca, 0x08, 0x11, 0x8b, 0x56, 0x8c, 0x1e, 0x2e, 0x5a, 0xb6, 0xe7,
	0x28, 0x04, 0x39, 0x2e, 0xda, 0x3f, 0xcc, 0xc0, 0xe1, 0xfa, 0xd8, 0xe0, 0xb5, 0x79, 0xe3, 0x4b,
	0xa0, 0x58, 0xf6, 0x64, 0xbe, 0x9a, 0x9a, 0x42, 0xd6, 0x7b, 0x7c, 0x98, 0x37, 0x39, 0x9c, 0xcb,
	0x1a, 0xef, 0x73, 0xd1, 0xb2, 0x01, 0x1b, 0x15, 0x64, 0x36, 0xfa, 0x95, 0x0c, 0x1c, 0xac, 0x8d,
	0x11, 0x90, 0x63, 0xd8, 0x8f, 0x87, 0x1a, 0xa2, 0xec, 0x74, 0xb0, 0x3e, 0xca, 0xb0, 0xe3, 0x27,
	0x81, 0x57, 0x31, 0xd5, 0x9f, 0x81, 0xed, 0x14, 0x52, 0xb1, 0x29, 0xcb, 0xc4, 0xa7, 0xec, 0x35,
	0x34, 0x46, 0x5d, 0x3f, 0xbe, 0xca, 0x98, 0xb6, 0x12, 0xfd, 0xbf, 0x03, 0x55, 0xd3, 0x9e, 0xc6,
	0x87, 0x10, 0x4c, 0x7b, 0x2a, 0x4c, 0xb5, 0x3f, 0x97, 0x83, 0x0d, 0xbe, 0x5b, 0x1a, 0x3a, 0x46,
	0xe5, 0xb5, 0x01, 0x81, 0xd8, 0xc6, 0x75, 0x2e, 0xb9, 0x71, 0x2d, 0x6f, 0x25, 0xe7, 0xf9, 0x89,
	0x10, 0xbe, 0x95, 0xfc, 0x06, 0x6c, 0x9d, 0x1b, 0x9e, 0x1e, 0x09, 0x92, 0x71, 0xbf, 0x78, 0xf3,
	0xdc, 0xf0, 0x64, 0xe1, 0x99, 0xee, 0x78, 0x6e, 0xc8, 0x49, 0x48, 0x2f, 0xe7, 0x78, 0x16, 0xa3,
	0x26, 0x5c, 0xea, 0x7e, 0x75, 0x29, 0x7d, 0xbf, 0xfa, 0x6d, 0xd8, 0x0e, 0x24, 0xef, 0xc2, 0xb1,
	0xfd, 0x73, 0xfd, 0xc2, 0x34, 0xd8, 0x59, 0xca, 0xb2, 0xb6, 0x25, 0x50, 0x7d, 0x8a, 0x79, 0x6a,
	0x1a, 0xee, 0xfa, 0x2d, 0x65, 0x58, 0xbb, 0xa5, 0xac, 0x9e, 0xc1, 0xc1, 0xda, 0x7d, 0x83, 0x75,
	0x9b, 0x8b, 0x57, 0x65, 0xc8, 0xa4, 0x6d, 0x2e, 0xea, 0xd0, 0x58, 0x17, 0xd5, 0xfb, 0x5c, 0x7c,
	0x7d, 0xf5, 0x6f, 0x6e, 0xc0, 0x56, 0xe2, 0xbc, 0x7e, 0x22, 0xd6, 0xf4, 0x16, 0x90, 0xe8, 0xf9,
	0xf3, 0x89, 0xb3, 0x64, 0xe7, 0xb0, 0x6a, 0xda, 0x96, 0x8c, 0x19, 0x51, 0x04, 0x95, 0x1a, 0xcb,
	0xd5, 0xe9, 0xdc, 0x9a, 0xb0, 0x48, 0x73, 0x70, 0x40, 0xa4, 0xa6, 0x6d, 0x4a, 0x70, 0xcc, 0x7b,
	0x8c, 0x7a, 0xf3, 0x4c, 0x7b, 0x48, 0xde, 0xfc, 0xdb, 0xb0, 0x2d, 0x07, 0xb4, 0x74, 0x1e, 0x98,
	0x62, 0xe9, 0xaf, 0x5b, 0x52, 0x10, 0x6b, 0xc0, 0x62, 0x54, 0x71, 0xff, 0x91, 0xa5, 0xd4, 0x47,
	0xfc, 0xc7, 0xc8, 0x06, 0x6b, 0x11, 0x93, 0xbc, 0xa5, 0x0d, 0xd6, 0xf7, 0xe0, 0x10, 0x19, 0x8d,
	0x5d, 0x1a, 0xb0, 0x5a, 0x52, 0x46, 0x0b, 0xd7, 0x23, 0xe3, 0xb8, 0x3d, 0x5a, 0x03, 0x83, 0xd5,
	0x27, 0x88, 0x17, 0xab, 0xf7, 0x2b, 0xb0, 0xe3, 0x3d, 0xb3, 0x96, 0x22, 0x08, 0x2e, 0x2e, 0x33,
	0x40, 0xce, 0x2b, 0x69, 0x84, 0xe2, 0x58, 0x88, 0x5b, 0xdc, 0x53, 0x40, 0x7e, 0x06, 0x1a, 0x13,
	0xc7, 0x3e, 0xb3, 0xdc, 0x85, 0x39, 0xd5, 0xc5, 0x25, 0x02, 0x1e, 0x0b, 0x40, 0x01, 0xbe, 0xb5,
	0x17, 0xe0, 0xc5, 0x9d, 0x03, 0x1e, 0x06, 0xa3, 0xde, 0x02, 0xb2, 0x30, 0xfc, 0xc9, 0x39, 0x5d,
	0x0c, 0xc6, 0x7c, 0xe6, 0xb8, 0x96, 0x7f, 0xbe, 0xc0, 0x54, 0x8f, 0x1a, 0xf2, 0x38, 0x62, 0x9a,
	0x02, 0x41, 0x9b, 0x86, 0x40, 0xdd, 0xa2, 0xf3, 0x4f, 0xe5, 0x24, 0x66, 0x6e, 0x60, 0xca, 0x47,
	0x49, 0x63, 0xa4, 0xba, 0x1c, 0x75, 0x44, 0x31, 0xe4, 0x3e, 0xdc, 0x92, 0xe2, 0xfa, 0x29, 0xdf,
	0xaa, 0xe1, 0xb7, 0x6e, 0x84, 0x95, 0xfa, 0xf1, 0xaf, 0xaa, 0xdf, 0x86, 0xad, 0x51, 0x82, 0x39,
	0x00, 0x36, 0x86, 0x5a, 0xbb, 0xa3, 0x8d, 0x94, 0x0c, 0xa9, 0x41, 0xf9, 0x78, 0x38, 0xea, 0x8e,
	0xbb, 0xc3, 0xc1, 0x88, 0x1d, 0xc3, 0x69, 0x0d, 0x7b, 0xbd, 0xe6, 0xb8, 0xa3, 0x35, 0x7b, 0x4a,
	0x4e, 0x1d, 0xc1, 0xe6, 0x71, 0x8c, 0x5f, 0x2a, 0x50, 0x6c, 0xb6, 0x5a, 0xc3, 0x93, 0xc1, 0x58,
	0xc9, 0x10, 0x05, 0xaa, 0xa3, 0x66, 0xaf, 0x33, 0xd2, 0x47, 0x1d, 0xad, 0xdb, 0xa1, 0x14, 0x6a,
	0x50, 0xbe, 0xaf, 0x0d, 0x1f, 0x75, 0xb4, 0xe6, 0x83, 0x8e, 0x92, 0x23, 0x04, 0xea, 0xcd, 0x5e,
	0x4f, 0x6f, 0x9e, 0x8c, 0x1f, 0x0e, 0xb5, 0xee, 0xf7, 0x31, 0xa1, 0xfd, 0xab, 0xb0, 0x95, 0x68,
	0x29, 0x29, 0x41, 0xfe, 0xa8, 0x7b, 0x34, 0x54, 0x32, 0xf4, 0xe9, 0xe1, 0xfd, 0x87, 0x23, 0x96,
	0xf9, 0xd7, 0xa3, 0xb0, 0x9c, 0xfa, 0x07, 0x19, 0xd8, 0x5f, 0x73, 0xa9, 0x45, 0x62, 0xa9, 0xc4,
	0xf6, 0xbf, 0xb2, 0x57, 0xee, 0x7f, 0x25, 0x8f, 0x53, 0xa8, 0x27, 0xeb, 0x43, 0xdb, 0xf1, 0x88,
	0x75, 0x26, 0x1a, 0xb1, 0xbe, 0x24, 0x44, 0x7d, 0xa6, 0x7e, 0x2c, 0x7a, 0x91, 0xbc, 0x26, 0xe3,
	0x75, 0xd8, 0x8c, 0x2c, 0xf0, 0xa0, 0x4b, 0x75, 0x19, 0xdc, 0x7d, 0x59, 0x49, 0xa0, 0xfe, 0xc2,
	0x06, 0x54, 0xe5, 0xfb, 0x45, 0xae, 0x3a, 0x23, 0xf5, 0x26, 0x94, 0x6d, 0xf3, 0x05, 0x5b, 0x41,
	0x3c, 0x87, 0xb5, 0x2e, 0x92, 0xed, 0x5e, 0x30, 0x42, 0x25, 0x9b, 0x3f, 0x91, 0x77, 0xa1, 0xca,
	0x6f, 0x83, 0x60, 0xf5, 0x73, 0xf2, 0xc1, 0x58, 0x76, 0xfb, 0x03, 0x7b, 0xa5, 0xb2, 0x08, 0x0b,
	0xf4, 0xad, 0x89, 0x61, 0x4f, 0x4c, 0xbe, 0x59, 0xc5, 0x73, 0x1e, 0xf8, 0x5b, 0x2d, 0xc4, 0xf0,
	0xb7, 0x26, 0x61, 0x81, 0x7c, 0x03, 0x6a, 0xde, 0xca, 0x5b, 0x52, 0xed, 0xcc, 0x5e, 0x03, 0xf9,
	0xec, 0xe8, 0x88, 0xa1, 0xd8, 0x7b, 0x55, 0x4f, 0x2a, 0x91, 0xf7, 0xa0, 0x8e, 0x79, 0x58, 0x54,
	0x8e, 0xb0, 0x37, 0x0b, 0x72, 0xda, 0x61, 0x93, 0xe3, 0xd8, 0xab, 0x35, 0x43, 0x2e, 0x92, 0x63,
	0xd8, 0x4b, 0xbd, 0xee, 0xc2, 0x8b, 0x66, 0x39, 0xa4, 0x5c, 0x74, 0xe1, 0x69, 0x3b, 0x29, 0x77,
	0x5c, 0x78, 0xa4, 0x0d, 0x84, 0x8e, 0xef, 0xc4, 0x59, 0x2c, 0x31, 0x5b, 0x97, 0xb5, 0xa8, 0x24,
	0xeb, 0xe9, 0x81, 0xf9, 0xa2, 0xc5, 0xd1, 0xac, 0x51, 0x8a, 0x1d, 0x83, 0xa0, 0x82, 0xbb, 0xb0,
	0xfd, 0x73, 0xd3, 0xb7, 0x26, 0xfa, 0xdc, 0xfa, 0x78, 0x65, 0xa1, 0x3e, 0xae, 0x44, 0xb2, 0x67,
	0x44, 0x85, 0x9e, 0xc0, 0x6b, 0xc4, 0x4b, 0xc0, 0xa8, 0x12, 0x0b, 0x49, 0x79, 0x13, 0x97, 0xae,
	0x4c, 0x94, 0x4a, 0xa1, 0x1b, 0x20, 0xd0, 0x23, 0x86, 0xd5, 0x14, 0x2f, 0x06, 0xa1, 0x5c, 0x33,
	0x73, 0xf8, 0xc5, 0x25, 0x3c, 0x95, 0x82, 0x73, 0xcd, 0x03, 0x87, 0xdd, 0x4c, 0xa2, 0x95, 0x66,
	0xfc, 0x89, 0xda, 0xff, 0x8e, 0xad, 0x9f, 0x9a, 0xe7, 0xc6, 0xfc, 0x8c, 0x7a, 0xfd, 0x74, 0x68,
	0xd1, 0xdc, 0x28, 0x6b, 0x75, 0xc7, 0xbe, 0x8f, 0xf0, 0xe1, 0x19, 0x1d, 0x37, 0xd2, 0x82, 0xdb,
	0xfc, 0xc4, 0x87, 0x6b, 0xce, 0x56, 0x73, 0xc3, 0x77, 0xdc, 0x8b, 0x50, 0x02, 0x52, 0x06, 0x66,
	0x17, 0x34, 0xdc, 0x60, 0xb5, 0xb4, 0xa0, 0x52, 0x20, 0x58, 0xba, 0x53, 0xf5, 0x05, 0x90, 0xe4,
	0x0d, 0x3b, 0x57, 0xad, 0x03, 0x4c, 0xad, 0xa7, 0x15, 0x63, 0xa9, 0xf5, 0x14, 0x74, 0x5d, 0x29,
	0xf2, 0x00, 0x4a, 0x62, 0xd1, 0x90, 0xbb, 0x50, 0x60, 0x53, 0xcd, 0xec, 0x83, 0x8a, 0x7c, 0xf3,
	0x0f, 0xc3, 0xb0, 0xe3, 0x0e, 0xc8, 0xb8, 0x22, 0x7e, 0xc6, 0x8b, 0xea, 0x6f, 0x02, 0x14, 0x18,
	0x99, 0x2b, 0x76, 0x6e, 0x54, 0xa8, 0xbd, 0x38, 0x4f, 0xf1, 0x97, 0x28, 0x50, 0x28, 0xc9, 0x58,
	0xd2, 0x67, 0x2e, 0x91, 0xf4, 0x79, 0x1b, 0x2a, 0x13, 0xbe, 0x36, 0x99, 0x49, 0x80, 0x67, 0x68,
	0x26, 0x6c, 0x1d, 0xb2, 0x4c, 0x68, 0x86, 0x44, 0xb3, 0xa2, 0xc0, 0x46, 0x0e, 0x21, 0xa8, 0x20,
	0xbe, 0x04, 0x8a, 0xf9, 0x89, 0x39, 0xe1, 0xb9, 0x79, 0x78, 0xc4, 0x0b, 0x63, 0x6d, 0x35, 0x6d,
	0x93, 0xc2, 0xbb, 0x21, 0x98, 0x1c, 0x42, 0x69, 0xba, 0xe2, 0x79, 0xc2, 0xec, 0x86, 0x85, 0xa0,
	0x4c, 0xed, 0xf5, 0x99, 0xe3, 0x4c, 0x75, 0xff, 0xdc, 0x5d, 0xc9, 0xd6, 0x66, 0x95, 0x42, 0xc7,
	0xe7, 0xee, 0x0a, 0x4d, 0x4d, 0x02, 0x79, 0xcf, 0x9a, 0xb2, 0x04, 0xcd, 0x9a, 0x86, 0xcf, 0xb4,
	0x83, 0x73, 0x6b, 0x61, 0xf1, 0x4c, 0x54, 0x94, 0x13, 0x5b, 0x1a, 0x20, 0x28, 0xc8, 0x5e, 0xf3,
	0x7c, 0x67, 0xc9, 0xf1, 0x15, 0xc4, 0x97, 0x29, 0x84, 0xa1, 0x15, 0xc8, 0x7d, 0xec, 0x5f, 0x60,
	0x00, 0xbf, 0xa6, 0xd1, 0x47, 0x4a, 0xf1, 0xb9, 0xe5, 0x59, 0xa7, 0x73, 0x53, 0xa7, 0x18, 0xa6,
	0x78, 0x81, 0x83, 0x3e, 0xf4, 0x2f, 0xa8, 0x37, 0xb7, 0xb0, 0x6c, 0x5d, 0xae, 0x54, 0x67, 0x79,
	0xcf, 0x0b, 0xcb, 0x7e, 0x1c, 0xd6, 0xbb, 0x01, 0x65, 0xcb, 0xd3, 0x17, 0x86, 0xbd, 0x32, 0xe6,
	0x8d, 0x4d, 0x34, 0x7d, 0x4a, 0x96, 0xd7, 0xc7, 0x32, 0x75, 0x04, 0x2c, 0x8f, 0x39, 0xa8, 0xb8,
	0xb9, 0x5e, 0xd2, 0x8a, 0x96, 0x87, 0x5e, 0x29, 0x79, 0x15, 0x6a, 0x96, 0xa7, 0xe3, 0x99, 0x03,
	0xcf, 0xb3, 0x9e, 0x9b, 0xb8, 0x45, 0x8e, 0x29, 0xa5, 0xcd, 0x00, 0x86, 0x1c, 0xe9, 0x1a, 0xd6,
	0x5c, 0x44, 0xa9, 0x08, 0x76, 0xac, 0x82, 0xb0, 0x30, 0xe0, 0x85, 0x45, 0x3c, 0x69, 0x6a, 0xce,
	0x70, 0xf7, 0xba, 0xc6, 0xab, 0x58, 0xf6, 0xec, 0xd8, 0x9c, 0xe1, 0x0e, 0x8b, 0x6b, 0xcd, 0x66,
	0xa6, 0x8b, 0xdd, 0xd8, 0x61, 0x7d, 0xe5, 0x20, 0xda, 0x87, 0xb7, 0x61, 0x9b, 0x0b, 0xc9, 0xc8,
	0x39, 0x9b, 0x5d, 0x76, 0xce, 0x26, 0x44, 0x09, 0x7e, 0xa3, 0x16, 0x24, 0xf2, 0xb1, 0x17, 0xa9,
	0xbf, 0xc7, 0xea, 0x87, 0x28, 0x51, 0xff, 0x3d, 0xa8, 0x47, 0x85, 0x2d, 0x4f, 0xab, 0xdc, 0x0e,
	0x2f, 0x2f, 0x0b, 0xef, 0x0c, 0xaa, 0xad, 0xe4, 0x22, 0x79, 0x13, 0x48, 0xc8, 0x34, 0xc1, 0xa7,
	0x1a, 0xcc, 0x4d, 0x11, 0x8c, 0x23, 0x3e, 0xf4, 0x1d, 0x38, 0xb0, 0xbc, 0xf8, 0x3d, 0x46, 0x93,
	0x73, 0x73, 0xf2, 0xcc, 0x64, 0x49, 0x93, 0x22, 0xc7, 0x66, 0xcf, 0xf2, 0x22, 0x5f, 0x6d, 0xb1,
	0x3a, 0x91, 0x24, 0x27, 0xe1, 0x17, 0x05, 0xe7, 0x77, 0x3d, 0xcc, 0xaa, 0x4c, 0x24, 0x39, 0x71,
	0x3f, 0x29, 0x38, 0x9f, 0xeb, 0x85, 0x49, 0x4e, 0x09, 0x94, 0x7a, 0x00, 0xf9, 0x11, 0xe5, 0xe8,
	0x22, 0xe4, 0xee, 0x9f, 0x3c, 0x65, 0xb6, 0xd1, 0xa8, 0xd3, 0xeb, 0x29, 0x59, 0xf5, 0xcb, 0x50,
	0x1e, 0x06, 0x4b, 0xae, 0x08, 0xb9, 0xfe, 0xa3, 0x31, 0xcb, 0x6b, 0xef, 0xf5, 0xc7, 0x2c, 0xaf,
	0x7d, 0x34, 0x3e, 0x66, 0x67, 0x95, 0x46, 0xe3, 0x9e, 0x92, 0x57, 0xbf, 0x07, 0x9b, 0x9d, 0xd8,
	0xf2, 0x2b, 0x42, 0xae, 0x39, 0x1c, 0x30, 0x0b, 0xa6, 0xdb, 0xea, 0xdc, 0xef, 0x68, 0x0f, 0x94,
	0x2c, 0xd9, 0x80, 0xec, 0x87, 0x63, 0x25, 0x47, 0xca, 0x50, 0x18, 0x6b, 0xcd, 0x6e, 0x4f, 0xc9,
	0xb3, 0x94, 0xca, 0x41, 0x53, 0xeb, 0x2a, 0x05, 0xfc, 0x56, 0x77, 0xac, 0x6c, 0xe0, 0x43, 0xaf,
	0xaf, 0x14, 0x55, 0x0d, 0x4a, 0xed, 0x55, 0x98, 0x61, 0xdf, 0x6e, 0x3e, 0x65, 0x2d, 0x79, 0x30,
	0x6e, 0xb1, 0x96, 0x3c, 0x18, 0xb7, 0x59, 0x4b, 0x1e, 0x8c, 0xc7, 0x4a, 0x9e, 0x3e, 0x1c, 0x35,
	0x1f, 0x31, 0x52, 0x47, 0xc3, 0x47, 0x8c, 0x54, 0x73, 0x3c, 0x54, 0x8a, 0xec, 0xa1, 0xa5, 0x94,
	0xd4, 0xaf, 0x43, 0x65, 0x2c, 0x31, 0x65, 0x05, 0x8a, 0xf7, 0x3b, 0xa3, 0xf1, 0xfd, 0x2e, 0xb7,
	0xb7, 0x68, 0xa1, 0x39, 0x7a, 0xc4, 0xec, 0xcd, 0x5e, 0x73, 0x34, 0xc6, 0xcb, 0x90, 0x94, 0x9c,
	0xfa, 0x21, 0xd4, 0x22, 0x53, 0x75, 0xd5, 0xf1, 0xe7, 0x4c, 0x70, 0xfc, 0x99, 0xec, 0xc1, 0x06,
	0x73, 0x76, 0xf9, 0xd5, 0x22, 0xbc, 0xa4, 0xfe, 0x28, 0x03, 0x37, 0x42, 0x15, 0xc8, 0xe7, 0xea,
	0xd8, 0x75, 0x96, 0xa6, 0xeb, 0x5b, 0xa6, 0x77, 0x15, 0x17, 0x64, 0x3e, 0x2b, 0x17, 0x50, 0xe1,
	0xe2, 0xb8, 0xd6, 0xcc, 0xb2, 0x43, 0x99, 0xcc, 0x1a, 0x5e, 0x63, 0x60, 0x21, 0x97, 0x55, 0xa8,
	0xb9, 0x8e, 0xe3, 0x87, 0xb5, 0xc4, 0xc1, 0x54, 0xc7, 0xf1, 0x25, 0xd9, 0x2d, 0x9d, 0x62, 0xe1,
	0xde, 0x5e, 0x70, 0x8a, 0x45, 0xfd, 0xd5, 0x02, 0x54, 0x24, 0xbb, 0x8d, 0x8a, 0xa4, 0x80, 0x1a,
	0x1b, 0xc1, 0xa2, 0x13, 0x52, 0xba, 0x6c, 0x17, 0xf8, 0x75, 0x50, 0x68, 0xeb, 0x74, 0x59, 0x93,
	0xb0, 0xe0, 0x07, 0xb6, 0xba, 0x15, 0x68, 0x93, 0xab, 0xb4, 0x4d, 0x42, 0xa5, 0x15, 0x92, 0x2a,
	0x8d, 0x4b, 0x6c, 0xe6, 0x6b, 0xa6, 0x49, 0xec, 0xe2, 0x75, 0x24, 0x76, 0x29, 0x4d, 0x62, 0xc7,
	0x94, 0x49, 0xf9, 0x0a, 0x65, 0x02, 0x71, 0x65, 0xb2, 0x46, 0x5a, 0x56, 0xd6, 0x49, 0xcb, 0x77,
	0x61, 0xcf, 0x35, 0x17, 0xce, 0x73, 0x53, 0x97, 0x5e, 0xc3, 0x57, 0x98, 0xa7, 0xb8, 0xc3, 0xb0,
	0xcd, 0x00, 0x79, 0x99, 0x8c, 0xad, 0xad, 0x93, 0xb1, 0xdf, 0x82, 0x43, 0xfe, 0x95, 0xb4, 0xd7,
	0xea, 0xec, 0x6a, 0x1d, 0x56, 0x63, 0x94, 0x78, 0x59, 0xd6, 0xda, 0xec, 0x80, 0xc0, 0x65, 0x5a,
	0x5b, 0x49, 0xd1, 0xda, 0xe9, 0x62, 0x7a, 0x2b, 0x55, 0x4c, 0xab, 0xff, 0x30, 0x03, 0x15, 0xc9,
	0x2b, 0xf8, 0x09, 0xe1, 0x49, 0xf5, 0xb7, 0x33, 0x50, 0x8b, 0xf8, 0x16, 0x3f, 0x41, 0x0d, 0xdf,
	0x49, 0x73, 0x68, 0x30, 0xd0, 0x7e, 0x6e, 0xc8, 0x62, 0x88, 0x9f, 0x49, 0x45, 0xe8, 0xf0, 0x7a,
	0x5d, 0x49, 0x6a, 0xf7, 0xdc, 0xb5, 0xb5, 0x3b, 0xdb, 0xb8, 0x14, 0x1a, 0x3a, 0xd8, 0xb8, 0xe4,
	0xea, 0x58, 0xfd, 0xe5, 0x0c, 0x28, 0x71, 0xdf, 0x89, 0x7e, 0x2f, 0xe6, 0x6b, 0x31, 0x03, 0x7c,
	0x5b, 0x04, 0xe8, 0x64, 0x47, 0xab, 0x36, 0x89, 0xbd, 0xbb, 0xb7, 0x34, 0x5c, 0x4c, 0xea, 0x38,
	0xb3, 0xe6, 0x73, 0x4f, 0x3f, 0x37, 0xec, 0x29, 0x55, 0x49, 0x91, 0x0c, 0xdc, 0x1d, 0x5e, 0xe7,
	0x88, 0x56, 0x79, 0xc8, 0x6b, 0xa8, 0x7f, 0x27, 0x03, 0xb5, 0x68, 0x4b, 0x08, 0xe4, 0xa5, 0x03,
	0xd0, 0xf8, 0xcc, 0xf6, 0x2e, 0x42, 0x67, 0x30, 0xc8, 0xb1, 0xaa, 0x4e, 0xe6, 0xe2, 0xe5, 0xee,
	0x14, 0xf3, 0x24, 0x23, 0x7d, 0xd0, 0x4d, 0xdb, 0x77, 0xc5, 0xa6, 0x6f, 0x23, 0xa5, 0x27, 0x1d,
	0x8a, 0xd7, 0xc8, 0x24, 0x01, 0x53, 0x1b, 0x90, 0x17, 0x26, 0xc3, 0xf0, 0x78, 0xc8, 0x14, 0xf5,
	0xb0, 0x35, 0x54, 0xb2, 0xaa, 0x07, 0x24, 0x49, 0x43, 0xf6, 0x5b, 0x32, 0x6b, 0xfc, 0x96, 0xe4,
	0x10, 0x67, 0x65, 0x07, 0xfb, 0xb2, 0x21, 0x56, 0xff, 0x34, 0x03, 0x55, 0xd9, 0x77, 0xff, 0x49,
	0xd1, 0x38, 0x6b, 0xc4, 0xfa, 0xc6, 0x1a, 0xb1, 0xae, 0xfe, 0xed, 0x32, 0x54, 0xa4, 0xcb, 0x4e,
	0xd3, 0xc3, 0x3d, 0xb9, 0x94, 0x70, 0xcf, 0x2b, 0x50, 0xb1, 0xa4, 0x48, 0x66, 0x56, 0x24, 0xc5,
	0x05, 0x11, 0x4c, 0xdc, 0x98, 0xe4, 0x57, 0xc0, 0x52, 0xc6, 0xe2, 0xa5, 0xc8, 0x40, 0xe6, 0xa3,
	0x03, 0x99, 0x5c, 0xc8, 0x85, 0x94, 0x85, 0xac, 0x42, 0x0d, 0xfd, 0xb8, 0xa0, 0x12, 0xbb, 0x16,
	0xa0, 0x42, 0x81, 0xa2, 0xce, 0x17, 0x61, 0x93, 0xc7, 0xda, 0x82, 0x21, 0x28, 0x86, 0x29, 0x3e,
	0x2b, 0x2f, 0xe2, 0x03, 0x9c, 0x2e, 0x2c, 0x2f, 0xaa, 0x68, 0x4a, 0x2c, 0x17, 0x30, 0x44, 0x89,
	0xfa, 0x07, 0x50, 0xa2, 0x2b, 0x0e, 0xd5, 0x32, 0x73, 0xed, 0x8a, 0xb4, 0x4c, 0x15, 0xb2, 0x40,
	0x4d, 0x6c, 0x1f, 0xf7, 0x07, 0x38, 0xaa, 0x65, 0xe3, 0x11, 0x68, 0xe3, 0xf9, 0x0c, 0xd7, 0x6a,
	0xe0, 0xdb, 0x51, 0x26, 0xa9, 0x1a, 0xcf, 0x67, 0x74, 0x75, 0x32, 0x8d, 0xfc, 0x26, 0x10, 0x76,
	0x2e, 0x4f, 0x37, 0xa4, 0xcd, 0x20, 0x7e, 0xf4, 0x8e, 0x61, 0x9a, 0xc1, 0x7e, 0xd0, 0xab, 0x50,
	0x73, 0x4d, 0xca, 0xc6, 0xd4, 0xaa, 0x63, 0xbe, 0x1f, 0xde, 0x19, 0x12, 0x00, 0x69, 0x93, 0x82,
	0x35, 0x52, 0x5f, 0xbb, 0x46, 0xd8, 0x4d, 0xf2, 0xb6, 0x67, 0x4c, 0xe4, 0xeb, 0x63, 0x37, 0x63,
	0x37, 0xc9, 0x0b, 0x3c, 0xbf, 0x33, 0x76, 0xcb, 0x8f, 0x83, 0xe8, 0x80, 0x9b, 0xb6, 0x6f, 0xba,
	0xe6, 0x14, 0x93, 0xb2, 0x3d, 0xd3, 0xe5, 0xe7, 0xee, 0x6a, 0x1c, 0x7c, 0x1f, 0xa5, 0x36, 0xf9,
	0x0a, 0xec, 0xb0, 0x23, 0x83, 0xb1, 0x04, 0xac, 0x2d, 0x1c, 0x71, 0x82, 0xb8, 0x68, 0xfa, 0xe5,
	0x9a, 0x74, 0x4d, 0xc2, 0x38, 0x3a, 0x99, 0xae, 0x99, 0xba, 0xf9, 0xb1, 0x1d, 0xbd, 0x62, 0xf7,
	0xca, 0xfd, 0xa6, 0xe8, 0x92, 0xde, 0x89, 0x2f, 0xe9, 0xc7, 0xd0, 0x88, 0x09, 0x3e, 0xe6, 0xbc,
	0xac, 0x5c, 0x93, 0x27, 0x30, 0xdf, 0x4c, 0x91, 0x31, 0x23, 0x51, 0x47, 0xdb, 0x9b, 0xa4, 0xc2,
	0xe9, 0x67, 0xcf, 0x0d, 0x4c, 0x96, 0x58, 0xd9, 0x3e, 0x7a, 0xa2, 0x35, 0xad, 0x4c, 0x21, 0x2d,
	0x4c, 0x8f, 0xd5, 0xa4, 0xed, 0xa3, 0x65, 0x60, 0xe8, 0x37, 0xf6, 0xe5, 0xb3, 0x05, 0x97, 0x78,
	0x04, 0xe1, 0x3e, 0x52, 0x08, 0x53, 0x7f, 0x2b, 0x03, 0x1b, 0x41, 0xc0, 0x1a, 0xba, 0x03, 0x7d,
	0xac, 0x35, 0x07, 0xa3, 0xee, 0x98, 0xdd, 0x84, 0xa5, 0x75, 0x3e, 0x10, 0x57, 0xc1, 0x54, 0xa0,
	0xf8, 0x64, 0xa8, 0x3d, 0xea, 0x0e, 0x1e, 0x28, 0x39, 0x5a, 0x10, 0xb7, 0x3a, 0xe6, 0xa9, 0xab,
	0xd3, 0x1d, 0xe8, 0xad, 0xe6, 0xa0, 0xd5, 0xe9, 0x29, 0x05, 0x5e, 0xec, 0x0f, 0xdb, 0xdd, 0xa3,
	0xa7, 0xca, 0x06, 0x2d, 0x32, 0x54, 0xaf, 0xd3, 0x56, 0x8a, 0xe8, 0xb2, 0x75, 0xf1, 0xb9, 0x44,
	0x51, 0xa3, 0x93, 0xd1, 0x71, 0x67, 0xd0, 0xee, 0xb4, 0x95, 0x72, 0x22, 0x82, 0x0d, 0xb4, 0x05,
	0xcd, 0xd6, 0xb8, 0xfb, 0xb8, 0xd3, 0x1c, 0x2b, 0x15, 0xf5, 0x9f, 0x6d, 0xe2, 0x8e, 0x54, 0x8c,
	0xf3, 0x42, 0x39, 0x93, 0x89, 0xcb, 0x19, 0x64, 0x53, 0x21, 0x93, 0xf3, 0x5a, 0x11, 0xcb, 0x4c,
	0xce, 0x30, 0x54, 0x7c, 0x67, 0x1e, 0xa1, 0xd2, 0x96, 0xab, 0x6b, 0x9e, 0xe9, 0x01, 0x11, 0xaa,
	0xd7, 0xf3, 0x1a, 0xb8, 0xe6, 0xd9, 0x98, 0xd3, 0x49, 0x93, 0xec, 0x85, 0xd0, 0x03, 0x5a, 0x2b,
	0xd9, 0x37, 0xe2, 0x92, 0x5d, 0x16, 0x2b, 0xcc, 0x25, 0x08, 0xc4, 0x0a, 0xde, 0x1b, 0x13, 0xc8,
	0x0d, 0x76, 0x8f, 0x67, 0xf9, 0x2c, 0x10, 0x1a, 0x77, 0xa1, 0x80, 0x5b, 0xc9, 0xfc, 0x42, 0xe6,
	0x8a, 0x74, 0x19, 0xb6, 0xc6, 0x30, 0xa4, 0x05, 0xc1, 0xbc, 0xe3, 0x1d, 0x0c, 0x68, 0x32, 0x34,
	0xbe, 0x18, 0x49, 0x51, 0xe3, 0xf8, 0x9e, 0x89, 0xf2, 0x48, 0x53, 0xbc, 0x28, 0xc0, 0xa3, 0xba,
	0x34, 0x8c, 0xc6, 0x52, 0x8e, 0x6c, 0xbc, 0x2e, 0xeb, 0xd2, 0x80, 0xeb, 0x1e, 0x1a, 0xf6, 0x4c,
	0xab, 0x79, 0x72, 0x91, 0x0e, 0xf7, 0xd2, 0x35, 0x9f, 0xf3, 0xfe, 0xd3, 0x3e, 0xb2, 0xfb, 0xea,
	0xaa, 0x14, 0x8a, 0x43, 0xc0, 0x43, 0x50, 0x61, 0x05, 0xb6, 0x5d, 0xc5, 0x14, 0x05, 0x45, 0xde,
	0x03, 0x05, 0x49, 0xc8, 0x2e, 0x4f, 0x15, 0xc7, 0x02, 0x49, 0xf7, 0x42, 0xb7, 0x27, 0xe6, 0x17,
	0xd5, 0x12, 0x7e, 0x11, 0x4b, 0xd2, 0x7a, 0xae, 0x4b, 0xce, 0x51, 0x1d, 0x2b, 0xd5, 0x28, 0x78,
	0x14, 0x38, 0x48, 0x51, 0xff, 0x69, 0x33, 0xee, 0x3f, 0x89, 0x16, 0xc9, 0x8e, 0x9a, 0x82, 0xad,
	0xc6, 0x16, 0x45, 0x3d, 0x35, 0xb9, 0xd2, 0x56, 0xc2, 0xe5, 0xfb, 0x32, 0xec, 0x20, 0xa9, 0xb8,
	0xdf, 0x47, 0xd8, 0x9e, 0x1d, 0xc5, 0xf5, 0x23, 0xbe, 0x5f, 0x8a, 0x8f, 0xb8, 0x9d, 0xe6, 0x23,
	0xaa, 0x80, 0x7d, 0xd2, 0x03, 0xde, 0x62, 0x41, 0xb3, 0x0a, 0x05, 0x1e, 0x71, 0xfe, 0x12, 0xc3,
	0x21, 0x31, 0xd9, 0x6e, 0x38, 0x1c, 0xa1, 0x76, 0x12, 0xf5, 0xa4, 0x08, 0x2b, 0x93, 0x4f, 0xb5,
	0x60, 0x16, 0xc5, 0xb6, 0xad, 0x54, 0x65, 0x9f, 0x89, 0xb0, 0x30, 0x08, 0xfb, 0x0e, 0xec, 0x22,
	0x99, 0x44, 0x24, 0xb6, 0x81, 0x56, 0xc6, 0x36, 0x45, 0xc6, 0xc3, 0x41, 0x69, 0x81, 0xdb, 0x83,
	0xf4, 0xc0, 0xed, 0xab, 0xbc, 0xc7, 0x81, 0x1f, 0x78, 0x18, 0x72, 0x5a, 0x10, 0x0b, 0x92, 0xfd,
	0xc4, 0x1b, 0x31, 0x3f, 0xf1, 0x2d, 0xc0, 0x26, 0xe8, 0x31, 0x67, 0xf1, 0x26, 0x4b, 0xd1, 0xa7,
	0xa8, 0x07, 0xb2, 0xc3, 0x98, 0x74, 0x2b, 0x6f, 0xa5, 0xb8, 0x95, 0xb1, 0x98, 0xfd, 0x6d, 0xc6,
	0x01, 0x52, 0xcc, 0xfe, 0x4d, 0xd8, 0x62, 0xb6, 0x03, 0x15, 0xf3, 0xa6, 0x4b, 0x0d, 0xf7, 0x8b,
	0xc6, 0x2b, 0x28, 0x49, 0x14, 0x34, 0x22, 0x24, 0x38, 0xf9, 0x12, 0x6c, 0xb9, 0x0e, 0x86, 0x04,
	0x25, 0x91, 0x72, 0x87, 0x6d, 0x53, 0x20, 0x22, 0x94, 0x3b, 0xf1, 0xbd, 0x80, 0xbb, 0xc9, 0x13,
	0x75, 0xef, 0xc2, 0x7e, 0xac, 0xc3, 0x81, 0x50, 0x54, 0xb1, 0x2b, 0xdb, 0x72, 0xa7, 0x85, 0x6c,
	0x4c, 0x77, 0x94, 0x5f, 0x4d, 0x8f, 0x67, 0x5e, 0xbd, 0x59, 0xf2, 0xda, 0x95, 0x9b, 0x25, 0xa4,
	0x0b, 0x77, 0xcd, 0xb3, 0x33, 0x93, 0x19, 0x48, 0xeb, 0xe8, 0x7c, 0x01, 0xe9, 0xdc, 0x0e, 0x2a,
	0xa6, 0xef, 0xbb, 0xfc, 0xf7, 0xec, 0x35, 0x55, 0x5e, 0x0d, 0xca, 0xcd, 0xd6, 0x23, 0xfd, 0xb8,
	0xd7, 0x6c, 0x75, 0xae, 0x50, 0x7a, 0x75, 0x00, 0x5a, 0x95, 0x97, 0x37, 0xf0, 0xfe, 0x30, 0x24,
	0x24, 0x40, 0xc5, 0xa8, 0x5e, 0x2c, 0x89, 0x37, 0x78, 0xb9, 0x2c, 0xbd, 0xc1, 0x41, 0xc0, 0xf6,
	0x9e, 0x7b, 0x3d, 0xa5, 0xc2, 0x76, 0x7a, 0x51, 0x53, 0x2a, 0x55, 0xaa, 0x27, 0x29, 0x58, 0x6f,
	0x0d, 0x35, 0xad, 0xd3, 0x1a, 0x2b, 0x35, 0xb2, 0x09, 0x15, 0x06, 0x61, 0xdf, 0xaa, 0xd3, 0x6f,
	0x21, 0xe0, 0xfe, 0xc9, 0x68, 0xac, 0x6c, 0x46, 0xf4, 0xa8, 0x42, 0xbf, 0x1c, 0xea, 0x59, 0x65,
	0x8b, 0xec, 0xc3, 0xf6, 0xe8, 0xe9, 0x60, 0xfc, 0xb0, 0x33, 0xee, 0xb6, 0x74, 0xac, 0xd7, 0xa4,
	0xfd, 0x27, 0xd2, 0x81, 0xa8, 0x6d, 0xb2, 0x03, 0x4a, 0x58, 0xe9, 0xa8, 0xd9, 0xa5, 0x1a, 0x7c,
	0x87, 0xec, 0x01, 0x09, 0xa1, 0xc3, 0xc7, 0x1d, 0x0d, 0xdb, 0xbb, 0x4b, 0x08, 0xd4, 0x43, 0xf8,
	0xc3, 0xe6, 0xe0, 0x81, 0xb2, 0xa7, 0xfe, 0x28, 0x0b, 0x05, 0x54, 0x4c, 0x5c, 0x35, 0x4f, 0x4d,
	0xc9, 0x97, 0xc2, 0x32, 0x73, 0x2b, 0xe4, 0x4d, 0xa0, 0x6c, 0x62, 0x13, 0xe8, 0x9a, 0xb9, 0xfb,
	0x4c, 0xc5, 0x4f, 0x13, 0x19, 0x75, 0x55, 0x84, 0x5e, 0x33, 0x9b, 0x6e, 0x07, 0x0a, 0x4c, 0x22,
	0x6e, 0xa0, 0x01, 0xc8, 0x0a, 0xc1, 0xd6, 0x4e, 0x51, 0xda, 0xda, 0xe1, 0x81, 0xbe, 0x52, 0xb8,
	0x35, 0xf3, 0x96, 0xf8, 0x45, 0x53, 0x64, 0x4d, 0xf3, 0x54, 0x23, 0xc4, 0x44, 0x16, 0x75, 0x62,
	0x23, 0x05, 0x52, 0x36, 0x52, 0xee, 0x81, 0x42, 0x15, 0x38, 0x15, 0x7a, 0x2b, 0xe1, 0x9d, 0xb1,
	0xbb, 0x5d, 0xeb, 0x73, 0x73, 0xd6, 0x11, 0xe0, 0xee, 0x54, 0x75, 0x60, 0x33, 0xa6, 0xd3, 0xa9,
	0x39, 0x43, 0x5f, 0x8e, 0x39, 0xb1, 0x30, 0x37, 0x67, 0x42, 0x5a, 0xa4, 0x91, 0xe7, 0x07, 0x28,
	0xa2, 0xe4, 0x45, 0x77, 0xd9, 0x99, 0x05, 0xfa, 0xa8, 0xfe, 0xff, 0x50, 0x8b, 0xd8, 0x00, 0x64,
	0x1f, 0x8a, 0x68, 0xca, 0x06, 0xbb, 0x81, 0x1b, 0xb4, 0xc8, 0x6c, 0x9d, 0xf3, 0x15, 0x77, 0x5a,
	0xd8, 0xf4, 0x16, 0x69, 0x99, 0xbb, 0x50, 0x92, 0x87, 0x9c, 0x93, 0x5c, 0x43, 0xf5, 0x37, 0x33,
	0xb0, 0x97, 0x6e, 0x4c, 0x7f, 0x86, 0xf8, 0xc5, 0xe8, 0xd2, 0xf8, 0xc5, 0xdd, 0xcb, 0x4c, 0xf8,
	0xf5, 0x81, 0x8c, 0xdf, 0xc8, 0xc0, 0x8d, 0x4b, 0xde, 0x49, 0x8d, 0x56, 0x65, 0x12, 0x4e, 0xee,
	0x65, 0x1e, 0x46, 0xf6, 0xd3, 0x7b, 0x18, 0xea, 0xf7, 0xe1, 0x50, 0x30, 0x06, 0x62, 0x7a, 0xa6,
	0x1c, 0xd1, 0x8f, 0x46, 0xe1, 0x33, 0xf1, 0xbb, 0xa4, 0x2e, 0x0f, 0x74, 0xa8, 0x17, 0x70, 0x4b,
	0xd0, 0x66, 0x3b, 0xea, 0xf8, 0x85, 0xeb, 0x93, 0xff, 0x26, 0x1c, 0xb8, 0xe6, 0x72, 0x6e, 0xda,
	0x96, 0x77, 0xae, 0x3b, 0xb6, 0x38, 0x09, 0x80, 0xa6, 0x09, 0x0f, 0x30, 0xec, 0x05, 0x15, 0x86,
	0x36, 0x3f, 0x17, 0x40, 0x99, 0x5b, 0xfd, 0x1f, 0x45, 0x20, 0xbc, 0xcc, 0x12, 0xa9, 0xd0, 0x22,
	0x24, 0x6f, 0xc0, 0x16, 0x35, 0x94, 0x3e, 0xf6, 0x2f, 0x74, 0xcb, 0x9e, 0xb8, 0x66, 0x70, 0xbb,
	0x75, 0x4d, 0xa3, 0x16, 0xd4, 0x87, 0xfe, 0x45, 0x57, 0x80, 0xc9, 0xd7, 0x60, 0xef, 0xe3, 0x95,
	0xb9, 0xc2, 0x74, 0x56, 0xcc, 0xd2, 0xa2, 0x6f, 0xf2, 0x1b, 0x8d, 0xe8, 0x0b, 0xdb, 0x88, 0x7d,
	0xc8, 0x90, 0x7d, 0xcb, 0xc6, 0x9b, 0x7a, 0x92, 0x2f, 0x19, 0x9f, 0x84, 0x37, 0xa5, 0xc5, 0x5f,
	0x32, 0x3e, 0xc1, 0x97, 0xde, 0x8d, 0xbf, 0x34, 0xb5, 0x3c, 0x1f, 0x0f, 0x95, 0xb1, 0x7d, 0x8f,
	0x1d, 0xf9, 0xa5, 0x36, 0xc7, 0x91, 0xef, 0xc0, 0x4d, 0xce, 0x08, 0xd6, 0x0f, 0xf1, 0xf2, 0x6f,
	0xfc, 0x6b, 0x96, 0x7f, 0xee, 0x9a, 0x1e, 0xa5, 0xc3, 0x13, 0x63, 0x0f, 0xd8, 0xcf, 0x6a, 0xac,
	0x1f, 0x9a, 0xfc, 0xd6, 0xd7, 0xb1, 0xa8, 0x10, 0xb7, 0x43, 0x37, 0xae, 0xb3, 0xf5, 0x50, 0x4c,
	0x33, 0x2b, 0xbf, 0x05, 0x87, 0x2f, 0x1c, 0xf7, 0x99, 0x65, 0xcf, 0x44, 0x42, 0x9b, 0xb8, 0x96,
	0xcb, 0x9e, 0x99, 0x7c, 0xb7, 0x62, 0x9f, 0xd7, 0x60, 0xb3, 0xc1, 0x2e, 0x9a, 0xc1, 0x6c, 0xd8,
	0x7b, 0xa0, 0xd0, 0x8f, 0xb0, 0x37, 0xf8, 0x6d, 0xeb, 0x2c, 0x57, 0xa2, 0xbe, 0xb0, 0x6c, 0xac,
	0xc8, 0x6f, 0x13, 0xbd, 0x0f, 0xb7, 0x05, 0x07, 0xf0, 0xcf, 0x9c, 0x59, 0x67, 0x8e, 0xce, 0x86,
	0x0e, 0xc7, 0x98, 0xb9, 0x11, 0x87, 0x4b, 0x79, 0xe2, 0x8f, 0xac, 0x33, 0xe7, 0x43, 0x5a, 0x05,
	0x87, 0xfa, 0x6d, 0xd8, 0x3e, 0x73, 0xdc, 0x89, 0x29, 0xf2, 0xf5, 0x96, 0xa6, 0x6b, 0x39, 0x53,
	0x91, 0x0d, 0x87, 0x28, 0x96, 0xa9, 0x77, 0x8c, 0x08, 0xf2, 0x75, 0xd8, 0xb7, 0x66, 0x36, 0xfe,
	0x8e, 0xec, 0x14, 0x2f, 0xa9, 0x9d, 0xf2, 0xe4, 0x11, 0x8f, 0x6f, 0x73, 0xec, 0x32, 0xf4, 0x90,
	0x63, 0x19, 0x9f, 0x7b, 0x74, 0x6c, 0xe9, 0xcc, 0x4f, 0xad, 0xc5, 0xc2, 0xb2, 0x67, 0x62, 0x23,
	0x7e, 0x61, 0x7c, 0xd2, 0x66, 0x10, 0x6a, 0xe3, 0x9f, 0x19, 0xae, 0x8e, 0x79, 0xd0, 0xfc, 0x3f,
	0x3a, 0x78, 0x17, 0x5e, 0x9d, 0xb7, 0xc4, 0x70, 0x8f, 0x5c, 0x67, 0xc1, 0xc8, 0xf5, 0x99, 0x49,
	0x48, 0x7c, 0x6b, 0xf2, 0xcc, 0xd3, 0x8d, 0x17, 0xc6, 0x85, 0xee, 0x3b, 0x3a, 0x1d, 0x50, 0x74,
	0x43, 0x0a, 0xda, 0x26, 0x62, 0x9a, 0x2f, 0x8c, 0x8b, 0xb1, 0xf3, 0xc4, 0x71, 0x9f, 0x51, 0xdf,
	0x69, 0xea, 0x2c, 0xf4, 0x15, 0x1a, 0x79, 0x0a, 0x37, 0x69, 0x9d, 0xc5, 0x09, 0x5a, 0x78, 0x3f,
	0x0d, 0x84, 0x22, 0x17, 0xab, 0xb9, 0x6f, 0xe1, 0xad, 0xc5, 0x92, 0x1b, 0xa2, 0x4c, 0x9d, 0x45,
	0x3f, 0x40, 0x7c, 0xe8, 0x5f, 0xa8, 0x1d, 0xd8, 0x3a, 0x4a, 0x34, 0x06, 0x8f, 0x3b, 0xeb, 0x41,
	0x72, 0x1e, 0x81, 0x7a, 0x7f, 0xf8, 0xb8, 0xa3, 0x37, 0x9f, 0x34, 0x9f, 0xea, 0xc3, 0x41, 0xef,
	0x29, 0xb3, 0x95, 0xda, 0xc3, 0x01, 0x35, 0x5e, 0x1e, 0x77, 0x94, 0x9c, 0x6a, 0x42, 0xb5, 0x3d,
	0xec, 0x63, 0x03, 0x90, 0x42, 0x15, 0x4a, 0xe3, 0xe1, 0x31, 0xab, 0x9c, 0xa1, 0xf6, 0x4a, 0xff,
	0xa4, 0x37, 0xee, 0xf6, 0x3a, 0x8f, 0x3b, 0xbd, 0x91, 0x92, 0x25, 0x07, 0xb0, 0x7b, 0x74, 0xd2,
	0xeb, 0xe9, 0xa3, 0xee, 0xf7, 0x3b, 0xfa, 0x93, 0xa1, 0x36, 0x1a, 0xeb, 0xc7, 0x5a, 0x17, 0xad,
	0xae, 0x1b, 0xb0, 0x1f, 0xa2, 0x9a, 0x8f, 0x31, 0x81, 0x8f, 0x23, 0xf3, 0xea, 0x29, 0x6c, 0x47,
	0x96, 0xfd, 0xc8, 0xb6, 0x96, 0x2c, 0xd9, 0x93, 0x6a, 0xb2, 0xc0, 0xca, 0xe7, 0x87, 0x05, 0xe7,
	0xe6, 0x4c, 0x38, 0x01, 0xea, 0x3d, 0xa8, 0xf4, 0xc2, 0x62, 0x64, 0x7f, 0xf8, 0xa8, 0xf9, 0x88,
	0xed, 0x0f, 0x1f, 0x0d, 0x1f, 0x29, 0x39, 0xf5, 0x7d, 0xd8, 0x19, 0xe1, 0x3d, 0xac, 0x31, 0xe1,
	0x22, 0x1d, 0xad, 0xe4, 0x89, 0x0d, 0x19, 0xbc, 0x90, 0x48, 0x1c, 0xad, 0xe4, 0x87, 0x6f, 0xf6,
	0x61, 0x37, 0xf6, 0x3a, 0x1b, 0x58, 0xf5, 0xf7, 0xb2, 0x09, 0xc2, 0xc7, 0xc6, 0xc5, 0xc9, 0x92,
	0xec, 0xc1, 0x46, 0x40, 0x90, 0x2a, 0x58, 0x5e, 0x4a, 0xf9, 0x60, 0x36, 0xe5, 0x83, 0xd4, 0x99,
	0xa0, 0x44, 0xad, 0x60, 0x87, 0xce, 0x59, 0xf9, 0x5c, 0x1c, 0x29, 0x01, 0x62, 0xcc, 0xe0, 0xe4,
	0x3d, 0x38, 0x08, 0x2b, 0x1b, 0xa7, 0x78, 0x68, 0xd8, 0xd4, 0xd9, 0x6f, 0x82, 0xb8, 0x38, 0xda,
	0x0f, 0x2a, 0x34, 0x39, 0x9e, 0xfd, 0x5a, 0x88, 0x74, 0xe0, 0x95, 0xf0, 0x5d, 0x67, 0x89, 0x59,
	0xaa, 0xe2, 0x5d, 0x7e, 0x47, 0x1f, 0xbb, 0x2f, 0xf0, 0x66, 0x50, 0x6d, 0xc8, 0x6b, 0x31, 0x0a,
	0xec, 0x5a, 0xbf, 0x6f, 0xe1, 0xdf, 0xf9, 0x38, 0x99, 0xd3, 0x53, 0x23, 0x4a, 0x61, 0x03, 0x29,
	0x84, 0x6d, 0xb8, 0x7f, 0x6a, 0x48, 0x2f, 0x53, 0xa3, 0x72, 0x3f, 0x36, 0x88, 0x62, 0x7f, 0x9e,
	0xbc, 0x0e, 0x9b, 0x41, 0x52, 0x49, 0x64, 0x40, 0xeb, 0x02, 0xbc, 0x26, 0xfb, 0x84, 0x99, 0x25,
	0x91, 0xec, 0x93, 0xe4, 0xd8, 0xe7, 0xd2, 0xc6, 0xfe, 0x06, 0x94, 0xa9, 0x1c, 0xc0, 0x37, 0xf9,
	0x75, 0x8a, 0xa5, 0x85, 0xf1, 0x09, 0x36, 0xe9, 0xf2, 0xb1, 0x2e, 0x7c, 0xe6, 0xb1, 0xde, 0xf8,
	0xcc, 0x63, 0x5d, 0xbc, 0x7c, 0xac, 0xff, 0x69, 0x01, 0x1a, 0xc8, 0xfa, 0xc2, 0x72, 0x90, 0x6f,
	0x1e, 0xbb, 0x42, 0xb7, 0x3f, 0xa4, 0x7e, 0xb5, 0x24, 0xcc, 0x59, 0x24, 0x87, 0x9b, 0x32, 0x7c,
	0xa7, 0x28, 0xa9, 0xc0, 0xb5, 0x2d, 0x59, 0xb6, 0xb3, 0x65, 0xf7, 0x08, 0x76, 0xa2, 0x94, 0x3c,
	0x5c, 0xf3, 0x3c, 0xc7, 0xf3, 0x20, 0x85, 0x14, 0x13, 0x0a, 0x1a, 0x91, 0x69, 0x71, 0x41, 0x71,
	0x0c, 0x7b, 0x9e, 0xe0, 0x1e, 0xa1, 0x65, 0x58, 0xcb, 0xf2, 0x72, 0x1e, 0x65, 0xda, 0xfa, 0xd7,
	0x76, 0xbc, 0x34, 0xa9, 0x30, 0x82, 0xfd, 0x04, 0x45, 0x9e, 0x7f, 0x58, 0x90, 0x7f, 0xc5, 0x9b,
	0x2a, 0x13, 0xb4, 0x5d, 0x2f, 0x0d, 0x9c, 0xda, 0xcc, 0xa5, 0x71, 0xb1, 0x5a, 0x46, 0xd3, 0x3d,
	0xd3, 0xa4, 0x49, 0xa2, 0x99, 0xc7, 0xf4, 0x3d, 0x76, 0x4d, 0x51, 0x8c, 0xa2, 0xe0, 0x77, 0x7e,
	0x59, 0xcd, 0xad, 0x54, 0xa2, 0x62, 0x75, 0x69, 0xfb, 0xde, 0x9a, 0x65, 0xf7, 0x5d, 0xb8, 0xb9,
	0x74, 0x9d, 0xa5, 0xe3, 0x52, 0xbe, 0x30, 0xe6, 0x92, 0x3f, 0xc1, 0xb8, 0xac, 0x84, 0x5c, 0x76,
	0x28, 0xd7, 0x09, 0x7c, 0x0b, 0xc6, 0xa5, 0x6f, 0xc2, 0x16, 0xe7, 0x4b, 0x54, 0x5a, 0xcb, 0xb9,
	0x65, 0xb2, 0x53, 0x1a, 0x19, 0x4d, 0x61, 0x88, 0x7e, 0x00, 0xa7, 0x2b, 0x93, 0xaa, 0x46, 0xc9,
	0x12, 0x62, 0x66, 0x41, 0x8d, 0x42, 0x03, 0xeb, 0x47, 0xfd, 0x1e, 0xd4, 0xd8, 0xb5, 0x8d, 0xe7,
	0xd6, 0x19, 0xfe, 0x75, 0xea, 0x16, 0x00, 0xbf, 0xe1, 0xd1, 0x37, 0x97, 0xc8, 0xb0, 0x05, 0xad,
	0x8c, 0x90, 0x91, 0x6f, 0x2e, 0xa9, 0x9d, 0x42, 0xed, 0x4e, 0x73, 0x8a, 0xd6, 0xe3, 0xd4, 0x9c,
	0xfb, 0x06, 0x97, 0x0b, 0x75, 0x06, 0xff, 0xd0, 0xbf, 0x68, 0x53, 0xa8, 0xfa, 0x87, 0x79, 0xb8,
	0x19, 0x38, 0x5b, 0xc1, 0xf2, 0xf8, 0x71, 0x98, 0xbd, 0xd4, 0x6b, 0x74, 0x9e, 0x9b, 0x2e, 0xc6,
	0x8e, 0x16, 0xec, 0x52, 0x25, 0x0c, 0x77, 0x09, 0x20, 0xaa, 0xde, 0xaf, 0xc1, 0x9e, 0x31, 0xb7,
	0x66, 0x36, 0x35, 0x22, 0xc2, 0x40, 0xb0, 0xe3, 0x7b, 0x5c, 0xbe, 0x6f, 0x23, 0x76, 0xec, 0x04,
	0x7d, 0x70, 0x7c, 0x8f, 0x8e, 0x2a, 0x1d, 0x0b, 0x2a, 0x11, 0x17, 0xa6, 0x7f, 0xee, 0x08, 0xfb,
	0xb2, 0xc6, 0xa1, 0x7d, 0x04, 0x92, 0xf7, 0x58, 0x35, 0x53, 0xf7, 0xf8, 0xb0, 0x72, 0x86, 0xdc,
	0x0e, 0x96, 0x61, 0x38, 0xe2, 0xec, 0xdd, 0x70, 0x02, 0x1e, 0xc0, 0x26, 0x2a, 0x69, 0xe9, 0x14,
	0x52, 0x51, 0xfe, 0x15, 0xeb, 0x3a, 0x51, 0x83, 0xde, 0xa8, 0x7c, 0x55, 0xef, 0x11, 0x54, 0x87,
	0x72, 0x87, 0x01, 0x36, 0xfa, 0xcd, 0xc1, 0x49, 0xb3, 0xa7, 0x64, 0xc8, 0x2e, 0x6c, 0x35, 0x4f,
	0xc6, 0xc3, 0x7e, 0x13, 0x03, 0x11, 0x9d, 0xf6, 0x03, 0x76, 0x67, 0xf6, 0x36, 0x6c, 0x36, 0x1f,
	0x0f, 0xbb, 0xed, 0x20, 0x66, 0x31, 0x52, 0x72, 0xea, 0xcf, 0xc2, 0x76, 0x33, 0x65, 0x28, 0xc4,
	0xaf, 0xef, 0xd0, 0xee, 0x19, 0x75, 0x5a, 0xc3, 0x41, 0xbb, 0xa9, 0x05, 0x76, 0x4f, 0x11, 0x72,
	0xcd, 0x5e, 0x4f, 0xc9, 0xa9, 0x2d, 0xc6, 0x60, 0xe1, 0xd8, 0x1c, 0xc0, 0x6e, 0x77, 0xd0, 0xee,
	0xe0, 0xf6, 0xc6, 0x60, 0xac, 0xf7, 0x86, 0xc2, 0xa6, 0xc9, 0x90, 0x7d, 0xd8, 0x16, 0x96, 0x0c,
	0x1a, 0x55, 0x1c, 0x91, 0x55, 0xff, 0x7e, 0x06, 0x6e, 0x88, 0x8f, 0x8f, 0x7c, 0x67, 0xf9, 0x92,
	0xac, 0x74, 0x03, 0x30, 0x42, 0xad, 0x63, 0x7c, 0x82, 0x71, 0x6b, 0x89, 0x02, 0x30, 0x59, 0xef,
	0x52, 0x3e, 0xcb, 0x5d, 0xea, 0x5e, 0xdd, 0x84, 0xd2, 0x48, 0x90, 0x29, 0x42, 0x8e, 0xa5, 0xbb,
	0xd1, 0x9e, 0x8f, 0x1e, 0x29, 0x59, 0xf5, 0x9f, 0x67, 0x60, 0x8f, 0x09, 0xaa, 0xb1, 0xf1, 0x2c,
	0x9a, 0x22, 0xf6, 0x16, 0x10, 0x63, 0x3e, 0x77, 0xf8, 0x71, 0x9f, 0xa5, 0xe9, 0x4e, 0x98, 0x07,
	0x86, 0xb7, 0xaf, 0x86, 0x98, 0x63, 0x86, 0xa0, 0x1a, 0x5b, 0x78, 0x16, 0xc2, 0x70, 0xe1, 0x6b,
	0x8e, 0x83, 0x85, 0xd9, 0x12, 0x8d, 0x32, 0xe7, 0x62, 0xa9, 0xbe, 0xea, 0xdb, 0x70, 0x28, 0x37,
	0x28, 0xe4, 0x24, 0x91, 0x62, 0xd0, 0xeb, 0xf3, 0xac, 0xc4, 0xfe, 0xa3, 0xb1, 0x92, 0x55, 0x7f,
	0x27, 0xe8, 0x41, 0xff, 0xba, 0x3d, 0xc8, 0xa4, 0xf7, 0x20, 0xe6, 0x64, 0x65, 0xaf, 0xe3, 0x64,
	0xe5, 0xd2, 0x9c, 0xac, 0x9f, 0x06, 0x62, 0x1b, 0x18, 0xec, 0x94, 0xab, 0xb2, 0x15, 0xab, 0x30,
	0x4c, 0x58, 0x5b, 0xfd, 0xf5, 0x2c, 0x1c, 0x34, 0xc3, 0x9b, 0xbf, 0x5f, 0x4e, 0x37, 0xbf, 0x09,
	0x5b, 0xc1, 0xa8, 0x07, 0x42, 0x94, 0xb5, 0x5c, 0x11, 0xe3, 0x1e, 0x78, 0x91, 0xe1, 0x9f, 0xbf,
	0x7d, 0x1c, 0x2a, 0x39, 0xa5, 0x30, 0x87, 0x19, 0x2c, 0x91, 0x3f, 0x7f, 0xc7, 0x39, 0x42, 0xfc,
	0xf9, 0x3b, 0xc1, 0x29, 0x21, 0xdd, 0x45, 0x82, 0x6e, 0x3e, 0x49, 0xb7, 0xbf, 0x86, 0x6e, 0x1c,
	0xae, 0xfe, 0x4e, 0x36, 0x8c, 0x4a, 0x48, 0x23, 0x74, 0xfd, 0x35, 0x95, 0x90, 0xb1, 0xfc, 0x4f,
	0x39, 0x11, 0x19, 0x9b, 0x94, 0x83, 0xb9, 0x6b, 0xcb, 0xc1, 0xfb, 0x50, 0x5d, 0x1a, 0xbe, 0x6f,
	0xba, 0xb6, 0x3e, 0x37, 0x67, 0x1e, 0xbf, 0x65, 0x84, 0x27, 0x66, 0xae, 0x9d, 0x54, 0xad, 0xc2,
	0x5f, 0xea, 0x99, 0x33, 0x4f, 0x7d, 0x0a, 0x0a, 0xad, 0x19, 0x11, 0x83, 0x29, 0x32, 0x2e, 0x83,
	0xc0, 0x56, 0xab, 0x73, 0x3c, 0x0e, 0xa3, 0xb5, 0x59, 0xea, 0x62, 0x1d, 0x6b, 0x9d, 0x51, 0x47,
	0x7b, 0xdc, 0xd1, 0x3f, 0x3c, 0xe9, 0x9c, 0x74, 0x74, 0x71, 0xf6, 0x4a, 0xc9, 0xa9, 0xff, 0x32,
	0x17, 0x9e, 0x68, 0x4c, 0xe6, 0x80, 0xfe, 0x1c, 0xec, 0xf3, 0x69, 0x63, 0xeb, 0x31, 0x92, 0x60,
	0x4a, 0xfb, 0xf1, 0x6a, 0x74, 0x87, 0x31, 0x35, 0x30, 0xa4, 0xed, 0x2e, 0x52, 0xe3, 0x45, 0xdf,
	0x83, 0x3d, 0xb6, 0x97, 0x97, 0xa0, 0x9d, 0x95, 0x2f, 0xa3, 0xbd, 0x4c, 0xf9, 0x6a, 0x3b, 0xf3,
	0x34, 0x95, 0x7c, 0x02, 0xbb, 0x28, 0x28, 0x13, 0x84, 0x23, 0xa1, 0xbf, 0x4b, 0x24, 0xb1, 0xb6,
	0xed, 0xa5, 0x88, 0xe7, 0xef, 0xc3, 0x9e, 0x74, 0xff, 0x7e, 0x94, 0x85, 0x53, 0x06, 0x23, 0x95,
	0x1f, 0xb5, 0x5d, 0x23, 0x95, 0x4d, 0x1f, 0x00, 0xd5, 0x7b, 0x32, 0xcd, 0x82, 0xfc, 0xb3, 0xfa,
	0xf5, 0x51, 0x3d, 0xad, 0x36, 0x97, 0x8b, 0xea, 0xdf, 0xca, 0x41, 0x3d, 0xfa, 0x9b, 0xe2, 0xcf,
	0x31, 0xeb, 0x27, 0x1a, 0x22, 0xcc, 0xc5, 0x13, 0x27, 0x62, 0xe1, 0xfd, 0x7c, 0x22, 0xbc, 0xff,
	0x35, 0xd8, 0xa3, 0x1f, 0xc0, 0x4b, 0x94, 0xf1, 0x84, 0xbd, 0x38, 0xfb, 0x88, 0xd1, 0xf9, 0x92,
	0xb6, 0x6d, 0x79, 0x23, 0x8a, 0x1c, 0x2e, 0x4d, 0x5b, 0x74, 0x82, 0x7c, 0x83, 0x9f, 0xc6, 0x0f,
	0xea, 0x6e, 0xc8, 0x17, 0xf5, 0xc8, 0x55, 0xb5, 0xaa, 0x23, 0xbf, 0x38, 0x86, 0xc6, 0x72, 0xe5,
	0x4e, 0xce, 0x0d, 0x4f, 0xfe, 0xaf, 0x2f, 0x1e, 0xf4, 0xe5, 0xb6, 0x08, 0xb7, 0xd6, 0x8f, 0x79,
	0x2d, 0xf1, 0x1b, 0x5f, 0x3c, 0xef, 0xab, 0xed, 0x2e, 0xd3, 0xc0, 0xe9, 0x19, 0x28, 0xa5, 0x97,
	0x3b, 0xf1, 0xac, 0xfe, 0xdb, 0x0c, 0x54, 0x23, 0x9d, 0x8c, 0xdf, 0x76, 0xc5, 0x63, 0xf0, 0xd9,
	0x70, 0xcb, 0x21, 0xd8, 0xae, 0x60, 0x71, 0x79, 0xbe, 0x5d, 0x11, 0xdd, 0xe3, 0xc8, 0xc7, 0xf7,
	0x38, 0x92, 0xfb, 0x29, 0x85, 0xeb, 0xed, 0xa7, 0xb0, 0x94, 0xb2, 0xe8, 0x7e, 0x8a, 0xb4, 0x8b,
	0x31, 0x33, 0xd8, 0x61, 0xed, 0xac, 0xb4, 0x8b, 0x81, 0x30, 0xf5, 0xaf, 0x64, 0x60, 0x37, 0x75,
	0x3c, 0x13, 0x5d, 0xfc, 0x0a, 0xec, 0xb8, 0xa6, 0x31, 0xb7, 0x7e, 0x68, 0x4e, 0xd9, 0xaf, 0x8e,
	0x7d, 0x7d, 0xee, 0x78, 0x1e, 0xbf, 0x62, 0x9e, 0x08, 0x1c, 0xfe, 0xce, 0xd8, 0xef, 0x39, 0x9e,
	0x47, 0x39, 0x01, 0x0f, 0xa4, 0x9a, 0x53, 0x9d, 0xa5, 0x45, 0xe4, 0x64, 0x4e, 0xe8, 0x33, 0x14,
	0xcb, 0x8e, 0xa8, 0x2e, 0xa4, 0x92, 0xfa, 0x9f, 0x32, 0x50, 0x95, 0xd1, 0x62, 0x78, 0x33, 0xe1,
	0xf0, 0xb2, 0x63, 0x30, 0xc8, 0x9a, 0xe2, 0x1c, 0x14, 0x67, 0xc6, 0x9f, 0x94, 0x91, 0xff, 0xdd,
	0x2c, 0x28, 0xf1, 0xff, 0x8b, 0xff, 0xf8, 0xd6, 0xfe, 0x65, 0x17, 0xab, 0xdd, 0x85, 0x2a, 0xbb,
	0x3e, 0x8d, 0x5f, 0x52, 0xc6, 0x6e, 0x57, 0x63, 0x57, 0xaa, 0xb1, 0x2b, 0xca, 0xd8, 0xd1, 0x71,
	0xe4, 0x1a, 0xb4, 0x0e, 0x9c, 0x17, 0xa6, 0xcb, 0xaf, 0x59, 0xdb, 0x0c, 0xe1, 0xc7, 0x14, 0x1c,
	0xde, 0xb5, 0x96, 0x91, 0xee, 0x5a, 0x5b, 0x3c, 0x17, 0xae, 0x27, 0xde, 0xac, 0x86, 0x90, 0x33,
	0xf4, 0x15, 0x11, 0x82, 0xbf, 0xe1, 0xe2, 0x77, 0xcc, 0x4f, 0x5c, 0x73, 0x6a, 0xf9, 0xdc, 0xe3,
	0xe4, 0x17, 0xcf, 0xb7, 0x10, 0xa6, 0xfe, 0x4a, 0x06, 0x48, 0xf2, 0x00, 0xe3, 0x55, 0xc7, 0xdf,
	0xe4, 0x8d, 0xad, 0x6c, 0x34, 0xe7, 0x51, 0xda, 0x27, 0xcb, 0x45, 0xf6, 0xc9, 0x12, 0xd9, 0x9e,
	0xf9, 0x64, 0x4a, 0xf4, 0x5f, 0xcc, 0x80, 0x12, 0x3f, 0x05, 0xf9, 0x7f, 0xab, 0x2d, 0xbf, 0x98,
	0x81, 0x92, 0x38, 0x54, 0xf9, 0x79, 0xb5, 0x21, 0xf3, 0x92, 0x6d, 0xf8, 0xb5, 0xac, 0xb0, 0xe3,
	0xe3, 0xff, 0xb3, 0xbf, 0xfa, 0x97, 0x12, 0x3b, 0x50, 0x60, 0xff, 0xf4, 0x63, 0x12, 0x95, 0x15,
	0xc8, 0xb7, 0xe0, 0x50, 0x5c, 0x73, 0xb2, 0x34, 0x3c, 0x5f, 0xc4, 0xee, 0xf1, 0x64, 0x8e, 0x27,
	0xfe, 0xf5, 0xcb, 0x6b, 0x1c, 0x1b, 0x9e, 0xcf, 0xbe, 0x8e, 0x57, 0xfe, 0x79, 0x6b, 0xae, 0x7b,
	0xcc, 0xaf, 0xb9, 0xee, 0xf1, 0x69, 0xf2, 0x5f, 0xeb, 0x00, 0x1b, 0xfc, 0x6f, 0xea, 0xf8, 0x6b,
	0x36, 0xf6, 0xcc, 0xff, 0xb8, 0xbe, 0x07, 0x24, 0x2c, 0xeb, 0x8f, 0x87, 0xbd, 0x93, 0x7e, 0x67,
	0xc4, 0x4e, 0xb6, 0x4b, 0xf0, 0xf6, 0xb0, 0xaf, 0xe4, 0xd5, 0xff, 0x96, 0x85, 0x9b, 0xfd, 0xcb,
	0xfe, 0xf3, 0x7f, 0xe5, 0xe8, 0x5c, 0x79, 0x78, 0x3d, 0x18, 0xbe, 0x9c, 0x3c, 0x7c, 0xd7, 0xb8,
	0xd2, 0x39, 0x7d, 0x90, 0x0a, 0x6b, 0x06, 0xe9, 0x37, 0x33, 0x9f, 0xfa, 0x04, 0x7c, 0xf2, 0xd7,
	0x7f, 0x69, 0x7f, 0x85, 0xc2, 0x2b, 0x61, 0x3b, 0xbd, 0xce, 0xb8, 0x73, 0xd5, 0xc5, 0xae, 0xe4,
	0x26, 0x34, 0xf8, 0x8d, 0x03, 0x7a, 0xab, 0x77, 0x32, 0x1a, 0x77, 0x34, 0xfc, 0x93, 0x1e, 0x26,
	0x88, 0x7c, 0xa4, 0xfe, 0x4a, 0x36, 0xfc, 0xa3, 0x7e, 0x38, 0xf6, 0x57, 0x8f, 0xf4, 0x5d, 0x28,
	0x7c, 0xbc, 0x72, 0x7c, 0xf1, 0x33, 0x63, 0x9e, 0xd1, 0xf7, 0x21, 0x05, 0x69, 0x0c, 0x13, 0x97,
	0xc4, 0xb9, 0x84, 0x24, 0x7e, 0x89, 0x5f, 0x55, 0xa2, 0xc6, 0x94, 0x79, 0xba, 0x10, 0xd5, 0x98,
	0x21, 0x3b, 0xa3, 0x24, 0xbc, 0x8a, 0xb9, 0x37, 0xd6, 0xcc, 0xdb, 0xaf, 0x66, 0xa1, 0x80, 0x7d,
	0x58, 0xb7, 0x5d, 0x8f, 0x3d, 0x4b, 0xdc, 0x81, 0x83, 0x50, 0xe9, 0x0e, 0xa0, 0x50, 0xcb, 0x06,
	0xe9, 0x18, 0x7b, 0xb0, 0x21, 0x6d, 0x57, 0xe4, 0x35, 0x5e, 0x22, 0x37, 0xa1, 0x6c, 0xd9, 0x53,
	0x6b, 0x62, 0xf8, 0xf8, 0xdb, 0x4d, 0xaa, 0xd1, 0x42, 0x80, 0xda, 0xe7, 0xc7, 0x0d, 0xd8, 0x61,
	0xc2, 0x76, 0x87, 0xfd, 0x43, 0x6c, 0xcd, 0x59, 0x3e, 0x1e, 0xf2, 0xc8, 0x89, 0x90, 0x47, 0x1e,
	0xef, 0x11, 0xee, 0x8c, 0xc7, 0xbd, 0x4e, 0xbf, 0x33, 0x18, 0x2b, 0x05, 0xf5, 0x6b, 0x50, 0xee,
	0x0a, 0xda, 0x74, 0xfd, 0x0e, 0x8f, 0x3b, 0x03, 0x7e, 0x65, 0x44, 0xf7, 0xc1, 0x43, 0x46, 0xa2,
	0x37, 0x7c, 0xc2, 0x4e, 0x2f, 0xb6, 0x7a, 0xc3, 0x51, 0x47, 0xc9, 0xab, 0xff, 0x28, 0x47, 0x6d,
	0x0e, 0x69, 0x48, 0x6f, 0x01, 0x30, 0x3b, 0x16, 0x7b, 0xc9, 0xee, 0xf3, 0x2a, 0xa3, 0xc1, 0x2a,
	0xec, 0x89, 0x73, 0x6b, 0x76, 0xce, 0xd1, 0x59, 0x86, 0xa6, 0x90, 0xe0, 0xb7, 0x40, 0x73, 0xe7,
	0x45, 0xf0, 0x5b, 0x1f, 0x8a, 0x2d, 0xcd, 0x9d, 0x17, 0x41, 0x5a, 0x24, 0xbb, 0x61, 0x8a, 0xa1,
	0xf3, 0x2c, 0x2d, 0x12, 0x41, 0xac, 0xc2, 0x57, 0x61, 0xe7, 0xc2, 0xa4, 0x93, 0x35, 0x35, 0x2e,
	0xf0, 0xe7, 0xc3, 0x73, 0xb6, 0x5b, 0xce, 0xfe, 0xc9, 0xb7, 0x1d, 0xe0, 0x46, 0x01, 0x2a, 0x54,
	0xda, 0x7c, 0xfc, 0xf9, 0x95, 0x2a, 0xec, 0xd2, 0x53, 0x36, 0x09, 0xaf, 0xc3, 0x66, 0x48, 0x95,
	0x9d, 0x20, 0x2e, 0xb2, 0xb4, 0xcd, 0x00, 0xcc, 0x0e, 0x12, 0xbf, 0x0e, 0x9b, 0x7c, 0x72, 0xac,
	0xe7, 0xec, 0x0a, 0x2e, 0x9e, 0xeb, 0x5a, 0x0f, 0xc1, 0xd4, 0x1c, 0xc6, 0xad, 0x4e, 0xe3, 0x82,
	0x3b, 0xeb, 0x65, 0x64, 0x84, 0xd2, 0xd4, 0xb8, 0x08, 0x7d, 0x75, 0x3a, 0x80, 0x16, 0xe6, 0x9c,
	0x7b, 0x3e, 0x3f, 0xf6, 0x86, 0x46, 0x7f, 0x97, 0xc3, 0xf0, 0x20, 0x31, 0xfe, 0x41, 0x87, 0xb5,
	0xba, 0xc2, 0x0f, 0x12, 0x5b, 0x93, 0x67, 0xbc, 0xd1, 0xb7, 0x01, 0xa4, 0x01, 0x60, 0x69, 0xa6,
	0x12, 0x44, 0xfd, 0x01, 0x34, 0x34, 0xd3, 0x98, 0x46, 0x8f, 0x04, 0x5d, 0xef, 0x16, 0x8b, 0x2f,
	0x40, 0x3d, 0x3c, 0xd2, 0xcb, 0xef, 0x64, 0xca, 0xdd, 0x2b, 0x6b, 0xb5, 0x00, 0x8a, 0x97, 0x08,
	0xfd, 0xef, 0x0c, 0xec, 0xa7, 0x7c, 0x02, 0x7f, 0xc0, 0x77, 0x9d, 0xfb, 0x01, 0x2e, 0xfb, 0xf5,
	0xde, 0x67, 0x39, 0xe8, 0x74, 0xb5, 0x38, 0x57, 0x5b, 0xd7, 0xfc, 0x49, 0xdf, 0xa5, 0xf7, 0x91,
	0xbc, 0x80, 0xc3, 0x94, 0x93, 0x5e, 0xd7, 0x1c, 0xe3, 0x64, 0x07, 0xb3, 0xd7, 0xed, 0xa0, 0xfa,
	0xfb, 0x19, 0x38, 0x48, 0xfd, 0xf2, 0xe7, 0x32, 0xf4, 0xd7, 0xb8, 0x9a, 0xe1, 0x73, 0x19, 0xbe,
	0xdf, 0xcd, 0xc0, 0x1e, 0x95, 0x98, 0xc2, 0xbb, 0x92, 0xa2, 0x08, 0x9f, 0xd2, 0x0c, 0x4a, 0xb9,
	0xc2, 0x2d, 0xfb, 0x92, 0x57, 0xb8, 0xa9, 0x6f, 0x0a, 0xfb, 0x46, 0xb6, 0x6a, 0xd6, 0x58, 0x31,
	0xea, 0xbf, 0xce, 0xc0, 0xb6, 0xdc, 0x85, 0x6b, 0xce, 0xfd, 0x13, 0x38, 0xc0, 0x6b, 0xde, 0x42,
	0x67, 0x3e, 0x12, 0x34, 0x92, 0xf2, 0xa6, 0xd2, 0xc7, 0x47, 0xdb, 0xf3, 0xd3, 0xc7, 0x0d, 0xff,
	0xad, 0xcb, 0xbe, 0x2b, 0x5d, 0x5a, 0x55, 0xe1, 0x30, 0x0c, 0x3a, 0xdf, 0x81, 0x8a, 0x16, 0x16,
	0xf1, 0x58, 0x79, 0x67, 0xcc, 0x94, 0x40, 0x5b, 0x1b, 0x1e, 0x2b, 0x39, 0xf5, 0x1f, 0xe4, 0x80,
	0x44, 0x3b, 0x85, 0xd7, 0x75, 0x7d, 0x76, 0xb6, 0xe2, 0x16, 0x43, 0x6e, 0xad, 0xc5, 0xf0, 0x2a,
	0xd4, 0x57, 0x4b, 0x3d, 0x3e, 0x3d, 0x39, 0xad, 0xb2, 0x5a, 0x8e, 0x83, 0x3b, 0xf6, 0xd2, 0x7f,
	0xea, 0x51, 0xb8, 0xf4, 0xa7, 0x1e, 0x71, 0x96, 0xde, 0x48, 0x1a, 0x78, 0x91, 0x4b, 0xf3, 0x8a,
	0xf1, 0x4b, 0xf3, 0xfe, 0x7a, 0xe6, 0x52, 0x8e, 0x0f, 0x6f, 0xe7, 0xbf, 0xe2, 0x46, 0xfe, 0x14,
	0x4b, 0x2e, 0x76, 0x49, 0xff, 0x01, 0xec, 0x0e, 0x4f, 0xc6, 0xa3, 0x6e, 0xbb, 0xa3, 0x37, 0x7b,
	0xbd, 0xe1, 0x93, 0x4e, 0x5b, 0xd7, 0x9a, 0x83, 0x07, 0x1d, 0xc5, 0xba, 0x6c, 0x35, 0x7d, 0xa4,
	0xfe, 0x7e, 0x16, 0xb6, 0xe8, 0xf8, 0xdc, 0x37, 0xdc, 0x97, 0x59, 0x48, 0x07, 0x50, 0x3a, 0x35,
	0x5c, 0x7d, 0x65, 0x5b, 0x62, 0x13, 0xa3, 0x78, 0x6a, 0xb8, 0x27, 0xb6, 0x85, 0x8a, 0x93, 0x82,
	0x83, 0x4b, 0xcb, 0x38, 0x33, 0x21, 0x8c, 0x5f, 0x57, 0x96, 0x58, 0x70, 0xf9, 0x2b, 0x17, 0x5c,
	0x21, 0x7e, 0x67, 0xe2, 0xeb, 0xb0, 0xb9, 0xf2, 0x4c, 0x49, 0x99, 0x7b, 0xe2, 0x5a, 0xfa, 0x95,
	0x67, 0x86, 0x7a, 0xdc, 0x53, 0x4f, 0xa1, 0x78, 0x9f, 0x37, 0xad, 0x04, 0xf9, 0xa7, 0x9d, 0xa6,
	0xc6, 0x72, 0x74, 0x46, 0x9d, 0x7e, 0x57, 0x6f, 0x0e, 0x70, 0x2b, 0x0d, 0x0f, 0x00, 0x7d, 0x78,
	0xd2, 0xd4, 0xc6, 0x1d, 0x8d, 0x99, 0x31, 0xfd, 0xe1, 0x60, 0xfc, 0x90, 0xfd, 0xfa, 0xfe, 0x49,
	0xa7, 0xc3, 0xef, 0x4d, 0x68, 0x37, 0x9f, 0x2a, 0x1b, 0x68, 0xf7, 0x0c, 0x4f, 0x34, 0x76, 0x71,
	0x42, 0xbf, 0x3b, 0x50, 0x4a, 0xea, 0x1f, 0x65, 0xa0, 0xce, 0x47, 0xf1, 0x9a, 0x6b, 0xf9, 0x01,
	0x6c, 0xe3, 0x5a, 0xa6, 0xa3, 0x98, 0x58, 0xc5, 0xfb, 0xe1, 0x2a, 0x8e, 0xcc, 0x8b, 0xb6, 0xe5,
	0x27, 0xa6, 0xea, 0x1a, 0x6b, 0xf7, 0xcb, 0x6b, 0xd6, 0x2e, 0x9e, 0x50, 0xe2, 0xff, 0x8b, 0x60,
	0x17, 0x7f, 0xf1, 0xa5, 0xfc, 0x5f, 0x72, 0x50, 0xe4, 0x1f, 0x27, 0x77, 0xa0, 0x8a, 0x33, 0x1d,
	0xbd, 0x32, 0x14, 0xe8, 0x6c, 0x87, 0x79, 0xc6, 0x92, 0x61, 0x97, 0xbd, 0xdc, 0xb0, 0xcb, 0x5d,
	0x6a, 0xd8, 0xe5, 0x2f, 0x37, 0xec, 0x0a, 0x09, 0xc3, 0x2e, 0xb4, 0x8f, 0x37, 0x22, 0xf6, 0x71,
	0x34, 0x3a, 0x55, 0xe4, 0xcc, 0x13, 0x44, 0xa7, 0xd0, 0x85, 0x58, 0x2c, 0x9c, 0xa9, 0xe5, 0x5f,
	0x08, 0x53, 0xa9, 0x84, 0x04, 0x36, 0x03, 0x38, 0xb7, 0x97, 0x12, 0x56, 0x57, 0x99, 0xef, 0x42,
	0xcb, 0x56, 0xd7, 0xd7, 0x61, 0x3f, 0xa4, 0x97, 0x34, 0xd2, 0x6a, 0xda, 0x6e, 0x80, 0x1e, 0xca,
	0xef, 0x7d, 0x09, 0x94, 0x90, 0x81, 0x23, 0x37, 0xe3, 0x6c, 0x86, 0xf0, 0x60, 0x28, 0x64, 0xc3,
	0xae, 0xca, 0xce, 0x6b, 0x49, 0x86, 0xdd, 0x3b, 0x10, 0x7e, 0x44, 0x97, 0xab, 0xd6, 0xb0, 0xea,
	0x76, 0x80, 0x1c, 0x07, 0xef, 0xa8, 0x7f, 0x9a, 0x83, 0x5a, 0xc0, 0xb7, 0xd7, 0x14, 0xd7, 0x97,
	0x7b, 0xca, 0xf7, 0xa0, 0x24, 0xf8, 0x3a, 0xfa, 0x6b, 0x0c, 0xf1, 0x99, 0x22, 0x67, 0xe1, 0xff,
	0x87, 0xa5, 0xf6, 0x1f, 0xff, 0x18, 0xfe, 0xb1, 0xf2, 0x99, 0x24, 0x7a, 0xd2, 0xd9, 0xff, 0xe8,
	0x32, 0x29, 0xff, 0x4c, 0xfd, 0x93, 0x0c, 0xec, 0xb0, 0x29, 0xc7, 0x70, 0xf2, 0xfc, 0xba, 0xd6,
	0xe6, 0x53, 0x38, 0xe0, 0xb9, 0x2a, 0x4b, 0xf6, 0x5e, 0x52, 0x56, 0xf1, 0x44, 0x9a, 0x08, 0x75,
	0x49, 0x62, 0xed, 0x3f, 0x4f, 0x47, 0x7c, 0x3e, 0x36, 0xc7, 0x2f, 0x65, 0x60, 0x7f, 0xcd, 0x97,
	0xaf, 0xd6, 0x61, 0x9f, 0xd7, 0xdd, 0xb4, 0xbf, 0x95, 0x83, 0xed, 0xd8, 0xe0, 0x7e, 0x2e, 0x96,
	0x4f, 0x17, 0x76, 0x62, 0x83, 0x6f, 0xf9, 0xe6, 0x42, 0xec, 0xe2, 0xed, 0xa7, 0x8c, 0x7b, 0xd7,
	0x37, 0x17, 0x1a, 0x79, 0x1e, 0x07, 0x79, 0xd7, 0x5b, 0x6b, 0xf1, 0x75, 0x53, 0xb8, 0x62, 0xdd,
	0x6c, 0xfc, 0xe4, 0x59, 0x3b, 0x4d, 0xd8, 0x4a, 0x0c, 0x58, 0x18, 0x79, 0xc9, 0xa4, 0x47, 0x5e,
	0xd8, 0xf9, 0x5a, 0x5e, 0x52, 0x6d, 0xd8, 0x5f, 0xf3, 0xa3, 0x42, 0xaa, 0xca, 0xd0, 0xac, 0x91,
	0xae, 0x42, 0x2e, 0x51, 0x00, 0xaa, 0x9c, 0x7d, 0x28, 0xfa, 0x0e, 0x43, 0x31, 0x36, 0xdb, 0xf0,
	0x9d, 0x76, 0x32, 0xba, 0x4e, 0x27, 0x37, 0x72, 0xee, 0x60, 0x00, 0x7b, 0xe9, 0xbf, 0x10, 0x23,
	0xef, 0x42, 0x55, 0x1c, 0x9e, 0xe0, 0x27, 0x84, 0xa5, 0xbf, 0x1e, 0x49, 0xd7, 0x1e, 0x68, 0x15,
	0x27, 0x2c, 0xbc, 0xf1, 0x0e, 0xec, 0x1c, 0xbb, 0x8e, 0xef, 0x4c, 0x9c, 0xf9, 0x63, 0xd3, 0xf5,
	0xf0, 0x3e, 0xf6, 0x8f, 0x1c, 0x97, 0x1c, 0xc2, 0xde, 0xb1, 0x36, 0x1c, 0x0f, 0x5b, 0xc3, 0x9e,
	0xfe, 0xb8, 0xa3, 0x8d, 0xba, 0xc3, 0x81, 0xde, 0x6f, 0x7e, 0x30, 0xd4, 0x94, 0x4c, 0xda, 0x3b,
	0x96, 0xbd, 0xee, 0x9d, 0xee, 0x60, 0xa8, 0x29, 0xed, 0x37, 0x66, 0x50, 0x0e, 0x7e, 0x23, 0x40,
	0x05, 0xe3, 0x68, 0x65, 0x4f, 0x8d, 0x0b, 0x16, 0xf6, 0xed, 0x3b, 0xf8, 0x8c, 0xd2, 0x73, 0xbc,
	0x32, 0x3d, 0x5a, 0xc0, 0x24, 0xeb, 0x27, 0xe6, 0xd4, 0x66, 0xc5, 0x1c, 0x26, 0x55, 0x9f, 0xaf,
	0x5c, 0x2c, 0xb1, 0xcb, 0xb0, 0x5c, 0x8b, 0x3e, 0x17, 0x28, 0x66, 0x64, 0xf8, 0x2b, 0x97, 0x96,
	0x36, 0xfe, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xb6, 0x04, 0xe6, 0xf7, 0x1e, 0xa1, 0x00, 0x00,
}
